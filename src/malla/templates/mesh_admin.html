{% extends "base.html" %}

{% block title %}Mesh Admin - {{ APP_NAME }}{% endblock %}

{% block extra_css %}
<style>
    .admin-card {
        transition: all 0.2s ease;
    }
    .admin-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .node-admin-badge {
        font-size: 0.7rem;
        padding: 2px 6px;
    }
    .command-btn {
        min-width: 120px;
    }
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
    }
    .status-connected {
        background-color: #198754;
        box-shadow: 0 0 8px rgba(25, 135, 84, 0.5);
    }
    .status-disconnected {
        background-color: #dc3545;
    }
    .log-entry {
        font-size: 0.875rem;
    }
    .log-timestamp {
        color: #6c757d;
        font-family: monospace;
    }
    .log-status-success {
        color: #198754;
    }
    .log-status-failed {
        color: #dc3545;
    }
    .log-status-pending {
        color: #ffc107;
    }
    .log-status-timeout {
        color: #fd7e14;
    }
    .log-entry {
        cursor: pointer;
    }
    .log-entry:hover {
        background-color: var(--bs-tertiary-bg);
    }
    .log-details-popover {
        max-width: 450px;
        font-size: 0.8rem;
    }
    .log-details-popover .popover-body {
        padding: 0.75rem;
    }
    .log-details-section {
        margin-bottom: 0.5rem;
    }
    .log-details-section:last-child {
        margin-bottom: 0;
    }
    .log-details-label {
        font-weight: 600;
        color: var(--bs-secondary-color);
        font-size: 0.7rem;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
    }
    .log-details-content {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.75rem;
        background: var(--bs-tertiary-bg);
        padding: 0.5rem;
        border-radius: 0.25rem;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 150px;
        overflow-y: auto;
    }
    [data-bs-theme="dark"] .log-details-content {
        background: #161b22;
    }
    .log-error-content {
        color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
    }
    .log-success-content {
        color: #198754;
    }
    /* Node autocomplete styles */
    .node-autocomplete-container {
        position: relative;
    }
    .node-autocomplete-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        z-index: 1000;
        max-height: 300px;
        overflow-y: auto;
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-top: none;
        border-radius: 0 0 0.375rem 0.375rem;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .node-autocomplete-item {
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        border-bottom: 1px solid var(--bs-border-color);
    }
    .node-autocomplete-item:last-child {
        border-bottom: none;
    }
    .node-autocomplete-item:hover,
    .node-autocomplete-item.active {
        background: var(--bs-primary);
        color: white;
    }
    .node-autocomplete-item .node-name {
        font-weight: 500;
    }
    .node-autocomplete-item .node-id {
        font-size: 0.8rem;
        font-family: monospace;
        opacity: 0.8;
    }
    .autocomplete-section-header {
        padding: 0.5rem 0.75rem;
        background: var(--bs-tertiary-bg);
        border-bottom: 1px solid var(--bs-border-color);
        font-weight: 500;
    }
    .autocomplete-section-footer {
        background: var(--bs-tertiary-bg);
    }
    /* Server logs styling */
    .server-logs-container {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.8rem;
    }
    .server-logs-container .log-entry {
        line-height: 1.4;
    }
    .server-logs-container .log-entry:hover {
        background: var(--bs-secondary-bg);
    }
    .server-logs-container .log-clickable {
        cursor: pointer;
        border-radius: 3px;
        transition: background 0.15s;
    }
    .server-logs-container .log-clickable:hover {
        background: var(--bs-primary-bg-subtle);
        text-decoration: underline;
    }
    .log-filter-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.2rem 0.5rem;
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.75rem;
    }
    .log-filter-badge .btn-close {
        font-size: 0.5rem;
        padding: 0.25rem;
    }
    [data-bs-theme="dark"] .server-logs-container {
        background: #0d1117 !important;
    }
    [data-bs-theme="dark"] .server-logs-container .log-entry:hover {
        background: #161b22;
    }
    [data-bs-theme="dark"] .server-logs-container .log-clickable:hover {
        background: rgba(88, 166, 255, 0.15);
    }
    .config-display {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.8rem;
        background: var(--bs-tertiary-bg);
        color: var(--bs-body-color);
        padding: 1rem;
        border-radius: 0.5rem;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--bs-border-color);
    }
    [data-bs-theme="dark"] .config-display {
        background: #161b22;
        border-color: #30363d;
    }
    .config-form {
        max-height: 500px;
        overflow-y: auto;
        padding: 1rem;
        background: var(--bs-tertiary-bg);
        border-radius: 0.5rem;
        border: 1px solid var(--bs-border-color);
    }
    [data-bs-theme="dark"] .config-form {
        background: #161b22;
        border-color: #30363d;
    }
    .config-form .form-control,
    .config-form .form-select {
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        border-color: var(--bs-border-color);
    }
    .config-form .form-control:focus,
    .config-form .form-select:focus {
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        border-color: var(--bs-primary);
    }
    [data-bs-theme="dark"] .config-form .form-control,
    [data-bs-theme="dark"] .config-form .form-select {
        background-color: #0d1117;
        color: #c9d1d9;
        border-color: #30363d;
    }
    [data-bs-theme="dark"] .config-form .form-control:focus,
    [data-bs-theme="dark"] .config-form .form-select:focus {
        background-color: #0d1117;
        border-color: var(--bs-primary);
    }
    [data-bs-theme="dark"] .config-form .form-control::placeholder {
        color: #6e7681;
    }
    .config-field {
        margin-bottom: 1rem;
    }
    .config-field label {
        font-weight: 500;
        color: var(--bs-body-color);
    }
    .config-field .form-text {
        font-size: 0.75rem;
        color: var(--bs-secondary-color);
    }
    .config-field-unit {
        font-size: 0.8rem;
        color: var(--bs-secondary-color);
    }
    [data-bs-theme="dark"] .config-field-unit {
        color: #8b949e;
    }
    .spinner-border-sm {
        width: 1rem;
        height: 1rem;
    }
    #nodeSearchResults {
        max-height: 300px;
        overflow-y: auto;
    }
    /* Bot activity log styles */
    .bot-activity-log {
        font-size: 0.8rem;
    }
    .bot-activity-entry {
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid var(--bs-border-color);
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
    }
    .bot-activity-entry:last-child {
        border-bottom: none;
    }
    .bot-activity-entry:hover {
        background-color: var(--bs-tertiary-bg);
    }
    .bot-activity-time {
        color: var(--bs-secondary-color);
        font-family: monospace;
        font-size: 0.7rem;
        white-space: nowrap;
        min-width: 70px;
    }
    .bot-activity-icon {
        width: 1.2rem;
        text-align: center;
    }
    .bot-activity-icon.event-command { color: #0d6efd; }
    .bot-activity-icon.event-response { color: #198754; }
    .bot-activity-icon.event-error { color: #dc3545; }
    .bot-activity-icon.event-system { color: #6c757d; }
    .bot-activity-content {
        flex: 1;
        min-width: 0;
    }
    .bot-activity-title {
        font-weight: 500;
    }
    .bot-activity-detail {
        color: var(--bs-secondary-color);
        font-size: 0.75rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .bot-cmd-toggle {
        cursor: pointer;
    }
    .bot-cmd-disabled {
        opacity: 0.5;
        text-decoration: line-through;
    }
    /* Admin status banner styles */
    .admin-status-banner {
        border-radius: 0.5rem;
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
        border: 1px solid;
    }
    .admin-status-banner.status-success {
        background-color: rgba(25, 135, 84, 0.1);
        border-color: rgba(25, 135, 84, 0.3);
    }
    .admin-status-banner.status-warning {
        background-color: rgba(255, 193, 7, 0.1);
        border-color: rgba(255, 193, 7, 0.3);
    }
    .admin-status-banner.status-danger {
        background-color: rgba(220, 53, 69, 0.1);
        border-color: rgba(220, 53, 69, 0.3);
    }
    .admin-status-banner .status-icon {
        font-size: 1.25rem;
        margin-right: 0.5rem;
    }
    .admin-status-banner .status-message {
        font-weight: 500;
    }
    .admin-status-banner .status-details {
        font-size: 0.85rem;
        margin-top: 0.5rem;
    }
    .admin-status-banner .check-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0;
    }
    .admin-status-banner .check-item i {
        font-size: 0.9rem;
    }
    .admin-status-banner .check-passed {
        color: #198754;
    }
    .admin-status-banner .check-failed {
        color: #dc3545;
    }
    .admin-status-banner .suggestions {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid var(--bs-border-color);
    }
    .admin-status-banner .suggestion-item {
        font-size: 0.85rem;
        color: var(--bs-secondary-color);
        margin-top: 0.25rem;
    }
    .admin-status-banner .suggestion-item i {
        color: var(--bs-info);
        margin-right: 0.25rem;
    }
    /* Backup tree styles */
    .backup-tree .backup-node-header:hover {
        background-color: var(--bs-secondary-bg) !important;
    }
    .backup-tree .backup-chevron {
        transition: transform 0.15s ease;
        font-size: 0.8rem;
    }
    .backup-tree .backup-item {
        border-radius: 0;
        padding: 0.5rem 0.75rem;
    }
    .backup-tree .backup-item:hover:not(.active) {
        background-color: var(--bs-tertiary-bg);
    }
    .backup-tree .backup-node-children {
        border-left: 2px solid var(--bs-border-color);
        margin-left: 10px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/">Home</a></li>
                    <li class="breadcrumb-item active">Mesh Admin</li>
                </ol>
            </nav>
            <h1>
                <i class="bi bi-gear-wide-connected"></i> Mesh Admin
                <small class="text-muted fs-5">Remote Node Administration</small>
            </h1>
        </div>
    </div>

    <!-- Connection Status Card -->
    <div class="row mb-4">
        <div class="col-lg-6">
            <div class="card admin-card">
                <div class="card-header">
                    <i class="bi bi-wifi"></i> Connection Status
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="connectionTypeSelect" class="form-label"><strong>Connection Type</strong></label>
                            <select class="form-select" id="connectionTypeSelect" onchange="changeConnectionType()">
                                <option value="mqtt" {{ 'selected' if connection_status.connection_type == 'mqtt' else '' }}>MQTT (via broker)</option>
                                <option value="tcp" {{ 'selected' if connection_status.connection_type == 'tcp' else '' }}>TCP (direct connection)</option>
                                <option value="serial" {{ 'selected' if connection_status.connection_type == 'serial' else '' }}>USB/Serial (local device)</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <p class="mb-2 mt-4">
                                <strong>Status:</strong>
                                <span id="connectionStatus">
                                    {% if connection_status.connected %}
                                        <span class="status-indicator status-connected"></span>Connected
                                    {% else %}
                                        <span class="status-indicator status-disconnected"></span>Disconnected
                                    {% endif %}
                                </span>
                            </p>
                        </div>
                    </div>

                    <!-- MQTT Settings -->
                    <div id="mqttSettings" class="{{ 'd-none' if connection_status.connection_type != 'mqtt' else '' }}">
                        <div class="row">
                            <div class="col-md-6">
                                <p class="mb-2">
                                    <strong>MQTT Connected:</strong>
                                    <span id="mqttStatus">
                                        {% if connection_status.mqtt_connected %}
                                            <span class="badge bg-success">Yes</span>
                                        {% else %}
                                            <span class="badge bg-secondary">No</span>
                                        {% endif %}
                                    </span>
                                </p>
                            </div>
                            <div class="col-md-6">
                                <p class="mb-2">
                                    <strong>Gateway Node:</strong>
                                    <span id="gatewayNodeDisplay">
                                        {% if connection_status.gateway_node_hex %}
                                            <code>{{ connection_status.gateway_node_hex }}</code>
                                        {% else %}
                                            <span class="text-warning">Not configured</span>
                                        {% endif %}
                                    </span>
                                </p>
                            </div>
                        </div>
                        <hr>
                        <div class="row">
                            <div class="col">
                                <label for="gatewayNodeInput" class="form-label">Set Gateway Node ID</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="gatewayNodeInput"
                                           placeholder="e.g., !abcd1234 or 2882400052"
                                           value="{{ connection_status.gateway_node_hex or '' }}">
                                    <button class="btn btn-primary" type="button" onclick="setGatewayNode()">
                                        <i class="bi bi-check-lg"></i> Set Gateway
                                    </button>
                                </div>
                                <div class="form-text">
                                    The gateway node is the Meshtastic device connected to the MQTT broker that will relay admin commands.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TCP Settings -->
                    <div id="tcpSettings" class="{{ 'd-none' if connection_status.connection_type != 'tcp' else '' }}">
                        <div class="row mb-3">
                            <div class="col-md-8">
                                <label for="tcpHostInput" class="form-label">Node IP Address</label>
                                <input type="text" class="form-control" id="tcpHostInput"
                                       placeholder="192.168.1.1"
                                       value="{{ connection_status.tcp_host or '192.168.1.1' }}">
                            </div>
                            <div class="col-md-4">
                                <label for="tcpPortInput" class="form-label">Port</label>
                                <input type="number" class="form-control" id="tcpPortInput"
                                       placeholder="4403"
                                       value="{{ connection_status.tcp_port or 4403 }}">
                            </div>
                        </div>
                        <div class="row mb-2">
                            <div class="col">
                                <button class="btn btn-success me-2" type="button" onclick="tcpConnect()" id="tcpConnectBtn">
                                    <i class="bi bi-plug"></i> Connect
                                </button>
                                <button class="btn btn-outline-danger me-2" type="button" onclick="tcpDisconnect()" id="tcpDisconnectBtn">
                                    <i class="bi bi-x-circle"></i> Disconnect
                                </button>
                                <button class="btn btn-outline-warning" type="button" onclick="tcpReconnect()" id="tcpReconnectBtn"
                                        title="Force reconnection - useful if connection appears stale">
                                    <i class="bi bi-arrow-clockwise"></i> Reconnect
                                </button>
                            </div>
                        </div>
                        <div id="tcpConnectResult" class="alert d-none mt-2" role="alert"></div>
                        <div id="tcpHealthWarning" class="alert alert-warning d-none mt-2" role="alert">
                            <i class="bi bi-exclamation-triangle me-2"></i>
                            <span id="tcpHealthWarningText">Connection may be stale.</span>
                            <button class="btn btn-sm btn-warning ms-2" onclick="tcpReconnect()">
                                <i class="bi bi-arrow-clockwise"></i> Reconnect Now
                            </button>
                        </div>
                        <div class="form-text">
                            Connect directly to a Meshtastic node via TCP. The node must have WiFi enabled and be accessible on the network.
                        </div>
                    </div>

                    <!-- Serial/USB Settings -->
                    <div id="serialSettings" class="{{ 'd-none' if connection_status.connection_type != 'serial' else '' }}">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="serialPortSelect" class="form-label">Serial Port</label>
                                <select class="form-select" id="serialPortSelect">
                                    <option value="">-- Select USB/Serial to scan --</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">&nbsp;</label>
                                <button class="btn btn-outline-secondary d-block w-100" type="button" onclick="discoverSerialPorts()">
                                    <i class="bi bi-search"></i> Discover
                                </button>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">&nbsp;</label>
                                <button class="btn btn-outline-info d-block w-100" type="button" onclick="probeSerialDevices()" id="probeDevicesBtn">
                                    <i class="bi bi-cpu"></i> Identify
                                </button>
                            </div>
                        </div>
                        <div id="serialPortInfo" class="alert alert-info d-none mb-3" role="alert">
                            <small></small>
                        </div>
                        <div class="row mb-2">
                            <div class="col">
                                <button class="btn btn-success me-2" type="button" onclick="serialConnect()" id="serialConnectBtn">
                                    <i class="bi bi-usb-plug"></i> Connect
                                </button>
                                <button class="btn btn-outline-danger" type="button" onclick="serialDisconnect()" id="serialDisconnectBtn">
                                    <i class="bi bi-x-circle"></i> Disconnect
                                </button>
                            </div>
                        </div>
                        <div id="serialConnectResult" class="alert d-none mt-2" role="alert"></div>
                        <div class="form-text">
                            <strong>Discover</strong> scans for USB ports. <strong>Identify</strong> connects briefly to detect actual Meshtastic hardware (takes a few seconds per device).
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Test Node Card -->
        <div class="col-lg-6">
            <div class="card admin-card">
                <div class="card-header">
                    <i class="bi bi-search"></i> Test Node Admin Access
                </div>
                <div class="card-body">
                    <p class="text-muted mb-3">
                        Test if a node has this server's public key configured and can be remotely administered.
                    </p>
                    <div class="node-autocomplete-container mb-3">
                        <div class="input-group">
                            <input type="text" class="form-control" id="testNodeInput"
                                   placeholder="Start typing node name or ID..."
                                   autocomplete="off"
                                   oninput="searchNodes(this.value, 'testNodeResults')"
                                   onfocus="if(this.value.length >= 1) searchNodes(this.value, 'testNodeResults')"
                                   onblur="setTimeout(() => hideAutocomplete('testNodeResults'), 200)">
                            <button class="btn btn-outline-primary" type="button" onclick="testNodeAdmin()" id="testNodeBtn">
                                <i class="bi bi-lightning"></i> Test
                            </button>
                        </div>
                        <div id="testNodeResults" class="node-autocomplete-results" style="display:none;"></div>
                    </div>
                    <div id="testNodeResult" class="alert d-none" role="alert"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Tabs -->
    <div class="row">
        <div class="col">
            <ul class="nav nav-tabs" id="adminTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="nodes-tab" data-bs-toggle="tab"
                            data-bs-target="#nodes-pane" type="button" role="tab">
                        <i class="bi bi-router"></i> Administrable Nodes
                        <span class="badge bg-primary">{{ administrable_nodes|length }}</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="commands-tab" data-bs-toggle="tab"
                            data-bs-target="#commands-pane" type="button" role="tab">
                        <i class="bi bi-gear"></i> Node Config
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="templates-tab" data-bs-toggle="tab"
                            data-bs-target="#templates-pane" type="button" role="tab">
                        <i class="bi bi-file-earmark-code"></i> Config Templates
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="backups-tab" data-bs-toggle="tab"
                            data-bs-target="#backups-pane" type="button" role="tab">
                        <i class="bi bi-cloud-download"></i> Node Backups
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="jobs-tab" data-bs-toggle="tab"
                            data-bs-target="#jobs-pane" type="button" role="tab">
                        <i class="bi bi-list-task"></i> Background Jobs
                        <span class="badge bg-secondary" id="jobsTabBadge">0</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="log-tab" data-bs-toggle="tab"
                            data-bs-target="#log-pane" type="button" role="tab">
                        <i class="bi bi-journal-text"></i> Audit Log
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="server-logs-tab" data-bs-toggle="tab"
                            data-bs-target="#server-logs-pane" type="button" role="tab">
                        <i class="bi bi-terminal"></i> Server Logs
                        <span class="badge bg-danger d-none" id="serverLogsErrorBadge">0</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="bot-tab" data-bs-toggle="tab"
                            data-bs-target="#bot-pane" type="button" role="tab">
                        <i class="bi bi-robot"></i> Mesh Bot
                        <span class="badge bg-success d-none" id="botRunningBadge">Running</span>
                    </button>
                </li>
            </ul>

            <div class="tab-content border border-top-0 rounded-bottom p-3" id="adminTabContent">
                <!-- Administrable Nodes Tab -->
                <div class="tab-pane fade show active" id="nodes-pane" role="tabpanel">
                    {% if administrable_nodes %}
                        <!-- Refresh All Controls -->
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <span class="text-muted small" id="refreshAllStatus"></span>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <button class="btn btn-outline-primary btn-sm" id="refreshAllNodesBtn" onclick="refreshAllAdminNodes()">
                                    <i class="bi bi-arrow-repeat"></i> Refresh All Nodes
                                </button>
                                <button class="btn btn-outline-danger btn-sm d-none" id="cancelRefreshAllBtn" onclick="cancelRefreshAllNodes()">
                                    <i class="bi bi-x-circle"></i> Cancel
                                </button>
                            </div>
                        </div>
                        <!-- Progress bar for refresh all -->
                        <div class="progress mb-3 d-none" id="refreshAllProgress" style="height: 6px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                        </div>
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Node</th>
                                        <th>Hardware</th>
                                        <th>Firmware</th>
                                        <th>Uptime</th>
                                        <th>Capabilities</th>
                                        <th>Status</th>
                                        <th>Last Confirmed</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="administrableNodesBody">
                                    {% for node in administrable_nodes %}
                                    <tr id="admin-node-row-{{ node.node_id }}">
                                        <td>
                                            <a href="/node/{{ node.node_id }}" class="text-decoration-none">
                                                <strong>{{ node.long_name or node.short_name or 'Unknown' }}</strong>
                                            </a>
                                            <br>
                                            <code class="text-muted small">{{ node.hex_id or ('!' + '%08x'|format(node.node_id)) }}</code>
                                        </td>
                                        <td id="admin-node-hw-{{ node.node_id }}">{{ node.hw_model or 'Unknown' }}</td>
                                        <td id="admin-node-fw-{{ node.node_id }}">{{ node.firmware_version or 'Unknown' }}</td>
                                        <td id="admin-node-uptime-{{ node.node_id }}">
                                            <span class="text-muted small">—</span>
                                        </td>
                                        <td id="admin-node-caps-{{ node.node_id }}">
                                            <span class="text-muted small">—</span>
                                        </td>
                                        <td id="admin-node-status-{{ node.node_id }}">
                                            {% if node.last_status_result == 'online' %}
                                                <span class="badge bg-success"><i class="bi bi-check-circle"></i> Online</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'timeout' %}
                                                <span class="badge bg-warning text-dark"><i class="bi bi-clock"></i> Timeout</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'error' %}
                                                <span class="badge bg-danger"><i class="bi bi-x-circle"></i> Error</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'offline' %}
                                                <span class="badge bg-danger"><i class="bi bi-x-circle"></i> Offline</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% else %}
                                                <span class="badge bg-secondary">Not checked</span>
                                            {% endif %}
                                        </td>
                                        <td id="admin-node-confirmed-{{ node.node_id }}">
                                            <span class="text-muted small">
                                                {{ node.last_confirmed | timestamp_to_datetime }}
                                            </span>
                                        </td>
                                        <td>
                                            <div class="btn-group btn-group-sm">
                                                <button class="btn btn-outline-success"
                                                        onclick="refreshNodeAdminInfo({{ node.node_id }})"
                                                        title="Refresh admin info"
                                                        id="admin-node-refresh-btn-{{ node.node_id }}">
                                                    <i class="bi bi-arrow-repeat"></i>
                                                </button>
                                                <button class="btn btn-outline-primary"
                                                        onclick="selectNode({{ node.node_id }})"
                                                        title="Select for commands">
                                                    <i class="bi bi-cursor"></i>
                                                </button>
                                                <button class="btn btn-outline-info"
                                                        onclick="getNodeConfig({{ node.node_id }}, 'device')"
                                                        title="Get device config">
                                                    <i class="bi bi-gear"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    {% else %}
                        <div class="text-center py-5">
                            <i class="bi bi-inbox text-muted" style="font-size: 4rem;"></i>
                            <h4 class="mt-3">No Administrable Nodes Found</h4>
                            <p class="text-muted">
                                Nodes will appear here once they respond to admin requests.<br>
                                Use the "Test Node Admin Access" feature above to check if a node is administrable.
                            </p>
                        </div>
                    {% endif %}
                </div>

                <!-- Node Config Tab -->
                <div class="tab-pane fade" id="commands-pane" role="tabpanel">
                    <div class="row">
                        <div class="col-lg-6">
                            <div class="mb-3 node-autocomplete-container">
                                <label for="targetNodeInput" class="form-label">Target Node</label>
                                <input type="text" class="form-control" id="targetNodeInput"
                                       placeholder="Click to select or type to search..."
                                       autocomplete="off"
                                       oninput="onTargetNodeInput(this.value)"
                                       onfocus="showNodeSelector()"
                                       onblur="setTimeout(() => hideAutocomplete('targetNodeResults'), 200)">
                                <div id="targetNodeResults" class="node-autocomplete-results" style="display:none;"></div>
                                <div class="form-text text-muted small">
                                    <i class="bi bi-info-circle"></i> Shows administrable nodes by default. Type to search all known nodes.
                                </div>
                            </div>

                            <!-- Admin Status Banner -->
                            <div id="adminStatusBanner" class="admin-status-banner d-none">
                                <div class="d-flex align-items-start">
                                    <i class="status-icon bi" id="adminStatusIcon"></i>
                                    <div class="flex-grow-1">
                                        <div class="status-message" id="adminStatusMessage"></div>
                                        <div class="status-details" id="adminStatusDetails"></div>
                                        <div class="suggestions" id="adminStatusSuggestions"></div>
                                    </div>
                                    <button type="button" class="btn btn-sm btn-outline-primary ms-2"
                                            onclick="refreshAdminStatus()" title="Refresh status">
                                        <i class="bi bi-arrow-clockwise"></i>
                                    </button>
                                </div>
                            </div>

                            <!-- Session Passkey Status -->
                            <div id="sessionPasskeyStatus" class="alert alert-info py-2 px-3 mb-3 d-none">
                                <div class="d-flex align-items-center justify-content-between">
                                    <div>
                                        <i class="bi bi-key-fill me-2"></i>
                                        <span id="sessionPasskeyCount">0</span> nodes with session passkeys
                                        <span id="sessionPasskeyNodes" class="text-muted small ms-2"></span>
                                    </div>
                                    <div>
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-1"
                                                onclick="refreshSessionPasskeys()" title="Refresh">
                                            <i class="bi bi-arrow-clockwise"></i>
                                        </button>
                                        <button type="button" class="btn btn-sm btn-outline-warning"
                                                onclick="clearSessionPasskeys()" title="Clear all session passkeys (use when node keys change)">
                                            <i class="bi bi-trash"></i> Clear
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Configuration Requests</label>
                                <div class="d-flex flex-wrap gap-2" id="configRequestBtns">
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="device" onclick="getConfig('device', this)">
                                        <i class="bi bi-cpu"></i> Device
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="lora" onclick="getConfig('lora', this)">
                                        <i class="bi bi-broadcast"></i> LoRa
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="position" onclick="getConfig('position', this)">
                                        <i class="bi bi-geo-alt"></i> Position
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="power" onclick="getConfig('power', this)">
                                        <i class="bi bi-battery-charging"></i> Power
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="network" onclick="getConfig('network', this)">
                                        <i class="bi bi-wifi"></i> Network
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="display" onclick="getConfig('display', this)">
                                        <i class="bi bi-display"></i> Display
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="bluetooth" onclick="getConfig('bluetooth', this)">
                                        <i class="bi bi-bluetooth"></i> Bluetooth
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="security" onclick="getConfig('security', this)">
                                        <i class="bi bi-shield-lock"></i> Security
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Module Configuration Requests</label>
                                <div class="d-flex flex-wrap gap-2" id="moduleConfigRequestBtns">
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="mqtt" onclick="getModuleConfig('mqtt', this)">
                                        <i class="bi bi-cloud"></i> MQTT
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="serial" onclick="getModuleConfig('serial', this)">
                                        <i class="bi bi-usb-plug"></i> Serial
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="telemetry" onclick="getModuleConfig('telemetry', this)">
                                        <i class="bi bi-graph-up"></i> Telemetry
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="neighborinfo" onclick="getModuleConfig('neighborinfo', this)">
                                        <i class="bi bi-people"></i> NeighborInfo
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="storeforward" onclick="getModuleConfig('storeforward', this)">
                                        <i class="bi bi-hdd-stack"></i> Store&amp;Forward
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="rangetest" onclick="getModuleConfig('rangetest', this)">
                                        <i class="bi bi-rulers"></i> Range Test
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="extnotif" onclick="getModuleConfig('extnotif', this)">
                                        <i class="bi bi-bell"></i> Ext Notif
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="cannedmsg" onclick="getModuleConfig('cannedmsg', this)">
                                        <i class="bi bi-chat-square-text"></i> Canned Msg
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="audio" onclick="getModuleConfig('audio', this)">
                                        <i class="bi bi-volume-up"></i> Audio
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="remotehardware" onclick="getModuleConfig('remotehardware', this)">
                                        <i class="bi bi-toggles"></i> Remote HW
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="ambientlighting" onclick="getModuleConfig('ambientlighting', this)">
                                        <i class="bi bi-lightbulb"></i> Ambient Light
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="detectionsensor" onclick="getModuleConfig('detectionsensor', this)">
                                        <i class="bi bi-radar"></i> Detection
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="paxcounter" onclick="getModuleConfig('paxcounter', this)">
                                        <i class="bi bi-person-walking"></i> Paxcounter
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Channel Requests</label>
                                <div class="d-flex flex-wrap gap-2" id="channelRequestBtns">
                                    {% for i in range(8) %}
                                    <button class="btn btn-outline-info btn-sm config-req-btn"
                                            data-channel="{{ i }}" onclick="getChannel({{ i }}, this)">
                                        Ch {{ i }}
                                    </button>
                                    {% endfor %}
                                </div>
                            </div>

                            <hr>

                            <div class="mb-3">
                                <label class="form-label text-danger">Dangerous Commands</label>
                                <div class="d-flex flex-wrap gap-2">
                                    <button class="btn btn-warning command-btn" onclick="confirmRebootTarget()">
                                        <i class="bi bi-arrow-clockwise"></i> Reboot
                                    </button>
                                    <button class="btn btn-danger command-btn" onclick="confirmShutdownTarget()">
                                        <i class="bi bi-power"></i> Shutdown
                                    </button>
                                    <button class="btn btn-outline-warning command-btn" onclick="showNodedbResetModal()">
                                        <i class="bi bi-database-x"></i> Reset NodeDB
                                    </button>
                                    <button class="btn btn-outline-danger command-btn" onclick="showFactoryResetModal()">
                                        <i class="bi bi-exclamation-triangle"></i> Factory Reset
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Node Database Management</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="nodeToRemoveInput"
                                           placeholder="Node ID to remove (e.g., !3ac468fa)">
                                    <button class="btn btn-outline-warning" type="button" onclick="confirmRemoveNode()">
                                        <i class="bi bi-person-x"></i> Remove Node
                                    </button>
                                </div>
                                <div class="form-text">Remove a specific node from the target's nodedb</div>
                            </div>
                        </div>

                        <div class="col-lg-6">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Response</label>
                                <div class="btn-group btn-group-sm" id="responseViewToggle" style="display:none;">
                                    <button type="button" class="btn btn-outline-secondary active" onclick="showFormView()">
                                        <i class="bi bi-ui-checks"></i> Form
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" onclick="showJsonView()">
                                        <i class="bi bi-code-square"></i> JSON/Log
                                    </button>
                                </div>
                            </div>
                            <div id="commandResponseForm" class="config-form" style="display:none;">
                                <form id="configEditForm">
                                    <div id="configFields">
                                        <!-- Dynamic config fields will be rendered here -->
                                    </div>
                                    <div class="d-flex gap-2 mt-3" id="configFormActions" style="display:none;">
                                        <button type="button" class="btn btn-primary" onclick="saveConfig()">
                                            <i class="bi bi-check-lg"></i> Save Changes
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary" onclick="refreshConfig()">
                                            <i class="bi bi-arrow-clockwise"></i> Refresh
                                        </button>
                                    </div>
                                </form>
                            </div>
                            <div id="commandResponse" class="config-display">
                                <span class="text-muted">Response will appear here...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Config Templates Tab -->
                <div class="tab-pane fade" id="templates-pane" role="tabpanel">
                    <div class="row">
                        <!-- Templates List -->
                        <div class="col-md-5">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0"><i class="bi bi-file-earmark-code"></i> Saved Templates</h6>
                                <div class="dropdown">
                                    <button class="btn btn-primary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                        <i class="bi bi-plus-lg"></i> New Template
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-end">
                                        <li><a class="dropdown-item" href="#" onclick="showCreateTemplateModal(); return false;">
                                            <i class="bi bi-pencil"></i> Create Empty Template
                                        </a></li>
                                        <li><a class="dropdown-item" href="#" onclick="showCreateFromNodeModal(); return false;">
                                            <i class="bi bi-download"></i> Create from Node
                                        </a></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="mb-2">
                                <select class="form-select form-select-sm" id="templateTypeFilter" onchange="loadTemplates()">
                                    <option value="">All Types</option>
                                    <option value="device">Device</option>
                                    <option value="lora">LoRa</option>
                                    <option value="channel">Channel (Single)</option>
                                    <option value="channels">Channels (Full Set)</option>
                                    <option value="position">Position</option>
                                    <option value="power">Power</option>
                                    <option value="network">Network</option>
                                    <option value="display">Display</option>
                                    <option value="bluetooth">Bluetooth</option>
                                    <option value="security">Security</option>
                                </select>
                            </div>
                            <div id="templatesList" class="list-group" style="max-height: 400px; overflow-y: auto;">
                                <div class="text-center py-3 text-muted">
                                    <i class="bi bi-arrow-clockwise spin"></i> Loading templates...
                                </div>
                            </div>
                        </div>

                        <!-- Template Editor / Deploy -->
                        <div class="col-md-7">
                            <div id="templateEditorSection" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0" id="templateEditorTitle">
                                        <i class="bi bi-pencil"></i> Edit Template
                                    </h6>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-success" onclick="saveTemplate()" id="saveTemplateBtn">
                                            <i class="bi bi-save"></i> Save
                                        </button>
                                        <button class="btn btn-outline-danger" onclick="deleteTemplate()" id="deleteTemplateBtn">
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Template Name</label>
                                    <input type="text" class="form-control" id="templateName" placeholder="e.g., Standard LoRa Settings">
                                </div>
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label class="form-label">Type</label>
                                        <select class="form-select" id="templateType">
                                            <option value="device">Device</option>
                                            <option value="lora">LoRa</option>
                                            <option value="channel">Channel (Single)</option>
                                            <option value="channels">Channels (Full Set)</option>
                                            <option value="position">Position</option>
                                            <option value="power">Power</option>
                                            <option value="network">Network</option>
                                            <option value="display">Display</option>
                                            <option value="bluetooth">Bluetooth</option>
                                            <option value="security">Security</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label">Description</label>
                                        <input type="text" class="form-control" id="templateDescription" placeholder="Optional description">
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Configuration (JSON)</label>
                                    <textarea class="form-control font-monospace" id="templateConfigData" rows="8"
                                              placeholder='{"region": "US", "modem_preset": "LONG_FAST"}'></textarea>
                                    <div class="form-text">
                                        Enter the configuration as JSON. See
                                        <a href="https://meshtastic.org/docs/configuration/" target="_blank">Meshtastic docs</a>
                                        for available settings.
                                    </div>
                                </div>

                                <!-- Deploy Section -->
                                <div class="card bg-light">
                                    <div class="card-header">
                                        <i class="bi bi-send"></i> Deploy Template
                                    </div>
                                    <div class="card-body">
                                        <div class="mb-3">
                                            <label class="form-label">Select Target Nodes</label>
                                            <div id="deployNodesList" class="border rounded p-2" style="max-height: 150px; overflow-y: auto;">
                                                <span class="text-muted small">Loading administrable nodes...</span>
                                            </div>
                                            <div class="form-text">
                                                <button class="btn btn-link btn-sm p-0" onclick="selectAllDeployNodes()">Select All</button>
                                                |
                                                <button class="btn btn-link btn-sm p-0" onclick="deselectAllDeployNodes()">Deselect All</button>
                                            </div>
                                        </div>
                                        <button class="btn btn-success" onclick="deployTemplate()" id="deployTemplateBtn">
                                            <i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes
                                        </button>
                                        <div id="deploymentResults" class="mt-3" style="display: none;"></div>
                                    </div>
                                </div>

                                <!-- Compliance Check Section -->
                                <div class="card bg-light mt-3">
                                    <div class="card-header d-flex justify-content-between align-items-center">
                                        <span><i class="bi bi-clipboard-check"></i> Compliance Check</span>
                                        <span id="complianceSummaryBadge" class="badge bg-secondary" style="display: none;"></span>
                                    </div>
                                    <div class="card-body">
                                        <p class="text-muted small mb-3">
                                            Check if your administrable nodes match this template's configuration.
                                            Useful for auditing security keys, LoRa settings, or any other config.
                                        </p>

                                        <!-- Node Selection -->
                                        <div class="mb-3">
                                            <label class="form-label small fw-semibold">Nodes to Check</label>
                                            <div class="d-flex gap-2 align-items-center mb-2">
                                                <select id="complianceNodeFilter" class="form-select form-select-sm" style="width: auto;">
                                                    <option value="all">All Admin Nodes</option>
                                                    <option value="selected">Selected Nodes</option>
                                                </select>
                                                <button type="button" class="btn btn-outline-secondary btn-sm" onclick="refreshComplianceNodeList()" title="Refresh node list">
                                                    <i class="bi bi-arrow-clockwise"></i>
                                                </button>
                                            </div>
                                            <div id="complianceNodeSelector" style="display: none;">
                                                <div class="border rounded p-2" style="max-height: 150px; overflow-y: auto; background: #fff;">
                                                    <div id="complianceNodeList" class="d-flex flex-wrap gap-2">
                                                        <span class="text-muted small">Loading nodes...</span>
                                                    </div>
                                                </div>
                                                <div class="mt-1">
                                                    <button type="button" class="btn btn-link btn-sm p-0" onclick="selectAllComplianceNodes(true)">Select All</button>
                                                    <span class="text-muted mx-1">|</span>
                                                    <button type="button" class="btn btn-link btn-sm p-0" onclick="selectAllComplianceNodes(false)">Clear All</button>
                                                    <span class="text-muted ms-2 small" id="complianceSelectedCount"></span>
                                                </div>
                                            </div>
                                        </div>

                                        <div class="d-flex gap-2 flex-wrap">
                                            <button class="btn btn-info btn-sm" onclick="runComplianceCheck()" id="runComplianceBtn">
                                                <i class="bi bi-search"></i> Run Compliance Check
                                            </button>
                                            <button class="btn btn-outline-secondary btn-sm" onclick="loadComplianceResults()" id="loadComplianceBtn">
                                                <i class="bi bi-arrow-repeat"></i> Load Last Results
                                            </button>
                                        </div>

                                        <div id="complianceResults" class="mt-3" style="display: none;">
                                            <div id="complianceProgress" class="mb-2" style="display: none;">
                                                <div class="progress" style="height: 8px;">
                                                    <div class="progress-bar progress-bar-striped progress-bar-animated bg-info"
                                                         id="complianceProgressBar" style="width: 0%"></div>
                                                </div>
                                                <small class="text-muted" id="complianceProgressText">Initializing...</small>
                                            </div>
                                            <div id="complianceResultsContent"></div>

                                            <!-- Fix Actions - shown when there are non-compliant nodes -->
                                            <div id="complianceFixActions" class="mt-3 pt-3 border-top" style="display: none;">
                                                <div class="d-flex justify-content-between align-items-center">
                                                    <div>
                                                        <strong class="text-danger"><i class="bi bi-exclamation-triangle"></i> <span id="nonCompliantCountLabel">0</span> non-compliant node(s)</strong>
                                                        <p class="text-muted small mb-0">Apply the template configuration to make them compliant.</p>
                                                    </div>
                                                    <div class="d-flex flex-column gap-2 align-items-end">
                                                        <div class="form-check">
                                                            <input class="form-check-input" type="checkbox" id="rebootAfterFixCheckbox">
                                                            <label class="form-check-label small" for="rebootAfterFixCheckbox">
                                                                <i class="bi bi-arrow-clockwise"></i> Reboot nodes after fix
                                                                <span class="text-muted">(required for Bluetooth changes)</span>
                                                            </label>
                                                        </div>
                                                        <button class="btn btn-warning btn-sm" onclick="runComplianceFix()" id="runComplianceFixBtn">
                                                            <i class="bi bi-wrench"></i> Fix All Non-Compliant
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div id="templatePlaceholder">
                                <div class="text-center py-5 text-muted">
                                    <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                                    <p class="mt-3">Select a template from the list to edit or deploy,<br>or create a new template.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Deployment History -->
                    <div class="mt-4">
                        <h6><i class="bi bi-clock-history"></i> Recent Deployments</h6>
                        <div id="deploymentHistory" class="table-responsive" style="max-height: 200px; overflow-y: auto;">
                            <table class="table table-sm table-hover">
                                <thead class="table-light sticky-top">
                                    <tr>
                                        <th>Template</th>
                                        <th>Node</th>
                                        <th>Status</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody id="deploymentHistoryBody">
                                    <tr>
                                        <td colspan="4" class="text-center text-muted">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Node Backups Tab -->
                <div class="tab-pane fade" id="backups-pane" role="tabpanel">
                    <div class="row">
                        <!-- Backups List -->
                        <div class="col-md-5">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0"><i class="bi bi-cloud-download"></i> Saved Backups</h6>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-secondary" onclick="toggleAllBackupNodes(true)" title="Expand All">
                                        <i class="bi bi-arrows-expand"></i>
                                    </button>
                                    <button class="btn btn-outline-secondary" onclick="toggleAllBackupNodes(false)" title="Collapse All">
                                        <i class="bi bi-arrows-collapse"></i>
                                    </button>
                                    <button class="btn btn-primary" onclick="showCreateBackupModal()">
                                        <i class="bi bi-plus-lg"></i> Create
                                    </button>
                                </div>
                            </div>
                            <div id="backupsList" class="backup-tree" style="max-height: 500px; overflow-y: auto;">
                                <div class="text-center py-3 text-muted">
                                    <i class="bi bi-arrow-clockwise spin"></i> Loading backups...
                                </div>
                            </div>
                        </div>

                        <!-- Backup Viewer -->
                        <div class="col-md-7">
                            <div id="backupViewerSection" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0" id="backupViewerTitle">
                                        <i class="bi bi-archive"></i> Backup Details
                                    </h6>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-primary" onclick="downloadBackup()" title="Download as JSON">
                                            <i class="bi bi-download"></i> Export
                                        </button>
                                        <button class="btn btn-outline-danger" onclick="deleteBackup()">
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>

                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="row">
                                            <div class="col-md-6">
                                                <strong>Name:</strong> <span id="backupName">-</span><br>
                                                <strong>Node:</strong> <span id="backupNode">-</span><br>
                                                <strong>Created:</strong> <span id="backupCreated">-</span>
                                            </div>
                                            <div class="col-md-6">
                                                <strong>Description:</strong><br>
                                                <span id="backupDescription" class="text-muted">-</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="accordion" id="backupContentsAccordion">
                                    <!-- Core Configs -->
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button" type="button" data-bs-toggle="collapse"
                                                    data-bs-target="#coreConfigsCollapse">
                                                <i class="bi bi-gear me-2"></i> Core Configurations
                                                <span class="badge bg-primary ms-2" id="coreConfigsCount">0</span>
                                            </button>
                                        </h2>
                                        <div id="coreConfigsCollapse" class="accordion-collapse collapse show"
                                             data-bs-parent="#backupContentsAccordion">
                                            <div class="accordion-body" id="coreConfigsContent">
                                                <p class="text-muted">Select a backup to view contents</p>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Module Configs -->
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                                    data-bs-target="#moduleConfigsCollapse">
                                                <i class="bi bi-puzzle me-2"></i> Module Configurations
                                                <span class="badge bg-info ms-2" id="moduleConfigsCount">0</span>
                                            </button>
                                        </h2>
                                        <div id="moduleConfigsCollapse" class="accordion-collapse collapse"
                                             data-bs-parent="#backupContentsAccordion">
                                            <div class="accordion-body" id="moduleConfigsContent">
                                                <p class="text-muted">Select a backup to view contents</p>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Channels -->
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                                    data-bs-target="#channelsCollapse">
                                                <i class="bi bi-broadcast me-2"></i> Channels
                                                <span class="badge bg-success ms-2" id="channelsCount">0</span>
                                            </button>
                                        </h2>
                                        <div id="channelsCollapse" class="accordion-collapse collapse"
                                             data-bs-parent="#backupContentsAccordion">
                                            <div class="accordion-body" id="channelsContent">
                                                <p class="text-muted">Select a backup to view contents</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Restore Section -->
                                <div class="card mt-3 border-warning">
                                    <div class="card-header bg-warning-subtle">
                                        <i class="bi bi-exclamation-triangle"></i> Restore to Node
                                    </div>
                                    <div class="card-body">
                                        <p class="small text-muted mb-2">
                                            Restoring will apply this backup's configuration to the selected node.
                                            This is a potentially destructive operation.
                                        </p>
                                        <div class="row g-2">
                                            <div class="col-md-8">
                                                <select class="form-select form-select-sm" id="restoreTargetNode">
                                                    <option value="">Select target node...</option>
                                                    {% for node in administrable_nodes %}
                                                    <option value="{{ node.node_id }}">
                                                        {{ node.long_name or node.short_name or node.hex_id }}
                                                    </option>
                                                    {% endfor %}
                                                </select>
                                            </div>
                                            <div class="col-md-4">
                                                <button class="btn btn-warning btn-sm w-100" onclick="restoreBackup()"
                                                        id="restoreBackupBtn" disabled>
                                                    <i class="bi bi-arrow-counterclockwise"></i> Restore
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- No Backup Selected Placeholder -->
                            <div id="noBackupSelected" class="text-center py-5 text-muted">
                                <i class="bi bi-cloud-download" style="font-size: 3rem;"></i>
                                <p class="mt-3">Select a backup to view its contents,<br>or create a new backup from a node.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Background Jobs Tab -->
                <div class="tab-pane fade" id="jobs-pane" role="tabpanel">
                    <div class="row">
                        <div class="col-lg-8">
                            <div class="card mb-3">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <span><i class="bi bi-list-task me-2"></i> Background Jobs</span>
                                    <button class="btn btn-outline-primary btn-sm" onclick="refreshJobsList()">
                                        <i class="bi bi-arrow-clockwise"></i> Refresh
                                    </button>
                                </div>
                                <div class="card-body">
                                    <p class="text-muted small mb-3">
                                        Background jobs run on the server and continue even if you close the browser.
                                        You can start a job and come back later to check the result.
                                    </p>
                                    <div id="jobsListContainer">
                                        <div class="text-center py-3 text-muted">
                                            <i class="bi bi-hourglass me-2"></i>
                                            Loading jobs...
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-lg-4">
                            <div class="card">
                                <div class="card-header">
                                    <i class="bi bi-info-circle me-2"></i> Job Queue Status
                                </div>
                                <div class="card-body">
                                    <div id="jobQueueStatus">
                                        <div class="d-flex justify-content-between mb-2">
                                            <span>Running:</span>
                                            <span class="badge bg-primary" id="runningJobsCount">0</span>
                                        </div>
                                        <div class="d-flex justify-content-between mb-2">
                                            <span>Queued:</span>
                                            <span class="badge bg-secondary" id="queuedJobsCount">0</span>
                                        </div>
                                        <hr>
                                        <p class="small text-muted mb-0">
                                            Jobs for the same node run sequentially to prevent conflicts.
                                            Jobs for different nodes can run in parallel.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Audit Log Tab -->
                <div class="tab-pane fade" id="log-pane" role="tabpanel">
                    <div class="mb-3">
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshLog()">
                            <i class="bi bi-arrow-clockwise"></i> Refresh
                        </button>
                    </div>
                    <div id="auditLogContainer">
                        <div class="text-center py-3">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Server Logs Tab -->
                <div class="tab-pane fade" id="server-logs-pane" role="tabpanel">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div class="d-flex align-items-center gap-3">
                            <h5 class="mb-0"><i class="bi bi-terminal me-2"></i>Server Logs</h5>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="serverLogsAutoRefresh" checked>
                                <label class="form-check-label" for="serverLogsAutoRefresh">Auto-refresh</label>
                            </div>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <select class="form-select form-select-sm" id="serverLogsLevelFilter" style="width: auto;">
                                <option value="DEBUG">All Levels</option>
                                <option value="INFO" selected>Info+</option>
                                <option value="WARNING">Warning+</option>
                                <option value="ERROR">Error+</option>
                            </select>
                            <input type="text" class="form-control form-control-sm" id="serverLogsSearch"
                                   placeholder="Search logs..." style="width: 200px;">
                            <button class="btn btn-outline-primary btn-sm" onclick="refreshServerLogs()">
                                <i class="bi bi-arrow-repeat"></i> Refresh
                            </button>
                            <button class="btn btn-outline-danger btn-sm" onclick="clearServerLogs()">
                                <i class="bi bi-trash"></i> Clear
                            </button>
                        </div>
                    </div>

                    <!-- Active Filters Breadcrumbs -->
                    <div id="serverLogsFilters" class="mb-2 d-none">
                        <span class="text-muted small me-2"><i class="bi bi-funnel"></i> Filters:</span>
                        <span id="serverLogsFilterBadges"></span>
                        <button class="btn btn-link btn-sm text-muted p-0 ms-2" onclick="clearAllLogFilters()" title="Clear all filters">
                            <i class="bi bi-x-lg"></i> Clear all
                        </button>
                    </div>

                    <!-- Log Stats Bar -->
                    <div class="d-flex gap-3 mb-3 small" id="serverLogsStats">
                        <span class="text-muted">Total: <strong id="logStatTotal">0</strong></span>
                        <span class="text-info"><i class="bi bi-info-circle"></i> <span id="logStatInfo">0</span></span>
                        <span class="text-warning"><i class="bi bi-exclamation-triangle"></i> <span id="logStatWarning">0</span></span>
                        <span class="text-danger"><i class="bi bi-x-circle"></i> <span id="logStatError">0</span></span>
                    </div>

                    <!-- Logs Container -->
                    <div id="serverLogsContainer" class="server-logs-container" style="height: calc(100vh - 400px); min-height: 300px; overflow-y: auto; font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace; font-size: 0.8rem; background: var(--bs-tertiary-bg); border-radius: 0.375rem; padding: 0.5rem;">
                        <div class="text-center py-4 text-muted">
                            <i class="bi bi-hourglass-split"></i> Loading logs...
                        </div>
                    </div>
                </div>

                <!-- Mesh Bot Tab -->
                <div class="tab-pane fade" id="bot-pane" role="tabpanel">
                    <div class="row">
                        <!-- Bot Status Card -->
                        <div class="col-lg-4 mb-4">
                            <div class="card">
                                <div class="card-header">
                                    <i class="bi bi-activity"></i> Bot Status
                                </div>
                                <div class="card-body">
                                    <div class="d-flex align-items-center justify-content-between mb-3">
                                        <div>
                                            <span id="botStatusIndicator" class="status-indicator status-disconnected"></span>
                                            <strong id="botStatusText">Loading...</strong>
                                        </div>
                                        <div class="btn-group">
                                            <button class="btn btn-success btn-sm" id="startBotBtn" onclick="startBot()" disabled>
                                                <i class="bi bi-play-fill"></i> Start
                                            </button>
                                            <button class="btn btn-danger btn-sm" id="stopBotBtn" onclick="stopBot()" disabled>
                                                <i class="bi bi-stop-fill"></i> Stop
                                            </button>
                                        </div>
                                    </div>
                                    <hr>
                                    <div class="row text-center mb-3">
                                        <div class="col-4">
                                            <div class="fs-5 fw-bold text-primary" id="botQueueSize">0</div>
                                            <small class="text-muted">Queue</small>
                                        </div>
                                        <div class="col-4">
                                            <div class="fs-5 fw-bold text-success" id="botStatsSent">0</div>
                                            <small class="text-muted">Sent</small>
                                        </div>
                                        <div class="col-4">
                                            <div class="fs-5 fw-bold text-info" id="botStatsReceived">0</div>
                                            <small class="text-muted">Cmds</small>
                                        </div>
                                    </div>
                                    <div class="small text-muted">
                                        <div class="d-flex justify-content-between">
                                            <span>Uptime:</span>
                                            <span id="botUptime">--</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>Errors:</span>
                                            <span id="botStatsErrors" class="text-danger">0</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Bot Configuration Card -->
                        <div class="col-lg-4 mb-4">
                            <div class="card">
                                <div class="card-header">
                                    <i class="bi bi-gear"></i> Configuration
                                </div>
                                <div class="card-body">
                                    <div class="mb-2">
                                        <label class="form-label small mb-1"><strong>Listen Channels</strong></label>
                                        <input type="text" class="form-control form-control-sm" id="botListenChannels"
                                               placeholder="e.g., LongFast">
                                    </div>
                                    <div class="mb-2">
                                        <label class="form-label small mb-1"><strong>Response Channel</strong></label>
                                        <input type="number" class="form-control form-control-sm" id="botRespondChannelIndex"
                                               min="0" max="7" value="1">
                                    </div>
                                    <div class="mb-2">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="botWaitForJobs" checked>
                                            <label class="form-check-label small" for="botWaitForJobs">
                                                Wait for admin jobs
                                            </label>
                                        </div>
                                    </div>
                                    <button class="btn btn-primary btn-sm w-100" onclick="saveBotConfig()">
                                        <i class="bi bi-save"></i> Save Config
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Quick Actions Card -->
                        <div class="col-lg-4 mb-4">
                            <div class="card">
                                <div class="card-header">
                                    <i class="bi bi-lightning"></i> Quick Actions
                                </div>
                                <div class="card-body">
                                    <div class="d-grid gap-2 mb-3">
                                        <button class="btn btn-outline-success btn-sm" onclick="sendQuickMessage('🏓 Pong!')">
                                            <i class="bi bi-broadcast"></i> Send Pong
                                        </button>
                                        <button class="btn btn-outline-info btn-sm" onclick="broadcastStatus()">
                                            <i class="bi bi-bar-chart"></i> Broadcast Status
                                        </button>
                                    </div>
                                    <div class="mb-2">
                                        <div class="input-group input-group-sm">
                                            <input type="text" class="form-control" id="botQuickMessageText" placeholder="Custom message...">
                                            <button class="btn btn-primary" onclick="sendCustomQuickMessage()">
                                                <i class="bi bi-send"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <button class="btn btn-outline-danger btn-sm w-100" onclick="clearBotQueue()">
                                        <i class="bi bi-trash"></i> Clear Queue
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Commands with Toggle -->
                    <div class="row">
                        <div class="col-lg-6 mb-4">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <span><i class="bi bi-terminal"></i> Commands</span>
                                    <span class="badge bg-secondary" id="botCommandCount">0</span>
                                </div>
                                <div class="card-body p-0">
                                    <div class="table-responsive" style="max-height: 300px; overflow-y: auto;">
                                        <table class="table table-hover table-sm mb-0">
                                            <thead class="sticky-top bg-body">
                                                <tr>
                                                    <th style="width: 50px;">Status</th>
                                                    <th>Command</th>
                                                    <th>Description</th>
                                                </tr>
                                            </thead>
                                            <tbody id="botCommandsTable">
                                                <tr>
                                                    <td colspan="3" class="text-center text-muted py-3">
                                                        <div class="spinner-border spinner-border-sm" role="status"></div>
                                                        Loading...
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Activity Log -->
                        <div class="col-lg-6 mb-4">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <span><i class="bi bi-journal-text"></i> Activity Log</span>
                                    <div>
                                        <button class="btn btn-outline-secondary btn-sm" onclick="clearActivityLog()" title="Clear log">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                        <button class="btn btn-outline-primary btn-sm" onclick="refreshBotActivity()" title="Refresh">
                                            <i class="bi bi-arrow-clockwise"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="card-body p-0">
                                    <div id="botActivityLog" class="bot-activity-log" style="max-height: 300px; overflow-y: auto;">
                                        <div class="text-center text-muted py-4">
                                            <i class="bi bi-clock-history fs-2"></i>
                                            <p class="mb-0 small">No activity yet</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Manual Message Sending (collapsed by default) -->
                    <div class="row">
                        <div class="col-12 mb-4">
                            <div class="card">
                                <div class="card-header" data-bs-toggle="collapse" data-bs-target="#manualMessagePanel"
                                     style="cursor: pointer;" aria-expanded="false">
                                    <i class="bi bi-send"></i> Manual Message
                                    <i class="bi bi-chevron-down float-end"></i>
                                </div>
                                <div class="collapse" id="manualMessagePanel">
                                    <div class="card-body">
                                        <div class="row">
                                            <div class="col-md-6 mb-3">
                                                <label class="form-label">Message Text</label>
                                                <textarea class="form-control" id="botMessageText" rows="2"
                                                          placeholder="Enter message to send..."></textarea>
                                            </div>
                                            <div class="col-md-3 mb-3">
                                                <label class="form-label">Destination</label>
                                                <select class="form-select" id="botMessageDestination">
                                                    <option value="broadcast">Broadcast</option>
                                                </select>
                                            </div>
                                            <div class="col-md-3 mb-3">
                                                <label class="form-label">Priority</label>
                                                <select class="form-select" id="botMessagePriority">
                                                    <option value="normal">Normal</option>
                                                    <option value="high">High</option>
                                                    <option value="low">Low</option>
                                                </select>
                                            </div>
                                        </div>
                                        <button class="btn btn-primary" onclick="sendBotMessage()">
                                            <i class="bi bi-send"></i> Queue Message
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Job Details Modal -->
<div class="modal fade" id="jobDetailsModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-list-task me-2"></i>
                    <span id="jobDetailsTitle">Job Details</span>
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="jobDetailsBody">
                <div class="text-center py-4">
                    <div class="spinner-border text-primary" role="status"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-outline-success d-none" id="jobDetailsResumeBtn" onclick="resumeJobFromModal()">
                    <i class="bi bi-play-fill me-1"></i> Resume
                </button>
                <button type="button" class="btn btn-outline-warning d-none" id="jobDetailsPauseBtn" onclick="pauseJobFromModal()">
                    <i class="bi bi-pause-fill me-1"></i> Pause
                </button>
                <button type="button" class="btn btn-outline-danger d-none" id="jobDetailsCancelBtn" onclick="cancelJobFromModal()">
                    <i class="bi bi-x-circle me-1"></i> Cancel
                </button>
                <button type="button" class="btn btn-danger d-none" id="jobDetailsForceCancelBtn" onclick="forceCancelJobFromModal()" title="Force cancel this job (use if job is stuck)">
                    <i class="bi bi-exclamation-triangle me-1"></i> Force Cancel
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Confirmation Modal -->
<div class="modal fade" id="confirmModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="confirmModalTitle">Confirm Action</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="confirmModalBody">
                Are you sure?
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmModalBtn">Confirm</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Template from Node Modal -->
<div class="modal fade" id="createFromNodeModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-download"></i> Create Template from Node
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-3">
                    Extract the current configuration from an existing node to use as a template.
                    Node-specific settings (like location, credentials, etc.) will be automatically removed.
                </p>

                <!-- Step 1: Select Node and Config Type -->
                <div id="extractStep1">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Source Node</label>
                            <select class="form-select" id="extractSourceNode">
                                <option value="">Select an administrable node...</option>
                            </select>
                            <div class="form-text">Select a node to extract config from</div>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Config Type</label>
                            <select class="form-select" id="extractConfigType">
                                <option value="device">Device</option>
                                <option value="lora" selected>LoRa</option>
                                <option value="position">Position</option>
                                <option value="power">Power</option>
                                <option value="network">Network</option>
                                <option value="display">Display</option>
                                <option value="bluetooth">Bluetooth</option>
                                <option value="security">Security</option>
                                <option value="channel">Channel (Single)</option>
                                <option value="channels">Channels (Full Set)</option>
                            </select>
                        </div>
                    </div>
                    <div class="mb-3" id="channelIndexRow" style="display: none;">
                        <label class="form-label">Channel Index</label>
                        <select class="form-select" id="extractChannelIndex">
                            <option value="0">Primary (0)</option>
                            <option value="1">Secondary (1)</option>
                            <option value="2">Channel 2</option>
                            <option value="3">Channel 3</option>
                            <option value="4">Channel 4</option>
                            <option value="5">Channel 5</option>
                            <option value="6">Channel 6</option>
                            <option value="7">Channel 7</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="extractConfigFromNode()" id="extractConfigBtn">
                        <i class="bi bi-cloud-download"></i> Extract Configuration
                    </button>

                    <!-- Real-time extraction progress -->
                    <div id="extractionProgress" class="mt-3" style="display: none;">
                        <div class="card bg-light">
                            <div class="card-body py-2">
                                <div class="d-flex align-items-center mb-2">
                                    <span class="spinner-border spinner-border-sm text-primary me-2"></span>
                                    <strong id="extractionStatus">Connecting to node...</strong>
                                </div>
                                <div class="progress" style="height: 8px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated"
                                         role="progressbar"
                                         id="extractionProgressBar"
                                         style="width: 0%"></div>
                                </div>
                                <small class="text-muted mt-1 d-block" id="extractionDetails"></small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Review and Name -->
                <div id="extractStep2" style="display: none;">
                    <div class="alert alert-success mb-3">
                        <i class="bi bi-check-circle"></i>
                        Configuration extracted successfully from node <strong id="extractedFromNode"></strong>
                    </div>

                    <div id="excludedFieldsWarning" class="alert alert-info mb-3" style="display: none;">
                        <i class="bi bi-info-circle"></i>
                        <strong>Note:</strong> The following node-specific fields were removed:
                        <code id="excludedFieldsList"></code>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Template Name</label>
                        <input type="text" class="form-control" id="extractTemplateName"
                               placeholder="e.g., Standard LoRa Settings">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Description (optional)</label>
                        <input type="text" class="form-control" id="extractTemplateDescription"
                               placeholder="Describe what this template is for">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Extracted Configuration</label>
                        <textarea class="form-control font-monospace" id="extractedConfigData" rows="10" readonly></textarea>
                        <div class="form-text">
                            You can edit this configuration after creating the template.
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-outline-secondary" id="extractBackBtn" style="display: none;"
                        onclick="resetExtractModal()">
                    <i class="bi bi-arrow-left"></i> Back
                </button>
                <button type="button" class="btn btn-success" id="saveExtractedTemplateBtn" style="display: none;"
                        onclick="saveExtractedTemplate()">
                    <i class="bi bi-save"></i> Create Template
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Create Backup Modal -->
<div class="modal fade" id="createBackupModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-cloud-download"></i> Create Node Backup
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-3">
                    Create a full backup of a node's configuration including all core configs,
                    module configs, and channels. This can be used to restore the node later.
                </p>

                <div class="mb-3">
                    <label class="form-label">Source Node</label>
                    <select class="form-select" id="backupSourceNode">
                        <option value="">Select an administrable node...</option>
                        {% for node in administrable_nodes %}
                        <option value="{{ node.node_id }}" data-hex="{{ node.hex_id }}"
                                data-name="{{ node.long_name or node.short_name or 'Unknown' }}">
                            {{ node.long_name or node.short_name or node.hex_id }}
                            ({{ node.hex_id or ('!' + '%08x'|format(node.node_id)) }})
                        </option>
                        {% endfor %}
                    </select>
                </div>

                <div class="mb-3">
                    <label class="form-label">Backup Name</label>
                    <input type="text" class="form-control" id="backupNameInput"
                           placeholder="e.g., My Node - Pre-Update Backup">
                    <div class="form-text">A descriptive name for this backup</div>
                </div>

                <div class="mb-3">
                    <label class="form-label">Description (optional)</label>
                    <textarea class="form-control" id="backupDescriptionInput" rows="2"
                              placeholder="e.g., Backup before firmware update to 2.5.0"></textarea>
                </div>

                <!-- Timing Settings -->
                <div class="mb-3">
                    <a class="text-decoration-none small" data-bs-toggle="collapse" href="#backupTimingSettings" role="button">
                        <i class="bi bi-gear"></i> Advanced Timing Settings
                    </a>
                    <div class="collapse mt-2" id="backupTimingSettings">
                        <div class="card card-body bg-light py-2">
                            <label class="form-label small">Request Delay Mode</label>
                            <select class="form-select form-select-sm" id="backupDelayMode" onchange="updateBackupDelayUI()">
                                <option value="auto" selected>Auto (based on hop count)</option>
                                <option value="fast">Fast (0s - for direct connections)</option>
                                <option value="normal">Normal (1.5s - for most mesh nodes)</option>
                                <option value="slow">Slow (3s - for distant nodes)</option>
                                <option value="custom">Custom...</option>
                            </select>
                            <div class="form-text small">Delay between config requests to prevent mesh congestion.</div>
                            <div class="mt-2 d-none" id="backupCustomDelayGroup">
                                <label class="form-label small">Custom Delay (seconds)</label>
                                <input type="number" class="form-control form-control-sm" id="backupCustomDelay"
                                       min="0" max="10" step="0.5" value="1.5" style="width: 100px;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Progress Section -->
                <div id="backupProgressSection" style="display: none;">
                    <div class="card bg-light">
                        <div class="card-body py-2">
                            <div class="d-flex align-items-center mb-2">
                                <span class="spinner-border spinner-border-sm text-primary me-2" id="backupSpinner"></span>
                                <strong id="backupProgressStatus">Starting backup...</strong>
                            </div>
                            <div class="progress" style="height: 8px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated"
                                     role="progressbar"
                                     id="backupProgressBar"
                                     style="width: 0%"></div>
                            </div>
                            <small class="text-muted mt-1 d-block" id="backupProgressDetails"></small>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="startBackupJobBtn" onclick="startBackupJob()"
                        title="Create backup as a background job">
                    <i class="bi bi-cloud-download"></i> Create Backup
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Restore Backup Modal -->
<div class="modal fade" id="restoreBackupModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-warning-subtle">
                <h5 class="modal-title">
                    <i class="bi bi-arrow-counterclockwise"></i> Restore Backup to Node
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" id="restoreModalClose"></button>
            </div>
            <div class="modal-body">
                <!-- Pre-Restore Configuration (shown before restore starts) -->
                <div id="restoreConfigSection">
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i>
                        <strong>Warning:</strong> This will overwrite the target node's configuration with the backup data.
                        Make sure you understand the implications before proceeding.
                    </div>

                    <div class="card mb-3">
                        <div class="card-body">
                            <h6><i class="bi bi-info-circle"></i> Backup Details</h6>
                            <table class="table table-sm mb-0">
                                <tr><td><strong>Name:</strong></td><td id="restoreBackupName">-</td></tr>
                                <tr><td><strong>Original Node:</strong></td><td id="restoreOriginalNode">-</td></tr>
                                <tr><td><strong>Created:</strong></td><td id="restoreBackupCreated">-</td></tr>
                            </table>
                        </div>
                    </div>

                    <div class="card mb-3">
                        <div class="card-body">
                            <h6><i class="bi bi-sliders"></i> Restore Options</h6>

                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="restoreSkipLora">
                                <label class="form-check-label" for="restoreSkipLora">
                                    <strong>Skip LoRa Configuration</strong>
                                    <small class="text-muted d-block">Keep current radio settings (frequency, bandwidth, etc.) even if selected below</small>
                                </label>
                            </div>

                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="restoreSkipSecurity" checked>
                                <label class="form-check-label" for="restoreSkipSecurity">
                                    <strong>Skip Security Configuration</strong>
                                    <small class="text-muted d-block">Recommended: Keep current admin keys to maintain access</small>
                                </label>
                            </div>

                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="restoreRebootAfter">
                                <label class="form-check-label" for="restoreRebootAfter">
                                    <strong>Reboot Node After Restore</strong>
                                    <small class="text-muted d-block">Required for some settings to take effect</small>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Selective Restore Configuration -->
                    <div class="card mb-3">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h6 class="mb-0"><i class="bi bi-list-check"></i> Select What to Restore</h6>
                            <div>
                                <button type="button" class="btn btn-sm btn-outline-secondary me-1" onclick="selectAllRestoreItems(true)">
                                    <i class="bi bi-check-all"></i> Select All
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-secondary" onclick="selectAllRestoreItems(false)">
                                    <i class="bi bi-x"></i> Deselect All
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <!-- Core Configs Section -->
                            <div class="mb-3">
                                <div class="d-flex align-items-center mb-2">
                                    <input class="form-check-input me-2" type="checkbox" id="restoreSelectAllCore" onchange="toggleRestoreCategory('core', this.checked)">
                                    <strong class="text-primary">
                                        <i class="bi bi-gear"></i> Core Configs
                                        <span id="restoreCoreCount" class="badge bg-primary ms-1">0</span>
                                    </strong>
                                    <button type="button" class="btn btn-link btn-sm ms-auto p-0" data-bs-toggle="collapse" data-bs-target="#restoreCoreConfigsList">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <div class="collapse" id="restoreCoreConfigsList">
                                    <div class="ms-4 ps-1 border-start" id="restoreCoreConfigsContainer">
                                        <!-- Dynamically populated -->
                                    </div>
                                </div>
                            </div>

                            <!-- Module Configs Section -->
                            <div class="mb-3">
                                <div class="d-flex align-items-center mb-2">
                                    <input class="form-check-input me-2" type="checkbox" id="restoreSelectAllModules" onchange="toggleRestoreCategory('module', this.checked)">
                                    <strong class="text-info">
                                        <i class="bi bi-puzzle"></i> Module Configs
                                        <span id="restoreModuleCount" class="badge bg-info ms-1">0</span>
                                    </strong>
                                    <button type="button" class="btn btn-link btn-sm ms-auto p-0" data-bs-toggle="collapse" data-bs-target="#restoreModuleConfigsList">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <div class="collapse" id="restoreModuleConfigsList">
                                    <div class="ms-4 ps-1 border-start" id="restoreModuleConfigsContainer">
                                        <!-- Dynamically populated -->
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Section -->
                            <div>
                                <div class="d-flex align-items-center mb-2">
                                    <input class="form-check-input me-2" type="checkbox" id="restoreSelectAllChannels" onchange="toggleRestoreCategory('channel', this.checked)">
                                    <strong class="text-success">
                                        <i class="bi bi-broadcast"></i> Channels
                                        <span id="restoreChannelCount" class="badge bg-success ms-1">0</span>
                                    </strong>
                                    <button type="button" class="btn btn-link btn-sm ms-auto p-0" data-bs-toggle="collapse" data-bs-target="#restoreChannelsList">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <div class="collapse" id="restoreChannelsList">
                                    <div class="ms-4 ps-1 border-start" id="restoreChannelsContainer">
                                        <!-- Dynamically populated -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-footer bg-light">
                            <small class="text-muted">
                                <i class="bi bi-info-circle"></i>
                                Selected: <span id="restoreSelectedCount" class="fw-bold">0</span> items
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Restore Progress Section (shown during restore) -->
                <div id="restoreProgressSection" style="display: none;">
                    <div class="card">
                        <div class="card-body">
                            <div class="d-flex align-items-center mb-3">
                                <span class="spinner-border spinner-border-sm text-warning me-2" id="restoreSpinner"></span>
                                <strong id="restoreProgressStatus">Starting restore...</strong>
                            </div>

                            <div class="progress mb-2" style="height: 20px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated bg-warning"
                                     role="progressbar"
                                     id="restoreProgressBar"
                                     style="width: 0%">0%</div>
                            </div>

                            <div class="mb-3">
                                <small class="text-muted" id="restoreProgressDetails">Initializing...</small>
                            </div>

                            <!-- Restore Log -->
                            <div class="bg-dark text-light rounded p-2" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.8rem;" id="restoreLogContainer">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Restore Complete Section (shown after restore) -->
                <div id="restoreCompleteSection" style="display: none;">
                    <div class="text-center py-4">
                        <i class="bi bi-check-circle-fill text-success" style="font-size: 4rem;" id="restoreSuccessIcon"></i>
                        <i class="bi bi-x-circle-fill text-danger" style="font-size: 4rem; display: none;" id="restoreFailIcon"></i>
                        <h4 class="mt-3" id="restoreCompleteTitle">Restore Complete</h4>
                        <p class="text-muted" id="restoreCompleteMessage">Configuration has been restored successfully.</p>
                    </div>

                    <div class="row" id="restoreResultsSummary">
                        <div class="col-md-6">
                            <div class="card border-success mb-2">
                                <div class="card-body py-2">
                                    <strong class="text-success">Successful:</strong>
                                    <span id="restoreSuccessCount" class="badge bg-success">0</span>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card border-danger mb-2">
                                <div class="card-body py-2">
                                    <strong class="text-danger">Failed:</strong>
                                    <span id="restoreFailCount" class="badge bg-danger">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="restoreErrorDetails" style="display: none;" class="mt-3">
                        <h6 class="text-danger">Failed Items:</h6>
                        <ul class="list-group list-group-flush small" id="restoreErrorList"></ul>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="restoreCancelBtn">Cancel</button>
                <button type="button" class="btn btn-warning" id="startRestoreJobBtn" onclick="startRestoreJob()"
                        title="Restore backup as a background job">
                    <i class="bi bi-arrow-counterclockwise"></i> Start Restore
                </button>
                <button type="button" class="btn btn-primary" id="restoreDoneBtn" style="display: none;" data-bs-dismiss="modal">
                    <i class="bi bi-check"></i> Done
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/job-manager.js') }}"></script>
<script>
    let selectedNodeId = null;
    let currentConfigType = null;
    let currentConfigData = null;
    let currentConfigSchema = null;
    let isModuleConfig = false;  // Track if current config is module config
    let searchTimeout = null;
    let cachedNodes = null;
    let adminStatusTimeout = null;
    let lastCheckedNodeId = null;

    // Global job manager instance
    let jobManager = null;
    let jobsPollingInterval = null;

    // ============================================================================
    // Admin Status Checking
    // ============================================================================

    // Debounced function to check admin status when typing
    function checkAdminStatusDebounced() {
        if (adminStatusTimeout) {
            clearTimeout(adminStatusTimeout);
        }
        adminStatusTimeout = setTimeout(() => {
            const nodeId = getNodeIdFromInput('targetNodeInput');
            if (nodeId && nodeId.length >= 3) {
                checkAdminStatus(nodeId);
            } else {
                hideAdminStatusBanner();
            }
        }, 500);
    }

    // Check admin status for a node
    async function checkAdminStatus(nodeId) {
        // Don't re-check the same node
        if (nodeId === lastCheckedNodeId) {
            return;
        }
        lastCheckedNodeId = nodeId;

        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Show loading state
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');
        banner.classList.add('status-warning');
        iconEl.className = 'status-icon bi bi-hourglass-split text-warning';
        messageEl.textContent = 'Checking admin channel status...';
        detailsEl.innerHTML = '';
        suggestionsEl.innerHTML = '';

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/status`);
            const data = await response.json();

            if (data.error) {
                showAdminStatusError(data.error);
                return;
            }

            displayAdminStatus(data);
        } catch (error) {
            showAdminStatusError(error.message);
        }
    }

    // Refresh admin status for current node
    function refreshAdminStatus() {
        lastCheckedNodeId = null; // Force refresh
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (nodeId) {
            checkAdminStatus(nodeId);
        }
    }

    // Session passkey management
    async function refreshSessionPasskeys() {
        try {
            const response = await fetch('/api/admin/session-passkeys');
            const data = await response.json();

            const statusDiv = document.getElementById('sessionPasskeyStatus');
            const countSpan = document.getElementById('sessionPasskeyCount');
            const nodesSpan = document.getElementById('sessionPasskeyNodes');

            if (data.count > 0) {
                statusDiv.classList.remove('d-none', 'alert-warning');
                statusDiv.classList.add('alert-info');
                countSpan.textContent = data.count;
                nodesSpan.textContent = `(${data.nodes.join(', ')})`;
            } else {
                statusDiv.classList.remove('d-none', 'alert-info');
                statusDiv.classList.add('alert-warning');
                countSpan.textContent = '0';
                nodesSpan.textContent = '- fetch config from a node to get session passkey';
            }
        } catch (error) {
            console.error('Error fetching session passkeys:', error);
        }
    }

    async function clearSessionPasskeys(nodeId = null) {
        const msg = nodeId
            ? `Clear session passkey for ${nodeId}? You'll need to fetch config again before making changes.`
            : 'Clear ALL session passkeys? You\'ll need to fetch config from each node again before making changes.';

        if (!confirm(msg)) return;

        try {
            const response = await fetch('/api/admin/session-passkeys/clear', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(nodeId ? {node_id: nodeId} : {})
            });
            const data = await response.json();

            if (data.success) {
                showToast(data.message, 'success');
                refreshSessionPasskeys();
            } else {
                showToast(data.error || 'Failed to clear session passkeys', 'danger');
            }
        } catch (error) {
            showToast('Error clearing session passkeys: ' + error.message, 'danger');
        }
    }

    // Display admin status in the banner
    function displayAdminStatus(status) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Reset classes
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');

        // Set status level styling
        const level = status.status_level || 'warning';
        banner.classList.add(`status-${level}`);

        // Set icon
        if (level === 'success') {
            iconEl.className = 'status-icon bi bi-check-circle-fill text-success';
        } else if (level === 'warning') {
            iconEl.className = 'status-icon bi bi-exclamation-triangle-fill text-warning';
        } else {
            iconEl.className = 'status-icon bi bi-x-circle-fill text-danger';
        }

        // Set message
        messageEl.textContent = status.status_message || 'Unknown status';

        // Build checks display
        let checksHtml = '';
        if (status.checks && status.checks.length > 0) {
            for (const check of status.checks) {
                const checkClass = check.passed ? 'check-passed' : 'check-failed';
                const checkIcon = check.passed ? 'bi-check-circle-fill' : 'bi-x-circle-fill';
                checksHtml += `
                    <div class="check-item ${checkClass}">
                        <i class="bi ${checkIcon}"></i>
                        <span>${escapeHtml(check.message)}</span>
                    </div>
                `;
            }
        }
        detailsEl.innerHTML = checksHtml;

        // Build suggestions display
        let suggestionsHtml = '';
        if (status.suggestions && status.suggestions.length > 0) {
            for (const suggestion of status.suggestions) {
                suggestionsHtml += `
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        ${escapeHtml(suggestion)}
                    </div>
                `;
            }
        }

        // Add test button if node is not administrable
        const nodeAdminCheck = status.checks?.find(c => c.name === 'node_administrable');
        if (nodeAdminCheck && !nodeAdminCheck.passed) {
            suggestionsHtml += `
                <div class="mt-2">
                    <button class="btn btn-sm btn-outline-primary" onclick="testCurrentNode()">
                        <i class="bi bi-lightning"></i> Test Admin Access Now
                    </button>
                </div>
            `;
        }

        suggestionsEl.innerHTML = suggestionsHtml;
        if (!suggestionsHtml) {
            suggestionsEl.classList.add('d-none');
        } else {
            suggestionsEl.classList.remove('d-none');
        }
    }

    // Show error in admin status banner
    function showAdminStatusError(errorMessage) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        banner.classList.remove('d-none', 'status-success', 'status-warning');
        banner.classList.add('status-danger');
        iconEl.className = 'status-icon bi bi-exclamation-octagon-fill text-danger';
        messageEl.textContent = 'Error checking admin status';
        detailsEl.innerHTML = `<span class="text-danger">${escapeHtml(errorMessage)}</span>`;
        suggestionsEl.innerHTML = '';
    }

    // Update admin status banner with a simple message (for reboot/shutdown status)
    function updateAdminStatusBanner(level, message, details) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        if (!banner) return;

        // Reset classes
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');
        banner.classList.add(`status-${level}`);

        // Set icon based on level
        if (level === 'success') {
            iconEl.className = 'status-icon bi bi-check-circle-fill text-success';
        } else if (level === 'warning') {
            iconEl.className = 'status-icon bi bi-hourglass-split text-warning';
        } else {
            iconEl.className = 'status-icon bi bi-x-circle-fill text-danger';
        }

        messageEl.textContent = message || '';
        detailsEl.innerHTML = details ? `<span class="text-muted">${escapeHtml(details)}</span>` : '';
        suggestionsEl.innerHTML = '';
        suggestionsEl.classList.add('d-none');
    }

    // Hide admin status banner
    function hideAdminStatusBanner() {
        const banner = document.getElementById('adminStatusBanner');
        banner.classList.add('d-none');
        lastCheckedNodeId = null;
    }

    // Test admin access for the current target node
    async function testCurrentNode() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const banner = document.getElementById('adminStatusBanner');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Show testing state
        banner.classList.remove('status-success', 'status-danger');
        banner.classList.add('status-warning');
        document.getElementById('adminStatusIcon').className = 'status-icon bi bi-hourglass-split text-warning';
        messageEl.textContent = 'Testing admin access...';
        detailsEl.innerHTML = '<div class="spinner-border spinner-border-sm text-primary" role="status"></div> Sending device metadata request...';
        suggestionsEl.innerHTML = '';

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const data = await response.json();

            if (data.success && data.administrable) {
                // Refresh status to show updated state
                lastCheckedNodeId = null;
                await checkAdminStatus(nodeId);
                showAlert('success', `Node ${data.hex_id} is administrable!`);
            } else {
                // Show failure in banner
                banner.classList.remove('status-warning');
                banner.classList.add('status-danger');
                document.getElementById('adminStatusIcon').className = 'status-icon bi bi-x-circle-fill text-danger';
                messageEl.textContent = 'Admin test failed';
                detailsEl.innerHTML = `<span class="text-danger">${escapeHtml(data.error || 'No response from node')}</span>`;
                suggestionsEl.innerHTML = `
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        Ensure the node has this server's public key configured
                    </div>
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        Check that the node is within radio range of the gateway
                    </div>
                `;
            }
        } catch (error) {
            showAdminStatusError(error.message);
        }
    }

    // ============================================================================
    // Node Autocomplete
    // ============================================================================

    // Cache of administrable nodes (populated from page data)
    const administrableNodesCache = [
        {% for node in administrable_nodes %}
        {
            node_id: {{ node.node_id }},
            hex_id: "{{ node.hex_id or ('!' + '%08x'|format(node.node_id)) }}",
            long_name: {{ node.long_name|tojson if node.long_name else 'null' }},
            short_name: {{ node.short_name|tojson if node.short_name else 'null' }},
            hw_model: {{ node.hw_model|tojson if node.hw_model else 'null' }},
            is_administrable: true
        },
        {% endfor %}
    ];

    // Handle target node input changes
    function onTargetNodeInput(value) {
        if (!value || value.length < 1) {
            // Show administrable nodes when input is empty
            showAdministrableNodes();
        } else {
            // Search all nodes when user types
            searchNodes(value, 'targetNodeResults');
        }
        checkAdminStatusDebounced();
    }

    // Show node selector dropdown - defaults to administrable nodes
    function showNodeSelector() {
        const input = document.getElementById('targetNodeInput');
        const value = input ? input.value.trim() : '';

        if (!value || value.length < 1) {
            // Show administrable nodes by default
            showAdministrableNodes();
        } else {
            // If there's already text, search all nodes
            searchNodes(value, 'targetNodeResults');
        }
    }

    // Show administrable nodes in the dropdown
    function showAdministrableNodes() {
        const resultsDiv = document.getElementById('targetNodeResults');
        if (!resultsDiv) return;

        if (administrableNodesCache.length === 0) {
            // No administrable nodes - show a message
            resultsDiv.innerHTML = `
                <div class="node-autocomplete-item text-muted" style="cursor: default;">
                    <div class="small">No administrable nodes found</div>
                    <div class="small text-muted">Type to search all known nodes</div>
                </div>
            `;
            resultsDiv.style.display = 'block';
            return;
        }

        // Build results HTML with administrable nodes
        let html = `
            <div class="autocomplete-section-header">
                <i class="bi bi-shield-check text-success me-1"></i>
                <span class="small text-muted">Administrable Nodes</span>
            </div>
        `;

        for (const node of administrableNodesCache) {
            const displayName = node.long_name || node.short_name || 'Unknown';
            const hexId = node.hex_id || `!${(node.node_id >>> 0).toString(16).padStart(8, '0')}`;
            const hwModel = node.hw_model ? `<span class="badge bg-secondary ms-1">${escapeHtml(node.hw_model)}</span>` : '';
            html += `
                <div class="node-autocomplete-item"
                     onclick="selectAutocompleteNode('${hexId}', '${escapeHtml(displayName)}', 'targetNodeResults')">
                    <div class="node-name">
                        ${escapeHtml(displayName)}
                        ${hwModel}
                        <i class="bi bi-shield-check text-success ms-1" title="Administrable"></i>
                    </div>
                    <div class="node-id">${hexId}</div>
                </div>
            `;
        }

        // Add a divider and hint
        html += `
            <div class="autocomplete-section-footer small text-muted border-top pt-2 mt-1 px-2">
                <i class="bi bi-search"></i> Type to search all nodes
            </div>
        `;

        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
    }

    async function searchNodes(query, resultsContainerId) {
        const resultsDiv = document.getElementById(resultsContainerId);

        if (!query || query.length < 1) {
            hideAutocomplete(resultsContainerId);
            return;
        }

        // Use cached nodes if available, otherwise fetch
        if (!cachedNodes) {
            try {
                const response = await fetch('/api/nodes?limit=500');
                const data = await response.json();
                cachedNodes = data.nodes || [];
            } catch (error) {
                console.error('Failed to fetch nodes:', error);
                cachedNodes = [];
            }
        }

        // Filter nodes based on query
        const lowerQuery = query.toLowerCase();
        const matches = cachedNodes.filter(node => {
            const longName = (node.long_name || '').toLowerCase();
            const shortName = (node.short_name || '').toLowerCase();
            const hexId = node.hex_id ? node.hex_id.toLowerCase() : '';
            const nodeId = node.node_id ? node.node_id.toString() : '';

            return longName.includes(lowerQuery) ||
                   shortName.includes(lowerQuery) ||
                   hexId.includes(lowerQuery) ||
                   nodeId.includes(lowerQuery);
        }).slice(0, 10); // Limit to 10 results

        if (matches.length === 0) {
            hideAutocomplete(resultsContainerId);
            return;
        }

        // Build results HTML
        let html = '';

        // Build a set of administrable node IDs for quick lookup
        const administrableNodeIds = new Set(administrableNodesCache.map(n => n.node_id));

        for (const node of matches) {
            const displayName = node.long_name || node.short_name || 'Unknown';
            const hexId = node.hex_id || `!${(node.node_id >>> 0).toString(16).padStart(8, '0')}`;
            const displayText = `${hexId} - ${displayName}`;
            const isAdministrable = administrableNodeIds.has(node.node_id);
            const adminBadge = isAdministrable
                ? '<i class="bi bi-shield-check text-success ms-1" title="Administrable"></i>'
                : '';
            html += `
                <div class="node-autocomplete-item"
                     onclick="selectAutocompleteNode('${hexId}', '${escapeHtml(displayName)}', '${resultsContainerId}')">
                    <div class="node-name">${escapeHtml(displayName)}${adminBadge}</div>
                    <div class="node-id">${hexId}</div>
                </div>
            `;
        }

        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
    }

    function selectAutocompleteNode(nodeId, nodeName, resultsContainerId) {
        // Find the input associated with this results container
        const resultsDiv = document.getElementById(resultsContainerId);
        const inputId = resultsContainerId === 'testNodeResults' ? 'testNodeInput' : 'targetNodeInput';
        const input = document.getElementById(inputId);

        // Display both hex ID and node name for easy identification
        input.value = `${nodeId} - ${nodeName}`;
        // Store the actual node ID in a data attribute for API calls
        input.dataset.nodeId = nodeId;
        hideAutocomplete(resultsContainerId);

        // If it's the target node input, also store the selected node and check admin status
        if (inputId === 'targetNodeInput') {
            selectedNodeId = nodeId;
            checkAdminStatus(nodeId);
        }
    }

    // Extract the actual node ID from the input value
    // The input may contain "!hexid - NodeName" format, we need just the hex ID
    function getNodeIdFromInput(inputId) {
        const input = document.getElementById(inputId);
        if (!input) return null;

        // First check if we have a stored node ID in the data attribute
        if (input.dataset.nodeId) {
            return input.dataset.nodeId;
        }

        // Otherwise, parse the value - it could be:
        // 1. Just a hex ID: "!abcd1234"
        // 2. Hex ID with name: "!abcd1234 - Node Name"
        // 3. Decimal ID: "1234567890"
        const value = input.value.trim();
        if (!value) return null;

        // If it contains " - ", extract the part before it
        if (value.includes(' - ')) {
            return value.split(' - ')[0].trim();
        }

        return value;
    }

    // Set the target node input with both hex ID and node name for easy identification
    function setTargetNode(nodeId, nodeName = null) {
        const input = document.getElementById('targetNodeInput');
        if (!input) return;

        // Store the actual node ID in the data attribute
        input.dataset.nodeId = nodeId;

        // If we have a node name, display both
        if (nodeName) {
            input.value = `${nodeId} - ${nodeName}`;
        } else {
            // Try to look up the node name from cache
            if (cachedNodes && cachedNodes.length > 0) {
                const hexLower = nodeId.toLowerCase();
                const node = cachedNodes.find(n => {
                    const nHex = (n.hex_id || `!${(n.node_id >>> 0).toString(16).padStart(8, '0')}`).toLowerCase();
                    return nHex === hexLower || n.node_id?.toString() === nodeId;
                });
                if (node) {
                    const displayName = node.long_name || node.short_name || 'Unknown';
                    input.value = `${nodeId} - ${displayName}`;
                } else {
                    // No name found, just use the ID
                    input.value = nodeId;
                }
            } else {
                // No cache yet, just use the ID
                input.value = nodeId;
            }
        }
    }

    function hideAutocomplete(resultsContainerId) {
        const resultsDiv = document.getElementById(resultsContainerId);
        if (resultsDiv) {
            resultsDiv.style.display = 'none';
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Refresh cached nodes
    function refreshNodeCache() {
        cachedNodes = null;
    }

    // ============================================================================
    // Connection Management
    // ============================================================================

    // Local storage keys for persisting settings
    const STORAGE_KEYS = {
        connectionType: 'malla_admin_connection_type',
        tcpHost: 'malla_admin_tcp_host',
        tcpPort: 'malla_admin_tcp_port',
        gatewayNode: 'malla_admin_gateway_node'
    };

    // Save setting to localStorage
    function saveSetting(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            console.warn('Failed to save setting to localStorage:', e);
        }
    }

    // Load setting from localStorage
    function loadSetting(key, defaultValue = '') {
        try {
            return localStorage.getItem(key) || defaultValue;
        } catch (e) {
            console.warn('Failed to load setting from localStorage:', e);
            return defaultValue;
        }
    }

    // Change connection type
    async function changeConnectionType() {
        const connType = document.getElementById('connectionTypeSelect').value;

        // Save to localStorage
        saveSetting(STORAGE_KEYS.connectionType, connType);

        // Show/hide appropriate settings
        document.getElementById('mqttSettings').classList.toggle('d-none', connType !== 'mqtt');
        document.getElementById('tcpSettings').classList.toggle('d-none', connType !== 'tcp');
        document.getElementById('serialSettings').classList.toggle('d-none', connType !== 'serial');

        // Auto-discover serial ports when switching to serial
        if (connType === 'serial') {
            discoverSerialPorts();
        }

        try {
            const response = await fetch('/api/admin/connection-type', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ connection_type: connType })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Connection type changed to ${connType.toUpperCase()}`);
                updateConnectionStatus();
            } else {
                showAlert('danger', data.error || 'Failed to change connection type');
            }
        } catch (error) {
            showAlert('danger', 'Error: ' + error.message);
        }
    }

    // TCP Connect
    async function tcpConnect() {
        const host = document.getElementById('tcpHostInput').value.trim();
        const port = parseInt(document.getElementById('tcpPortInput').value) || 4403;

        // Save TCP settings to localStorage (before connect attempt)
        saveSetting(STORAGE_KEYS.tcpHost, host);
        saveSetting(STORAGE_KEYS.tcpPort, port.toString());

        const btn = document.getElementById('tcpConnectBtn');
        const disconnectBtn = document.getElementById('tcpDisconnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');

        btn.disabled = true;
        disconnectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        // Allow auto-reconnect since user is initiating connection
        if (typeof NodeConnectionManager !== 'undefined') {
            NodeConnectionManager.allowAutoReconnect();
        }

        try {
            // Use NodeConnectionManager if available
            let success = false;
            let data = {};

            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.connectTcp(host, port);
                if (success) {
                    const state = NodeConnectionManager.getState();
                    data = {
                        success: true,
                        host: state.tcpHost,
                        port: state.tcpPort,
                        local_node_hex: state.localNodeHex
                    };
                }
            } else {
                // Fallback to direct API call
                const response = await fetch('/api/admin/tcp/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ host: host, port: port })
                });
                data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                let nodeInfo = data.local_node_hex || '';
                if (data.local_node_name) {
                    nodeInfo = `${data.local_node_name} (${data.local_node_hex})`;
                }
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Connected to ${data.host}:${data.port}` +
                    (nodeInfo ? ` - ${nodeInfo}` : '');
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Failed to connect'}`;
                // Re-enable connect button on failure
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            // Re-enable connect button on error
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
        }

        // Restore button text (state will be set by updateConnectionStatus)
        btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
    }

    // TCP Disconnect
    async function tcpDisconnect() {
        const btn = document.getElementById('tcpDisconnectBtn');
        const connectBtn = document.getElementById('tcpConnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');

        btn.disabled = true;
        connectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Disconnecting...';

        try {
            let success = false;

            // Use NodeConnectionManager if available (this marks as user-disconnected)
            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.disconnect();
            } else {
                const response = await fetch('/api/admin/tcp/disconnect', {
                    method: 'POST'
                });
                const data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = '<i class="bi bi-check-circle"></i> Disconnected';
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Failed to disconnect`;
                // Re-enable disconnect button on failure
                btn.disabled = false;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            // Re-enable disconnect button on error
            btn.disabled = false;
        }

        // Restore button text (state will be set by updateConnectionStatus)
        btn.innerHTML = '<i class="bi bi-x-circle"></i> Disconnect';
    }

    // TCP Reconnect - force reconnection for stale connections
    async function tcpReconnect() {
        const reconnectBtn = document.getElementById('tcpReconnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');
        const healthWarning = document.getElementById('tcpHealthWarning');

        if (reconnectBtn) {
            reconnectBtn.disabled = true;
            reconnectBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Reconnecting...';
        }

        try {
            const response = await fetch('/api/admin/tcp/reconnect', {
                method: 'POST'
            });
            const data = await response.json();

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');
            healthWarning.classList.add('d-none');

            if (data.success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Reconnected to ${data.host}:${data.port}`;
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Reconnection failed'}`;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
        } finally {
            if (reconnectBtn) {
                reconnectBtn.disabled = false;
                reconnectBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Reconnect';
            }
        }
    }

    // Check TCP connection health and show warning if stale
    async function checkTcpHealth() {
        try {
            const statusResponse = await fetch('/api/admin/status');
            const status = await statusResponse.json();

            // Only check health if we're using TCP and supposedly connected
            if (status.connection_type !== 'tcp' || !status.connected) {
                return;
            }

            const healthResponse = await fetch('/api/admin/tcp/health');
            const health = await healthResponse.json();

            const healthWarning = document.getElementById('tcpHealthWarning');
            const healthText = document.getElementById('tcpHealthWarningText');

            if (health.healthy === false && health.connected) {
                // Connection is stale
                healthWarning.classList.remove('d-none');
                healthText.textContent = health.reason || 'Connection may be stale.';
            } else {
                healthWarning.classList.add('d-none');
            }
        } catch (error) {
            console.debug('TCP health check failed:', error);
        }
    }

    // Serial Port Discovery
    async function discoverSerialPorts(probe = false) {
        const selectEl = document.getElementById('serialPortSelect');
        const infoDiv = document.getElementById('serialPortInfo');
        const discoverBtn = document.querySelector('#serialSettings button[onclick="discoverSerialPorts()"]');
        const probeBtn = document.getElementById('probeDevicesBtn');

        selectEl.disabled = true;

        // Disable both buttons during operation
        if (discoverBtn) {
            discoverBtn.disabled = true;
        }
        if (probeBtn) {
            probeBtn.disabled = true;
        }

        // Show appropriate loading state
        if (probe) {
            if (probeBtn) {
                probeBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Probing...';
            }
            selectEl.innerHTML = '<option value="">Probing devices (this may take a moment)...</option>';
        } else {
            if (discoverBtn) {
                discoverBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning...';
            }
            selectEl.innerHTML = '<option value="">Scanning ports...</option>';
        }
        infoDiv.classList.add('d-none');

        try {
            const url = probe ? '/api/admin/serial/ports?probe=true' : '/api/admin/serial/ports';
            const response = await fetch(url);
            const data = await response.json();

            // Store ports data for later reference
            window._serialPortsData = data.ports || [];

            selectEl.innerHTML = '';

            if (data.success && data.ports && data.ports.length > 0) {
                // Add placeholder
                const placeholderOpt = document.createElement('option');
                placeholderOpt.value = '';
                placeholderOpt.textContent = '-- Select a port --';
                selectEl.appendChild(placeholderOpt);

                // Add ports - confirmed/likely Meshtastic devices first
                const sortedPorts = [...data.ports].sort((a, b) => {
                    // Confirmed devices first
                    if (a.is_meshtastic_confirmed && !b.is_meshtastic_confirmed) return -1;
                    if (!a.is_meshtastic_confirmed && b.is_meshtastic_confirmed) return 1;
                    // Then likely devices
                    if (a.is_meshtastic_likely && !b.is_meshtastic_likely) return -1;
                    if (!a.is_meshtastic_likely && b.is_meshtastic_likely) return 1;
                    return 0;
                });

                for (const port of sortedPorts) {
                    const opt = document.createElement('option');
                    opt.value = port.device;

                    // Build label
                    let label = port.device;

                    // If we have device info from probing, show hardware model and name
                    if (port.device_info) {
                        const di = port.device_info;
                        if (di.hardware_model_name) {
                            label += ` - ${di.hardware_model_name}`;
                        }
                        if (di.short_name) {
                            label += ` (${di.short_name})`;
                        }
                        label += ' ✓';
                    } else if (port.chip_type) {
                        // Show chip type from VID:PID lookup
                        label += ` - ${port.chip_type}`;
                        if (port.is_meshtastic_likely) {
                            label += ' ⭐';
                        }
                    } else if (port.description && port.description !== 'n/a') {
                        label += ` - ${port.description}`;
                        if (port.is_meshtastic_likely) {
                            label += ' ⭐';
                        }
                    }

                    opt.textContent = label;
                    selectEl.appendChild(opt);
                }

                // Auto-select first confirmed/likely Meshtastic port
                const bestPort = data.ports.find(p => p.is_meshtastic_confirmed) ||
                                 data.ports.find(p => p.is_meshtastic_likely);
                if (bestPort) {
                    selectEl.value = bestPort.device;
                    showSerialPortInfo(bestPort);
                }

                // Add change handler to show port info
                selectEl.onchange = () => {
                    const selectedPort = window._serialPortsData.find(p => p.device === selectEl.value);
                    if (selectedPort) {
                        showSerialPortInfo(selectedPort);
                    } else {
                        infoDiv.classList.add('d-none');
                    }
                };
            } else {
                selectEl.innerHTML = '<option value="">No serial ports found</option>';
            }
        } catch (error) {
            selectEl.innerHTML = '<option value="">Error discovering ports</option>';
            console.error('Serial port discovery error:', error);
        }

        // Re-enable all controls
        selectEl.disabled = false;
        const discoverBtnFinal = document.querySelector('#serialSettings button[onclick="discoverSerialPorts()"]');
        const probeBtnFinal = document.getElementById('probeDevicesBtn');
        if (discoverBtnFinal) {
            discoverBtnFinal.disabled = false;
            discoverBtnFinal.innerHTML = '<i class="bi bi-search"></i> Discover';
        }
        if (probeBtnFinal) {
            probeBtnFinal.disabled = false;
            probeBtnFinal.innerHTML = '<i class="bi bi-cpu"></i> Identify';
        }
    }

    // Probe devices to identify Meshtastic hardware
    async function probeSerialDevices() {
        await discoverSerialPorts(true);
    }

    function showSerialPortInfo(port) {
        const infoDiv = document.getElementById('serialPortInfo');
        let html = `<strong>${port.device}</strong>`;

        // Show confirmed device info if available
        if (port.device_info) {
            const di = port.device_info;
            if (di.hardware_model_name) {
                html += `<br><span class="text-success"><i class="bi bi-check-circle-fill"></i> <strong>${di.hardware_model_name}</strong></span>`;
            }
            if (di.long_name) {
                html += `<br>Name: ${di.long_name}`;
            }
            if (di.short_name) {
                html += ` (${di.short_name})`;
            }
            if (di.node_hex) {
                html += `<br>Node ID: <code>${di.node_hex}</code>`;
            }
            if (di.firmware_version) {
                html += `<br>Firmware: ${di.firmware_version}`;
            }
        } else {
            // Fallback to basic info
            if (port.chip_type) {
                html += `<br>Chip: ${port.chip_type}`;
            } else if (port.description && port.description !== 'n/a') {
                html += `<br>Description: ${port.description}`;
            }
            if (port.manufacturer && port.manufacturer !== 'n/a') {
                html += `<br>Manufacturer: ${port.manufacturer}`;
            }
            if (port.vid && port.pid) {
                html += `<br>VID:PID: ${port.vid.toString(16).toUpperCase().padStart(4, '0')}:${port.pid.toString(16).toUpperCase().padStart(4, '0')}`;
            }
            if (port.is_meshtastic_likely) {
                html += `<br><span class="text-warning"><i class="bi bi-question-circle"></i> Likely Meshtastic - click "Identify Device" to confirm</span>`;
            }
        }

        infoDiv.querySelector('small').innerHTML = html;
        infoDiv.classList.remove('d-none');
    }

    // Serial Connect
    async function serialConnect() {
        const port = document.getElementById('serialPortSelect').value;

        if (!port) {
            showAlert('warning', 'Please select a serial port first');
            return;
        }

        // Save serial port to localStorage
        saveSetting('serialPort', port);

        const btn = document.getElementById('serialConnectBtn');
        const disconnectBtn = document.getElementById('serialDisconnectBtn');
        const resultDiv = document.getElementById('serialConnectResult');

        btn.disabled = true;
        disconnectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        // Allow auto-reconnect since user is initiating connection
        if (typeof NodeConnectionManager !== 'undefined') {
            NodeConnectionManager.allowAutoReconnect();
        }

        try {
            // Use NodeConnectionManager if available
            let success = false;
            let data = {};

            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.connectSerial(port);
                if (success) {
                    const state = NodeConnectionManager.getState();
                    data = {
                        success: true,
                        port: state.serialPort,
                        local_node_hex: state.localNodeHex
                    };
                }
            } else {
                // Fallback to direct API call
                const response = await fetch('/api/admin/serial/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ port: port })
                });
                data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                let nodeInfo = data.local_node_hex || '';
                if (data.local_node_name) {
                    nodeInfo = `${data.local_node_name} (${data.local_node_hex})`;
                }
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Connected to ${data.port}` +
                    (nodeInfo ? ` - ${nodeInfo}` : '');
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Failed to connect'}`;
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
        }

        btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
    }

    // Serial Disconnect
    async function serialDisconnect() {
        const btn = document.getElementById('serialDisconnectBtn');
        const connectBtn = document.getElementById('serialConnectBtn');
        const resultDiv = document.getElementById('serialConnectResult');

        btn.disabled = true;
        connectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Disconnecting...';

        try {
            let success = false;

            // Use NodeConnectionManager if available (this marks as user-disconnected)
            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.disconnect();
            } else {
                const response = await fetch('/api/admin/serial/disconnect', {
                    method: 'POST'
                });
                const data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = '<i class="bi bi-check-circle"></i> Disconnected';
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Failed to disconnect`;
                btn.disabled = false;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            btn.disabled = false;
        }

        btn.innerHTML = '<i class="bi bi-x-circle"></i> Disconnect';
    }

    // Update connection status display
    async function updateConnectionStatus() {
        try {
            const response = await fetch('/api/admin/status');
            const data = await response.json();

            const statusSpan = document.getElementById('connectionStatus');
            const tcpConnectBtn = document.getElementById('tcpConnectBtn');
            const tcpDisconnectBtn = document.getElementById('tcpDisconnectBtn');
            const serialConnectBtn = document.getElementById('serialConnectBtn');
            const serialDisconnectBtn = document.getElementById('serialDisconnectBtn');

            if (data.connected) {
                let statusText = 'Connected';
                if (data.local_node_hex) {
                    if (data.local_node_name) {
                        statusText = `Connected - ${data.local_node_name} (${data.local_node_hex})`;
                    } else {
                        statusText = `Connected (${data.local_node_hex})`;
                    }
                }
                statusSpan.innerHTML = `<span class="status-indicator status-connected"></span>${statusText}`;
                // Disable connect buttons, enable disconnect buttons
                if (tcpConnectBtn) {
                    tcpConnectBtn.disabled = true;
                    tcpConnectBtn.classList.remove('btn-success');
                    tcpConnectBtn.classList.add('btn-outline-secondary');
                }
                if (tcpDisconnectBtn) {
                    tcpDisconnectBtn.disabled = false;
                    tcpDisconnectBtn.classList.remove('btn-outline-secondary');
                    tcpDisconnectBtn.classList.add('btn-outline-danger');
                }
                if (serialConnectBtn) {
                    serialConnectBtn.disabled = true;
                    serialConnectBtn.classList.remove('btn-success');
                    serialConnectBtn.classList.add('btn-outline-secondary');
                }
                if (serialDisconnectBtn) {
                    serialDisconnectBtn.disabled = false;
                    serialDisconnectBtn.classList.remove('btn-outline-secondary');
                    serialDisconnectBtn.classList.add('btn-outline-danger');
                }
            } else {
                statusSpan.innerHTML = '<span class="status-indicator status-disconnected"></span>Disconnected';
                // Enable connect buttons, disable disconnect buttons
                if (tcpConnectBtn) {
                    tcpConnectBtn.disabled = false;
                    tcpConnectBtn.classList.remove('btn-outline-secondary');
                    tcpConnectBtn.classList.add('btn-success');
                }
                if (tcpDisconnectBtn) {
                    tcpDisconnectBtn.disabled = true;
                    tcpDisconnectBtn.classList.remove('btn-outline-danger');
                    tcpDisconnectBtn.classList.add('btn-outline-secondary');
                }
                if (serialConnectBtn) {
                    serialConnectBtn.disabled = false;
                    serialConnectBtn.classList.remove('btn-outline-secondary');
                    serialConnectBtn.classList.add('btn-success');
                }
                if (serialDisconnectBtn) {
                    serialDisconnectBtn.disabled = true;
                    serialDisconnectBtn.classList.remove('btn-outline-danger');
                    serialDisconnectBtn.classList.add('btn-outline-secondary');
                }
            }

            // Update gateway display if available
            if (data.gateway_node_hex) {
                document.getElementById('gatewayNodeDisplay').innerHTML = `<code>${data.gateway_node_hex}</code>`;
            }

            // Update the global header indicator
            if (typeof NodeConnectionManager !== 'undefined') {
                NodeConnectionManager.updateGlobalIndicator();
            }

            return data.connected;
        } catch (error) {
            console.error('Failed to update connection status:', error);
            return false;
        }
    }

    // Periodic connection status check
    let connectionCheckInterval = null;

    function startConnectionCheck() {
        // Clear any existing interval
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
        }

        // Check connection status every 10 seconds
        connectionCheckInterval = setInterval(async () => {
            await updateConnectionStatus();
            // Also check TCP health periodically
            await checkTcpHealth();
        }, 10000);
    }

    function stopConnectionCheck() {
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
            connectionCheckInterval = null;
        }
    }

    // Start connection check on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Initial status update
        updateConnectionStatus();
        // Initial session passkey status
        refreshSessionPasskeys();
        // Start periodic check
        startConnectionCheck();

        // Handle tab navigation via URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const tabParam = urlParams.get('tab');
        if (tabParam) {
            const tabMap = {
                'nodes': 'nodes-tab',
                'commands': 'commands-tab',
                'templates': 'templates-tab',
                'backups': 'backups-tab',
                'jobs': 'jobs-tab',
                'log': 'log-tab'
            };
            const tabId = tabMap[tabParam];
            if (tabId) {
                const tabEl = document.getElementById(tabId);
                if (tabEl) {
                    const tab = new bootstrap.Tab(tabEl);
                    tab.show();
                }
            }
        }
    });

    // Set gateway node
    async function setGatewayNode() {
        const nodeId = document.getElementById('gatewayNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a node ID');
            return;
        }

        try {
            const response = await fetch('/api/admin/gateway', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ node_id: nodeId })
            });
            const data = await response.json();

            if (data.success) {
                // Save gateway node to localStorage
                saveSetting(STORAGE_KEYS.gatewayNode, data.gateway_node_hex || nodeId);

                document.getElementById('gatewayNodeDisplay').innerHTML =
                    `<code>${data.gateway_node_hex}</code>`;
                showAlert('success', 'Gateway node set successfully');
            } else {
                showAlert('danger', data.error || 'Failed to set gateway node');
            }
        } catch (error) {
            showAlert('danger', 'Error: ' + error.message);
        }
    }

    // Test node admin access
    async function testNodeAdmin() {
        const nodeId = getNodeIdFromInput('testNodeInput');
        if (!nodeId) {
            alert('Please enter a node ID');
            return;
        }

        const btn = document.getElementById('testNodeBtn');
        const resultDiv = document.getElementById('testNodeResult');

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Testing...';
        resultDiv.classList.add('d-none');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const data = await response.json();

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-warning', 'alert-danger');

            if (data.success && data.administrable) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> <strong>Success!</strong>
                    Node ${data.hex_id} is administrable and responded to the test request.
                    <button class="btn btn-sm btn-outline-success ms-2" onclick="location.reload()">
                        <i class="bi bi-arrow-clockwise"></i> Refresh Page
                    </button>`;
            } else {
                resultDiv.classList.add('alert-warning');
                const errorMsg = data.error || 'Node did not respond. It may not have this server\'s public key configured.';
                const isTimeout = errorMsg.toLowerCase().includes('timeout');
                const isPkiError = errorMsg.toLowerCase().includes('pki') || errorMsg.toLowerCase().includes('key') || errorMsg.toLowerCase().includes('session');

                let retryButton = '';
                if (isTimeout || isPkiError) {
                    retryButton = `
                        <div class="mt-2">
                            <button class="btn btn-sm btn-outline-warning" onclick="clearPkiCacheAndRetry('${nodeId}')">
                                <i class="bi bi-arrow-repeat"></i> Clear PKI Cache & Retry
                            </button>
                            <small class="text-muted ms-2">Clears cached session keys and retries admin test</small>
                        </div>`;
                }

                resultDiv.innerHTML = `<i class="bi bi-exclamation-triangle"></i> <strong>Not Administrable</strong><br>
                    ${errorMsg}${retryButton}`;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-lightning"></i> Test';
        }
    }

    // Clear PKI cache for a node and retry admin test
    async function clearPkiCacheAndRetry(nodeId) {
        const resultDiv = document.getElementById('testNodeResult');

        resultDiv.classList.remove('alert-success', 'alert-warning', 'alert-danger');
        resultDiv.classList.add('alert-info');
        resultDiv.innerHTML = `<i class="bi bi-hourglass-split"></i> Resetting admin state for node ${nodeId}...`;

        try {
            // Step 1: Reset all admin state (clears PKI cache AND removes DB entry)
            const resetResponse = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/reset`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const resetData = await resetResponse.json();

            if (resetData.error) {
                throw new Error(resetData.error);
            }

            const clearedItems = [];
            if (resetData.session_passkey_cleared) clearedItems.push('PKI cache');
            if (resetData.db_entry_removed) clearedItems.push('database entry');
            const clearedMsg = clearedItems.length > 0 ? `Cleared: ${clearedItems.join(', ')}. ` : '';

            resultDiv.innerHTML = `<i class="bi bi-hourglass-split"></i> ${clearedMsg}Retrying admin test...`;

            // Step 2: Wait a moment for changes to take effect
            await new Promise(resolve => setTimeout(resolve, 500));

            // Step 3: Retry the admin test
            const testResponse = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const testData = await testResponse.json();

            resultDiv.classList.remove('alert-info');

            if (testData.success && testData.administrable) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> <strong>Success after reset!</strong>
                    Node ${testData.hex_id || nodeId} is now administrable.
                    <button class="btn btn-sm btn-outline-success ms-2" onclick="location.reload()">
                        <i class="bi bi-arrow-clockwise"></i> Refresh Page
                    </button>`;
            } else {
                resultDiv.classList.add('alert-warning');
                const errorMsg = testData.error || 'Still not responding after admin state reset.';
                resultDiv.innerHTML = `<i class="bi bi-exclamation-triangle"></i> <strong>Still Not Administrable</strong><br>
                    ${errorMsg}<br>
                    <small class="text-muted mt-2 d-block">
                        The node may need its admin keys reconfigured, or it may be unreachable.
                        Try connecting directly to the node via USB/Bluetooth to verify its admin key settings.
                    </small>`;
            }
        } catch (error) {
            resultDiv.classList.remove('alert-info');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error resetting admin state: ${error.message}`;
        }
    }

    // Select node for commands
    function selectNode(nodeId) {
        selectedNodeId = nodeId;
        setTargetNode(nodeId);

        // Switch to commands tab
        const commandsTab = document.getElementById('commands-tab');
        bootstrap.Tab.getOrCreateInstance(commandsTab).show();

        // Check admin status for the selected node
        checkAdminStatus(nodeId);

        showAlert('info', `Selected node ${nodeId} for commands`);
    }

    // Command log management (similar to reboot log)
    let commandLogLines = [];
    let commandSpinnerInterval = null;
    let commandSpinnerFrame = 0;
    const commandSpinnerFrames = ['/', '-', '\\', '|'];

    function initCommandLog() {
        commandLogLines = [];
        const container = document.getElementById('commandResponse');
        container.innerHTML = '<pre id="commandLogPre" style="margin: 0; font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></pre>';
        // Auto-switch to JSON/Log view when starting a command
        showJsonView();
    }

    function addCommandLog(message, isSpinnerLine = false) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logLine = `[${timestamp}] ${message}`;

        if (isSpinnerLine) {
            if (commandLogLines.length > 0 && commandLogLines[commandLogLines.length - 1].isSpinner) {
                commandLogLines[commandLogLines.length - 1] = { text: logLine, isSpinner: true };
            } else {
                commandLogLines.push({ text: logLine, isSpinner: true });
            }
        } else {
            commandLogLines.push({ text: logLine, isSpinner: false });
        }

        updateCommandLogDisplay();
    }

    function updateCommandLogDisplay() {
        const pre = document.getElementById('commandLogPre');
        if (!pre) return;

        const text = commandLogLines.map(line => line.text).join('\n');
        pre.textContent = text;
        pre.scrollTop = pre.scrollHeight;
    }

    function startCommandSpinner(baseMessage) {
        stopCommandSpinner();
        commandSpinnerFrame = 0;

        const updateSpinner = () => {
            const spinner = commandSpinnerFrames[commandSpinnerFrame % commandSpinnerFrames.length];
            addCommandLog(`${spinner} ${baseMessage}`, true);
            commandSpinnerFrame++;
        };

        updateSpinner();
        commandSpinnerInterval = setInterval(updateSpinner, 250);
    }

    function stopCommandSpinner() {
        if (commandSpinnerInterval) {
            clearInterval(commandSpinnerInterval);
            commandSpinnerInterval = null;
        }
    }

    function finalizeCommandLog(message, success = true) {
        stopCommandSpinner();
        if (commandLogLines.length > 0 && commandLogLines[commandLogLines.length - 1].isSpinner) {
            commandLogLines.pop();
        }
        const symbol = success ? '✓' : '✗';
        addCommandLog(`${symbol} ${message}`);
    }

    // Helper to highlight the active config button
    function highlightConfigButton(btn) {
        // Remove highlight from all config request buttons
        document.querySelectorAll('.config-req-btn').forEach(b => {
            b.classList.remove('btn-primary', 'btn-success', 'active');
            // Restore original outline style
            if (b.closest('#moduleConfigRequestBtns')) {
                b.classList.add('btn-outline-primary');
            } else if (b.closest('#channelRequestBtns')) {
                b.classList.add('btn-outline-info');
            } else {
                b.classList.add('btn-outline-secondary');
            }
        });

        // Highlight the clicked button
        if (btn) {
            btn.classList.remove('btn-outline-secondary', 'btn-outline-primary', 'btn-outline-info');
            btn.classList.add('btn-primary', 'active');
        }
    }

    // Get configuration with retry support
    async function getConfig(configType, btn = null) {
        highlightConfigButton(btn);

        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        // Get retry settings from UI if available
        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting ${configType} config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/config/${configType}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = configType;
                isModuleConfig = false;  // This is a regular config
                currentConfigData = data.config;
                currentConfigSchema = data.schema;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Config received successfully${attemptsMsg}`);

                // Refresh session passkey status (a new passkey may have been received)
                refreshSessionPasskeys();

                // Render the form if we have schema
                if (data.schema && data.config) {
                    renderConfigForm(configType, data.config, data.schema);
                    showConfigForm();
                }

                // Also append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.config, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get config: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Get module configuration with retry support
    async function getModuleConfig(moduleType, btn = null) {
        highlightConfigButton(btn);

        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting ${moduleType} module config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/moduleconfig/${moduleType}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = moduleType;
                isModuleConfig = true;  // This is a module config
                currentConfigData = data.config;
                currentConfigSchema = data.schema;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Module config received successfully${attemptsMsg}`);

                // Render the form if we have schema
                if (data.schema && data.config) {
                    renderConfigForm(moduleType, data.config, data.schema);
                    showConfigForm();
                }

                // Also append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.config, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get module config: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Render editable config form
    function renderConfigForm(configType, config, schema) {
        const container = document.getElementById('configFields');
        const configValues = config[configType] || config;

        let html = `<h6 class="mb-3"><i class="bi bi-gear"></i> ${configType.charAt(0).toUpperCase() + configType.slice(1)} Configuration</h6>`;

        for (const field of schema) {
            const value = configValues[field.name];
            const fieldId = `config_${field.name}`;

            html += `<div class="config-field">`;
            html += `<label for="${fieldId}" class="form-label">${field.label}</label>`;

            if (field.type === 'boolean') {
                html += `
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="${fieldId}"
                               name="${field.name}" ${value ? 'checked' : ''}>
                    </div>
                `;
            } else if (field.type === 'enum' && field.enum) {
                html += `<select class="form-select form-select-sm" id="${fieldId}" name="${field.name}">`;
                for (const [enumVal, enumLabel] of Object.entries(field.enum)) {
                    const selected = parseInt(enumVal) === value ? 'selected' : '';
                    html += `<option value="${enumVal}" ${selected}>${enumLabel} (${enumVal})</option>`;
                }
                html += `</select>`;
            } else if (field.type === 'number') {
                const min = field.min !== null ? `min="${field.min}"` : '';
                const max = field.max !== null ? `max="${field.max}"` : '';
                html += `
                    <div class="input-group input-group-sm">
                        <input type="number" class="form-control" id="${fieldId}"
                               name="${field.name}" value="${value !== undefined ? value : ''}"
                               ${min} ${max}>
                        ${field.unit ? `<span class="input-group-text config-field-unit">${field.unit}</span>` : ''}
                    </div>
                `;
            } else if (field.type === 'password') {
                html += `
                    <input type="text" class="form-control form-control-sm font-monospace" id="${fieldId}"
                           name="${field.name}" value="${value || ''}" placeholder="Hex key">
                `;
            } else if (field.readonly) {
                html += `
                    <input type="text" class="form-control form-control-sm" id="${fieldId}"
                           name="${field.name}" value="${value !== undefined ? value : ''}" readonly disabled>
                `;
            } else {
                html += `
                    <input type="text" class="form-control form-control-sm" id="${fieldId}"
                           name="${field.name}" value="${value !== undefined ? value : ''}">
                `;
            }

            if (field.description) {
                html += `<div class="form-text">${field.description}</div>`;
            }

            html += `</div>`;
        }

        container.innerHTML = html;
        document.getElementById('configFormActions').style.display = 'flex';
    }

    // Show/hide form vs JSON view
    function showConfigForm() {
        document.getElementById('responseViewToggle').style.display = 'block';
        document.getElementById('commandResponseForm').style.display = 'block';
        document.getElementById('commandResponse').style.display = 'none';
        updateViewToggle(true);
    }

    function hideConfigForm() {
        document.getElementById('responseViewToggle').style.display = 'none';
        document.getElementById('commandResponseForm').style.display = 'none';
        document.getElementById('commandResponse').style.display = 'block';
    }

    function showFormView() {
        document.getElementById('commandResponseForm').style.display = 'block';
        document.getElementById('commandResponse').style.display = 'none';
        updateViewToggle(true);
    }

    function showJsonView() {
        document.getElementById('commandResponseForm').style.display = 'none';
        document.getElementById('commandResponse').style.display = 'block';
        updateViewToggle(false);
    }

    function updateViewToggle(formActive) {
        const buttons = document.querySelectorAll('#responseViewToggle .btn');
        buttons[0].classList.toggle('active', formActive);
        buttons[1].classList.toggle('active', !formActive);
    }

    // Core config types vs module config types
    const coreConfigTypes = ['device', 'position', 'power', 'network', 'display', 'lora', 'bluetooth', 'security'];
    const moduleConfigTypes = ['mqtt', 'serial', 'extnotif', 'storeforward', 'rangetest', 'telemetry',
                               'cannedmsg', 'audio', 'remotehardware', 'neighborinfo', 'ambientlighting',
                               'detectionsensor', 'paxcounter'];

    // Compare two values for equality (handles arrays, objects, etc.)
    function configValuesEqual(original, current, fieldType) {
        // Handle null/undefined
        if (original === null || original === undefined) {
            if (fieldType === 'boolean') return current === false;
            if (fieldType === 'number' || fieldType === 'enum') return current === 0;
            if (fieldType === 'text') return current === '' || current === null;
            return current === null || current === undefined || current === '';
        }

        // Arrays (like admin_key)
        if (Array.isArray(original)) {
            if (!Array.isArray(current)) return false;
            if (original.length !== current.length) return false;
            // Compare each element
            for (let i = 0; i < original.length; i++) {
                if (original[i] !== current[i]) return false;
            }
            return true;
        }

        // Direct comparison for primitives
        return original === current;
    }

    // Save config changes as a background job
    async function saveConfig() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId || !currentConfigType || !currentConfigSchema) {
            alert('No configuration loaded to save');
            return;
        }

        // Collect form values and compare with original
        const changedFields = {};
        let changeCount = 0;

        for (const field of currentConfigSchema) {
            const element = document.getElementById(`config_${field.name}`);
            if (!element || field.readonly) continue;

            let currentValue;
            if (field.type === 'boolean') {
                currentValue = element.checked;
            } else if (field.type === 'enum' || field.type === 'number') {
                currentValue = parseInt(element.value);
            } else {
                currentValue = element.value;
            }

            // Get original value from the config we fetched
            const originalValue = currentConfigData ? currentConfigData[field.name] : null;

            // Only include if changed
            if (!configValuesEqual(originalValue, currentValue, field.type)) {
                changedFields[field.name] = currentValue;
                changeCount++;
                console.log(`Field '${field.name}' changed: ${JSON.stringify(originalValue)} → ${JSON.stringify(currentValue)}`);
            }
        }

        // Check if anything changed
        if (changeCount === 0) {
            showAlert('info', 'No changes detected - nothing to save');
            return;
        }

        showAlert('info', `Queuing ${changeCount} configuration change(s)...`);

        try {
            // Queue as a background job so progress can be monitored
            const result = await jobManager.queueConfigDeploy(nodeId, currentConfigType, changedFields);

            if (result.success && result.job_id) {
                showAlert('success', `Configuration job queued! Job ID: ${result.job_id} (${changeCount} field(s) changed)`);

                // Switch to Jobs tab to show progress
                const jobsTab = document.querySelector('[data-bs-target="#jobs-pane"]');
                if (jobsTab) {
                    jobsTab.click();
                }

                // Refresh job list and open job details
                await refreshJobsList();
                viewJobDetails(result.job_id);
            } else {
                showAlert('danger', `Failed to queue job: ${result.error}`);
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Refresh current config
    async function refreshConfig() {
        if (currentConfigType) {
            await getConfig(currentConfigType);
        }
    }

    // Get channel with retry support
    async function getChannel(channelIndex, btn = null) {
        highlightConfigButton(btn);

        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting channel ${channelIndex} config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/channel/${channelIndex}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = 'channel';
                currentConfigData = data.channel;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Channel received successfully${attemptsMsg}`);

                // Render channel form
                renderChannelForm(channelIndex, data.channel);
                showConfigForm();

                // Append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.channel, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get channel: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Render channel edit form
    function renderChannelForm(channelIndex, channel) {
        const container = document.getElementById('configFields');

        const roleOptions = {
            0: 'DISABLED',
            1: 'PRIMARY',
            2: 'SECONDARY'
        };

        const settings = channel.settings || {};
        const moduleSettings = settings.module_settings || {};

        let html = `
            <h6 class="mb-3"><i class="bi bi-broadcast"></i> Channel ${channelIndex} Configuration</h6>
            <input type="hidden" id="channel_index" value="${channelIndex}">

            <div class="config-field">
                <label class="form-label">Channel Role</label>
                <select class="form-select form-select-sm" id="channel_role" name="role">
                    ${Object.entries(roleOptions).map(([val, label]) =>
                        `<option value="${val}" ${parseInt(val) === channel.role ? 'selected' : ''}>${label}</option>`
                    ).join('')}
                </select>
            </div>

            <div class="config-field">
                <label class="form-label">Channel Name</label>
                <input type="text" class="form-control form-control-sm" id="channel_name"
                       name="name" value="${settings.name || ''}">
                <div class="form-text">Display name for this channel</div>
            </div>

            <div class="config-field">
                <label class="form-label">Pre-Shared Key (PSK)</label>
                <input type="text" class="form-control form-control-sm font-monospace" id="channel_psk"
                       name="psk" value="${settings.psk || ''}" placeholder="Hex encoded key">
                <div class="form-text">Encryption key in hexadecimal format</div>
            </div>

            <div class="config-field">
                <label class="form-label">Position Precision</label>
                <input type="number" class="form-control form-control-sm" id="channel_position_precision"
                       name="position_precision" value="${moduleSettings.position_precision || 0}"
                       min="0" max="32">
                <div class="form-text">Bits of precision (0=full, 32=no location)</div>
            </div>
        `;

        container.innerHTML = html;

        // Override save button for channels
        document.getElementById('configFormActions').style.display = 'flex';
        currentConfigSchema = [{name: 'role'}, {name: 'name'}, {name: 'psk'}, {name: 'position_precision'}];
    }

    // Override saveConfig for channels
    const originalSaveConfig = saveConfig;
    saveConfig = async function() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId || !currentConfigType) {
            alert('No configuration loaded to save');
            return;
        }

        if (currentConfigType === 'channel') {
            await saveChannel();
        } else {
            // Collect form values and compare with original
            const formData = {};
            let changeCount = 0;

            for (const field of currentConfigSchema) {
                const element = document.getElementById(`config_${field.name}`);
                if (!element || field.readonly) continue;

                let currentValue;
                if (field.type === 'boolean') {
                    currentValue = element.checked;
                } else if (field.type === 'enum' || field.type === 'number') {
                    currentValue = parseInt(element.value);
                } else {
                    currentValue = element.value;
                }

                // Get original value from the config we fetched
                const originalValue = currentConfigData ? currentConfigData[field.name] : null;

                // Only include if changed
                if (!configValuesEqual(originalValue, currentValue, field.type)) {
                    formData[field.name] = currentValue;
                    changeCount++;
                    console.log(`Field '${field.name}' changed: ${JSON.stringify(originalValue)} → ${JSON.stringify(currentValue)}`);
                }
            }

            // Check if anything changed
            if (changeCount === 0) {
                showAlert('info', 'No changes detected - nothing to save');
                return;
            }

            showAlert('info', `Queuing ${changeCount} configuration change(s)...`);

            try {
                // Queue as a background job so progress can be monitored
                // The job system handles both regular configs and module configs
                const result = await jobManager.queueConfigDeploy(nodeId, currentConfigType, formData);

                if (result.success && result.job_id) {
                    showAlert('success', `Configuration job queued! Job ID: ${result.job_id} (${changeCount} field(s) changed)`);

                    // Switch to Jobs tab to show progress
                    const jobsTab = document.querySelector('[data-bs-target="#jobs-pane"]');
                    if (jobsTab) {
                        jobsTab.click();
                    }

                    // Refresh job list and open job details
                    await refreshJobsList();
                    viewJobDetails(result.job_id);
                } else {
                    showAlert('danger', `Failed to queue job: ${result.error}`);
                }
            } catch (error) {
                showAlert('danger', `Error: ${error.message}`);
            }
        }
    };

    // Save channel
    async function saveChannel() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        const channelIndex = parseInt(document.getElementById('channel_index').value);

        const channelData = {
            role: parseInt(document.getElementById('channel_role').value),
            name: document.getElementById('channel_name').value,
            psk: document.getElementById('channel_psk').value,
            position_precision: parseInt(document.getElementById('channel_position_precision').value) || 0
        };

        showAlert('info', 'Saving channel configuration...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/channel/${channelIndex}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(channelData)
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Channel ${channelIndex} saved successfully!`);
                showCommandResponse(JSON.stringify({saved: channelData, message: data.message}, null, 2));
            } else {
                showAlert('danger', `Failed to save channel: ${data.error}`);
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Get node config shortcut from nodes table
    async function getNodeConfig(nodeId, configType) {
        setTargetNode(nodeId);

        // Switch to commands tab
        const commandsTab = document.getElementById('commands-tab');
        bootstrap.Tab.getOrCreateInstance(commandsTab).show();

        await getConfig(configType);
    }

    // Format uptime seconds to human readable string
    function formatUptimeSeconds(seconds) {
        if (!seconds || seconds <= 0) return '—';

        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);

        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0 || parts.length === 0) parts.push(`${minutes}m`);

        return parts.join(' ');
    }

    // Format datetime for admin confirmed time (respects timezone preference)
    function formatAdminDateTime(date) {
        if (!date) date = new Date();

        // Use formatTimestamp if available (from timezone-utils.js)
        if (typeof formatTimestamp === 'function') {
            const timestamp = Math.floor(date.getTime() / 1000);
            return formatTimestamp(timestamp, 'datetime');
        }

        // Fallback: format as YYYY-MM-DD HH:MM:SS (matching the database format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // Refresh node admin info - tests admin access and fetches metadata + telemetry
    async function refreshNodeAdminInfo(nodeId) {
        const refreshBtn = document.getElementById(`admin-node-refresh-btn-${nodeId}`);
        const statusCell = document.getElementById(`admin-node-status-${nodeId}`);
        const fwCell = document.getElementById(`admin-node-fw-${nodeId}`);
        const hwCell = document.getElementById(`admin-node-hw-${nodeId}`);
        const capsCell = document.getElementById(`admin-node-caps-${nodeId}`);
        const uptimeCell = document.getElementById(`admin-node-uptime-${nodeId}`);
        const confirmedCell = document.getElementById(`admin-node-confirmed-${nodeId}`);

        // Show loading state
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
        }
        if (statusCell) {
            statusCell.innerHTML = '<span class="badge bg-warning text-dark"><i class="bi bi-hourglass-split"></i> Testing...</span>';
        }

        try {
            // Fetch telemetry data in parallel with admin test
            const [adminResponse, telemetryResponse] = await Promise.all([
                fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, { method: 'POST' }),
                fetch(`/api/node/${encodeURIComponent(nodeId)}/telemetry`)
            ]);

            const data = await adminResponse.json();
            const telemetryData = await telemetryResponse.json();

            // Update uptime from telemetry if available
            if (uptimeCell && telemetryData.telemetry) {
                const dm = telemetryData.telemetry.device_metrics;
                if (dm && dm.uptime_seconds) {
                    uptimeCell.innerHTML = `<span class="text-muted small" title="${dm.uptime_seconds} seconds">${formatUptimeSeconds(dm.uptime_seconds)}</span>`;
                } else {
                    uptimeCell.innerHTML = '<span class="text-muted small">—</span>';
                }
            }

            if (data.success && data.administrable) {
                // Success - update the row with new info
                if (statusCell) {
                    statusCell.innerHTML = '<span class="badge bg-success"><i class="bi bi-check-circle"></i> Online</span>';
                }

                // Update firmware version if returned
                if (data.response && data.response.firmware_version && fwCell) {
                    fwCell.textContent = data.response.firmware_version;
                }

                // Update hardware model if returned
                if (data.response && data.response.hw_model && hwCell) {
                    hwCell.textContent = data.response.hw_model;
                }

                // Update capabilities icons
                if (capsCell && data.response) {
                    const caps = [];
                    if (data.response.has_wifi) {
                        caps.push('<i class="bi bi-wifi" title="WiFi"></i>');
                    }
                    if (data.response.has_bluetooth) {
                        caps.push('<i class="bi bi-bluetooth" title="Bluetooth"></i>');
                    }
                    if (data.response.can_shutdown) {
                        caps.push('<i class="bi bi-power" title="Can Shutdown"></i>');
                    }
                    if (data.response.role !== undefined && data.response.role !== null) {
                        const roleNames = {
                            0: 'Client', 1: 'Client Mute', 2: 'Router',
                            3: 'Router Client', 4: 'Repeater', 5: 'Tracker', 6: 'Sensor'
                        };
                        const roleName = roleNames[data.response.role] || `Role ${data.response.role}`;
                        caps.push(`<span class="badge bg-info text-dark" title="Device Role">${roleName}</span>`);
                    }
                    capsCell.innerHTML = caps.length > 0 ? caps.join(' ') : '<span class="text-muted small">—</span>';
                }

                // Update last confirmed time
                if (confirmedCell) {
                    const now = new Date();
                    confirmedCell.innerHTML = `<span class="text-muted small">${formatAdminDateTime(now)}</span>`;
                }

                showAlert('success', `Node ${data.hex_id} is online and administrable`);
            } else {
                // Failed to get response
                if (statusCell) {
                    statusCell.innerHTML = '<span class="badge bg-danger"><i class="bi bi-x-circle"></i> No Response</span>';
                }
                showAlert('warning', data.error || 'Node did not respond to admin request');
            }
        } catch (error) {
            // Error occurred
            if (statusCell) {
                statusCell.innerHTML = '<span class="badge bg-danger"><i class="bi bi-exclamation-triangle"></i> Error</span>';
            }
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            // Restore button
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i>';
            }
        }
    }

    // State for refresh all operation
    let refreshAllInProgress = false;
    let refreshAllCancelled = false;

    // Refresh all administrable nodes with adaptive timing based on hop count
    async function refreshAllAdminNodes() {
        if (refreshAllInProgress) return;

        refreshAllInProgress = true;
        refreshAllCancelled = false;

        const refreshBtn = document.getElementById('refreshAllNodesBtn');
        const cancelBtn = document.getElementById('cancelRefreshAllBtn');
        const progressDiv = document.getElementById('refreshAllProgress');
        const progressBar = progressDiv?.querySelector('.progress-bar');
        const statusSpan = document.getElementById('refreshAllStatus');

        // Show controls
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Fetching hop data...';
        }
        if (cancelBtn) cancelBtn.classList.remove('d-none');
        if (progressDiv) progressDiv.classList.remove('d-none');
        if (statusSpan) statusSpan.textContent = 'Estimating hop distances...';

        try {
            // Fetch hop estimates from API
            const hopResponse = await fetch('/api/admin/nodes/hop-estimates');
            const hopData = await hopResponse.json();

            if (!hopResponse.ok || hopData.error) {
                throw new Error(hopData.error || 'Failed to get hop estimates');
            }

            const hopEstimates = hopData.hop_estimates || {};

            // Get all node rows
            const tbody = document.getElementById('administrableNodesBody');
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll('tr[id^="admin-node-row-"]'));
            if (rows.length === 0) {
                showAlert('info', 'No administrable nodes to refresh');
                return;
            }

            // Sort nodes by hop count (nearest first, then unknown)
            const nodesWithHops = rows.map(row => {
                const nodeId = row.id.replace('admin-node-row-', '');
                const estimate = hopEstimates[nodeId];
                return {
                    nodeId: parseInt(nodeId),
                    row: row,
                    estimatedHops: estimate?.estimated_hops ?? null,
                    delayMs: estimate?.recommended_delay_ms ?? 7000  // Default 7s if unknown
                };
            }).sort((a, b) => {
                // Sort by hops: known hops ascending, unknown last
                if (a.estimatedHops === null && b.estimatedHops === null) return 0;
                if (a.estimatedHops === null) return 1;
                if (b.estimatedHops === null) return -1;
                return a.estimatedHops - b.estimatedHops;
            });

            const totalNodes = nodesWithHops.length;
            let completed = 0;
            let successCount = 0;
            let failCount = 0;

            if (refreshBtn) {
                refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Refreshing...';
            }

            for (const node of nodesWithHops) {
                if (refreshAllCancelled) {
                    if (statusSpan) statusSpan.textContent = `Cancelled. ${successCount} successful, ${failCount} failed.`;
                    break;
                }

                const hopText = node.estimatedHops !== null ? `${node.estimatedHops} hops` : 'unknown hops';
                if (statusSpan) {
                    statusSpan.textContent = `Refreshing ${completed + 1}/${totalNodes}: !${node.nodeId.toString(16).padStart(8, '0')} (${hopText})...`;
                }

                try {
                    await refreshNodeAdminInfo(node.nodeId);
                    successCount++;
                } catch (err) {
                    console.error(`Failed to refresh node ${node.nodeId}:`, err);
                    failCount++;
                }

                completed++;

                // Update progress bar
                if (progressBar) {
                    const percent = Math.round((completed / totalNodes) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressBar.setAttribute('aria-valuenow', percent);
                }

                // Wait adaptive time before next request (skip delay after last node)
                if (completed < totalNodes && !refreshAllCancelled) {
                    const delaySeconds = Math.ceil(node.delayMs / 1000);
                    if (statusSpan) {
                        statusSpan.textContent = `Waiting ${delaySeconds}s for ${hopText} response time... (${completed}/${totalNodes} done)`;
                    }
                    await new Promise(resolve => setTimeout(resolve, node.delayMs));
                }
            }

            if (!refreshAllCancelled) {
                if (statusSpan) {
                    statusSpan.textContent = `Refresh complete: ${successCount} online, ${failCount} failed out of ${totalNodes} nodes`;
                }
                showAlert('success', `Refreshed ${successCount} of ${totalNodes} nodes successfully`);
            }

        } catch (error) {
            console.error('Refresh all error:', error);
            showAlert('danger', `Error: ${error.message}`);
            if (statusSpan) statusSpan.textContent = `Error: ${error.message}`;
        } finally {
            refreshAllInProgress = false;

            // Restore UI
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i> Refresh All Nodes';
            }
            if (cancelBtn) cancelBtn.classList.add('d-none');

            // Hide progress after a delay
            setTimeout(() => {
                if (progressDiv && !refreshAllInProgress) {
                    progressDiv.classList.add('d-none');
                    if (progressBar) progressBar.style.width = '0%';
                }
            }, 3000);
        }
    }

    // Cancel the refresh all operation
    function cancelRefreshAllNodes() {
        refreshAllCancelled = true;
        const cancelBtn = document.getElementById('cancelRefreshAllBtn');
        if (cancelBtn) {
            cancelBtn.disabled = true;
            cancelBtn.innerHTML = '<i class="bi bi-hourglass"></i> Cancelling...';
        }
    }

    // Legacy function name for compatibility
    async function refreshAllNodes() {
        await refreshAllAdminNodes();
    }

    // Confirm reboot from nodes table
    function confirmReboot(nodeId) {
        showConfirmModal(
            'Confirm Reboot',
            `Are you sure you want to reboot node ${nodeId}?<br><br>
            <span class="text-muted">The node will restart in 5 seconds after the command is sent.</span>`,
            async () => {
                await sendReboot(nodeId);
            }
        );
    }

    // Confirm reboot target node
    function confirmRebootTarget() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }
        confirmReboot(nodeId);
    }

    // Confirm shutdown target node
    function confirmShutdownTarget() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }
        showConfirmModal(
            'Confirm Shutdown',
            `<strong class="text-danger">Warning!</strong> Are you sure you want to shut down node ${nodeId}?<br><br>
            <span class="text-muted">The node will power off and will need to be manually restarted.</span>`,
            async () => {
                await sendShutdown(nodeId);
            }
        );
    }

    // Confirm remove node from nodedb
    function confirmRemoveNode() {
        const targetNodeId = getNodeIdFromInput('targetNodeInput');
        const nodeToRemove = document.getElementById('nodeToRemoveInput').value.trim();

        if (!targetNodeId) {
            alert('Please enter a target node ID first');
            return;
        }
        if (!nodeToRemove) {
            alert('Please enter the node ID to remove');
            return;
        }

        showConfirmModal(
            'Confirm Remove Node',
            `Remove node <strong>${nodeToRemove}</strong> from <strong>${targetNodeId}</strong>'s node database?<br><br>
            <span class="text-muted">The node will be forgotten by the target. It can be rediscovered later.</span>`,
            async () => {
                await sendRemoveNode(targetNodeId, nodeToRemove);
            }
        );
    }

    // Send remove node command
    async function sendRemoveNode(targetNodeId, nodeToRemove) {
        initCommandLog();
        addCommandLog(`Sending remove_node command to ${targetNodeId}...`);
        addCommandLog(`Node to remove: ${nodeToRemove}`);

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(targetNodeId)}/remove-node`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ node_to_remove: nodeToRemove })
            });

            const data = await response.json();

            if (data.success) {
                finalizeCommandLog(`✓ ${data.message}`);
                showAlert('success', data.message);
                document.getElementById('nodeToRemoveInput').value = '';
            } else {
                finalizeCommandLog(`✗ Failed: ${data.error}`, false);
                showAlert('danger', data.error);
            }
        } catch (error) {
            finalizeCommandLog(`✗ Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Show nodedb reset modal
    function showNodedbResetModal() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        showConfirmModal(
            'Confirm NodeDB Reset',
            `<strong class="text-warning">Warning!</strong> Reset the node database on <strong>${nodeId}</strong>?<br><br>
            <span class="text-muted">This will clear all known nodes from the device. It will need to rediscover the mesh.</span>`,
            async () => {
                await sendNodedbReset(nodeId);
            }
        );
    }

    // Send nodedb reset command
    async function sendNodedbReset(nodeId) {
        initCommandLog();
        addCommandLog(`Sending nodedb_reset command to ${nodeId}...`);

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/nodedb-reset`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            const data = await response.json();

            if (data.success) {
                finalizeCommandLog(`✓ ${data.message}`);
                showAlert('success', data.message);
            } else {
                finalizeCommandLog(`✗ Failed: ${data.error}`, false);
                showAlert('danger', data.error);
            }
        } catch (error) {
            finalizeCommandLog(`✗ Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Show factory reset modal
    function showFactoryResetModal() {
        const nodeId = getNodeIdFromInput('targetNodeInput');
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        // Use a custom modal with radio buttons for reset type
        const modalHtml = `
            <strong class="text-danger">Warning!</strong> Factory reset node <strong>${nodeId}</strong>?<br><br>
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="resetType" id="resetConfigOnly" value="config" checked>
                <label class="form-check-label" for="resetConfigOnly">
                    <strong>Config Only</strong> - Reset settings, preserve node database
                </label>
            </div>
            <div class="form-check mb-3">
                <input class="form-check-input" type="radio" name="resetType" id="resetFull" value="full">
                <label class="form-check-label" for="resetFull">
                    <strong>Full Reset</strong> - Reset everything including node database
                </label>
            </div>
            <span class="text-muted">The node will reboot with default settings.</span>
        `;

        showConfirmModal(
            'Confirm Factory Reset',
            modalHtml,
            async () => {
                const configOnly = document.getElementById('resetConfigOnly').checked;
                await sendFactoryReset(nodeId, configOnly);
            }
        );
    }

    // Send factory reset command
    async function sendFactoryReset(nodeId, configOnly) {
        const resetType = configOnly ? 'config reset' : 'full factory reset';
        initCommandLog();
        addCommandLog(`Sending ${resetType} command to ${nodeId}...`);

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/factory-reset`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ config_only: configOnly })
            });

            const data = await response.json();

            if (data.success) {
                finalizeCommandLog(`✓ ${data.message}`);
                showAlert('success', data.message);
            } else {
                finalizeCommandLog(`✗ Failed: ${data.error}`, false);
                showAlert('danger', data.error);
            }
        } catch (error) {
            finalizeCommandLog(`✗ Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Quick check if node is responding (lighter than full test)
    async function isNodeResponding(nodeId, timeoutMs = 5000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            const data = await response.json();
            return data.success && data.administrable;
        } catch (error) {
            clearTimeout(timeoutId);
            return false;
        }
    }

    // Reboot log management
    let rebootLogLines = [];
    let spinnerInterval = null;
    let spinnerFrame = 0;
    const spinnerFrames = ['/', '-', '\\', '|'];

    function initRebootLog() {
        rebootLogLines = [];
        const container = document.getElementById('commandResponse');
        container.innerHTML = '<pre id="rebootLogPre" style="margin: 0; font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></pre>';
    }

    function addRebootLog(message, isSpinnerLine = false) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logLine = `[${timestamp}] ${message}`;

        if (isSpinnerLine) {
            // Replace last line if it was a spinner line
            if (rebootLogLines.length > 0 && rebootLogLines[rebootLogLines.length - 1].isSpinner) {
                rebootLogLines[rebootLogLines.length - 1] = { text: logLine, isSpinner: true };
            } else {
                rebootLogLines.push({ text: logLine, isSpinner: true });
            }
        } else {
            rebootLogLines.push({ text: logLine, isSpinner: false });
        }

        updateRebootLogDisplay();
    }

    function updateRebootLogDisplay() {
        const pre = document.getElementById('rebootLogPre');
        if (!pre) return;

        const text = rebootLogLines.map(line => line.text).join('\n');
        pre.textContent = text;
        pre.scrollTop = pre.scrollHeight;
    }

    function startSpinner(baseMessage) {
        stopSpinner();
        spinnerFrame = 0;

        const updateSpinner = () => {
            const spinner = spinnerFrames[spinnerFrame % spinnerFrames.length];
            addRebootLog(`${spinner} ${baseMessage}`, true);
            spinnerFrame++;
        };

        updateSpinner();
        spinnerInterval = setInterval(updateSpinner, 250);
    }

    function stopSpinner() {
        if (spinnerInterval) {
            clearInterval(spinnerInterval);
            spinnerInterval = null;
        }
    }

    function finalizeRebootLog(message, success = true) {
        stopSpinner();
        // Remove the last spinner line if present
        if (rebootLogLines.length > 0 && rebootLogLines[rebootLogLines.length - 1].isSpinner) {
            rebootLogLines.pop();
        }
        const symbol = success ? '✓' : '✗';
        addRebootLog(`${symbol} ${message}`);
    }

    // Update reboot progress UI
    function updateRebootProgress(phase, progress, message, details) {
        const banner = document.getElementById('adminStatusBanner');
        if (!banner) return;

        // Create or get progress container
        let progressContainer = document.getElementById('rebootProgressContainer');
        if (!progressContainer) {
            progressContainer = document.createElement('div');
            progressContainer.id = 'rebootProgressContainer';
            progressContainer.className = 'mt-3';
            banner.querySelector('.status-details')?.appendChild(progressContainer);
        }

        // Phase icons and colors
        const phases = {
            'sending': { icon: 'bi-send', color: 'warning' },
            'waiting-shutdown': { icon: 'bi-hourglass-split', color: 'warning' },
            'offline': { icon: 'bi-power', color: 'secondary' },
            'waiting-online': { icon: 'bi-arrow-repeat', color: 'info' },
            'reconnecting': { icon: 'bi-plug', color: 'primary' },
            'complete': { icon: 'bi-check-circle', color: 'success' },
            'error': { icon: 'bi-x-circle', color: 'danger' }
        };

        const phaseInfo = phases[phase] || phases['sending'];

        progressContainer.innerHTML = `
            <div class="d-flex align-items-center mb-2">
                <i class="bi ${phaseInfo.icon} text-${phaseInfo.color} me-2" style="font-size: 1.2rem;"></i>
                <strong>${message}</strong>
            </div>
            <div class="progress" style="height: 8px;">
                <div class="progress-bar bg-${phaseInfo.color} ${phase === 'offline' || phase === 'waiting-online' ? 'progress-bar-striped progress-bar-animated' : ''}"
                     role="progressbar"
                     style="width: ${progress}%;"
                     aria-valuenow="${progress}"
                     aria-valuemin="0"
                     aria-valuemax="100">
                </div>
            </div>
            <small class="text-muted mt-1 d-block">${details || ''}</small>
        `;

        // Update banner styling
        updateAdminStatusBanner(phaseInfo.color === 'success' ? 'success' : 'warning',
            phase === 'complete' ? 'Reboot Complete' : 'Rebooting Node...', '');
    }

    // Monitor reboot process with real-time updates
    async function monitorReboot(nodeId) {
        const POLL_INTERVAL = 3000;  // Check every 3 seconds
        const SHUTDOWN_TIMEOUT = 15000;  // Max time to wait for shutdown (15s)
        const ONLINE_TIMEOUT = 120000;  // Max time to wait for online (2 min)

        let phase = 'waiting-shutdown';
        let startTime = Date.now();
        let offlineDetectedTime = null;
        const nodeHex = `!${nodeId.toString(16).padStart(8, '0')}`;

        // Initialize log
        initRebootLog();
        addRebootLog(`Reboot command sent to ${nodeHex}`);
        addRebootLog('Node will restart in 5 seconds...');

        updateRebootProgress('waiting-shutdown', 10, 'Waiting for node to shut down...',
            'The node will restart in a few seconds');

        // Phase 1: Wait for node to go offline
        addRebootLog('Phase 1: Waiting for node to go offline');
        startSpinner('Polling node status...');

        while (Date.now() - startTime < SHUTDOWN_TIMEOUT) {
            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));

            const responding = await isNodeResponding(nodeId, 4000);
            const elapsed = Math.round((Date.now() - startTime) / 1000);

            if (!responding) {
                // Node is offline!
                stopSpinner();
                offlineDetectedTime = Date.now();
                phase = 'offline';
                finalizeRebootLog(`Node offline detected after ${elapsed}s`);
                updateRebootProgress('offline', 30, 'Node is offline',
                    `Shutdown detected after ${elapsed}s. Waiting for restart...`);
                break;
            } else {
                // Still online, update progress
                const progress = 10 + (elapsed / (SHUTDOWN_TIMEOUT / 1000)) * 20;
                updateRebootProgress('waiting-shutdown', Math.min(progress, 29),
                    'Waiting for node to shut down...',
                    `Still responding after ${elapsed}s...`);
                startSpinner(`Polling node status... (${elapsed}s elapsed, still online)`);
            }
        }

        // If we didn't detect offline, assume it went offline and we missed it
        if (!offlineDetectedTime) {
            stopSpinner();
            offlineDetectedTime = Date.now();
            phase = 'offline';
            addRebootLog('! Node shutdown not detected, assuming offline');
            updateRebootProgress('offline', 30, 'Node appears offline',
                'Shutdown assumed. Waiting for restart...');
        }

        // Phase 2: Wait for node to come back online
        phase = 'waiting-online';
        let pollCount = 0;
        const maxPolls = Math.ceil(ONLINE_TIMEOUT / POLL_INTERVAL);

        addRebootLog('Phase 2: Waiting for node to come back online');
        startSpinner('Waiting for node to boot...');

        while (Date.now() - offlineDetectedTime < ONLINE_TIMEOUT) {
            pollCount++;
            const progress = 30 + (pollCount / maxPolls) * 50;
            const waitTime = Math.round((Date.now() - offlineDetectedTime) / 1000);

            updateRebootProgress('waiting-online', Math.min(progress, 79),
                'Waiting for node to come back online...',
                `Polling... (${waitTime}s since shutdown)`);
            startSpinner(`Polling node... (${waitTime}s since shutdown, attempt ${pollCount})`);

            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));

            const responding = await isNodeResponding(nodeId, 4000);

            if (responding) {
                // Node is back online!
                stopSpinner();
                finalizeRebootLog(`Node responded after ${waitTime}s`);

                phase = 'reconnecting';
                updateRebootProgress('reconnecting', 85, 'Node is back online!',
                    'Re-establishing admin session...');
                addRebootLog('Phase 3: Re-establishing admin session');
                startSpinner('Negotiating session key...');

                // Refresh admin info
                await refreshNodeAdminInfo(nodeId);
                stopSpinner();
                finalizeRebootLog('Admin session established');

                // Update admin status for selected node
                const targetNodeInput = document.getElementById('targetNodeInput');
                if (targetNodeInput && targetNodeInput.value.trim() == nodeId) {
                    lastCheckedNodeId = null;
                    await checkAdminStatus(nodeId);
                }

                // Complete!
                const totalTime = Math.round((Date.now() - startTime) / 1000);
                updateRebootProgress('complete', 100, 'Reboot complete!',
                    `Node rebooted successfully in ${totalTime}s`);
                addRebootLog('─'.repeat(40));
                addRebootLog(`✓ REBOOT COMPLETE - Total time: ${totalTime}s`);
                addRebootLog('─'.repeat(40));
                showAlert('success', 'Node rebooted successfully');

                // Clear progress after a few seconds
                setTimeout(() => {
                    const progressContainer = document.getElementById('rebootProgressContainer');
                    if (progressContainer) {
                        progressContainer.remove();
                    }
                }, 5000);

                return true;
            }
        }

        // Timeout - node didn't come back
        stopSpinner();
        const totalWait = Math.round((Date.now() - offlineDetectedTime) / 1000);
        finalizeRebootLog(`Timeout after ${totalWait}s waiting for node`, false);
        addRebootLog('─'.repeat(40));
        addRebootLog('✗ REBOOT TIMEOUT - Node did not respond');
        addRebootLog('─'.repeat(40));

        updateRebootProgress('error', 100, 'Timeout waiting for node',
            'Node did not respond within expected time. It may still be booting or have issues.');
        showAlert('warning', 'Node reboot timeout - please check the device');

        return false;
    }

    // Send reboot command
    async function sendReboot(nodeId) {
        updateRebootProgress('sending', 5, 'Sending reboot command...', '');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/reboot`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ delay_seconds: 5 })
            });
            const data = await response.json();

            if (data.success) {
                showCommandResponse(data.message);
                showAlert('success', data.message);

                // Start real-time reboot monitoring
                await monitorReboot(nodeId);
            } else {
                showCommandResponse(`Error: ${data.error}`, true);
                updateRebootProgress('error', 0, 'Failed to send reboot', data.error);
            }
        } catch (error) {
            showCommandResponse(`Error: ${error.message}`, true);
            updateRebootProgress('error', 0, 'Error sending reboot', error.message);
        }
    }

    // Send shutdown command
    async function sendShutdown(nodeId) {
        showCommandResponse('Sending shutdown command...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/shutdown`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ delay_seconds: 5 })
            });
            const data = await response.json();

            if (data.success) {
                showCommandResponse(data.message);
                showAlert('warning', data.message);

                // Update status to show shutting down
                updateAdminStatusBanner('warning', 'Node is shutting down...',
                    'The node will power off in a few seconds. It will not respond to commands until manually powered on.');
            } else {
                showCommandResponse(`Error: ${data.error}`, true);
            }
        } catch (error) {
            showCommandResponse(`Error: ${error.message}`, true);
        }
    }

    // Show command response
    function showCommandResponse(content, isError = false) {
        const container = document.getElementById('commandResponse');
        if (isError) {
            container.innerHTML = `<span class="text-danger">${content}</span>`;
        } else {
            container.textContent = content;
        }
    }

    // Refresh audit log
    async function refreshLog() {
        const container = document.getElementById('auditLogContainer');
        container.innerHTML = `
            <div class="text-center py-3">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        `;

        try {
            const response = await fetch('/api/admin/log?limit=100');
            const data = await response.json();

            if (data.log && data.log.length > 0) {
                let html = `
                    <div class="table-responsive">
                        <table class="table table-sm table-hover audit-log-table">
                            <thead class="table-light">
                                <tr>
                                    <th style="width: 140px;">Time</th>
                                    <th style="width: 200px;">Target Node</th>
                                    <th>Action</th>
                                    <th style="width: 100px;">Duration</th>
                                    <th style="width: 90px;">Status</th>
                                    <th style="width: 40px;"></th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                for (const entry of data.log) {
                    const timestamp = formatAdminDateTime(new Date(entry.timestamp * 1000));
                    const statusClass = `log-status-${entry.status}`;
                    const entryId = `log-entry-${entry.id}`;

                    // Build target display with both hex ID and name
                    const targetHex = entry.target_node_hex || `!${(entry.target_node_id >>> 0).toString(16).padStart(8, '0')}`;
                    const targetName = entry.target_node_name || '';
                    const targetDisplay = targetName
                        ? `<div><code class="small">${targetHex}</code></div><div class="text-muted small">${escapeHtmlBasic(targetName)}</div>`
                        : `<code>${targetHex}</code>`;

                    // Get friendly command name and icon
                    const cmdInfo = getCommandDisplayInfo(entry.command_type);

                    // Build command summary
                    let commandDetail = '';
                    if (entry.command_summary) {
                        commandDetail = `<div class="text-muted small text-truncate" style="max-width: 300px;">${escapeHtmlBasic(entry.command_summary)}</div>`;
                    }

                    // Format duration
                    let durationDisplay = '—';
                    if (entry.duration_ms !== undefined) {
                        if (entry.duration_ms < 1000) {
                            durationDisplay = `${entry.duration_ms}ms`;
                        } else {
                            durationDisplay = `${(entry.duration_ms / 1000).toFixed(1)}s`;
                        }
                    } else if (entry.status === 'pending') {
                        durationDisplay = '<span class="spinner-border spinner-border-sm" role="status"></span>';
                    }

                    // Build popover content
                    const popoverContent = buildLogPopoverContent(entry);

                    html += `
                        <tr class="log-entry ${entry.status === 'failed' || entry.status === 'timeout' ? 'table-danger' : ''}"
                            id="${entryId}"
                            data-bs-toggle="popover"
                            data-bs-trigger="click"
                            data-bs-placement="left"
                            data-bs-html="true"
                            data-bs-custom-class="log-details-popover"
                            data-bs-content="${escapeHtml(popoverContent)}"
                            title="${cmdInfo.name} Details"
                            style="cursor: pointer;">
                            <td class="log-timestamp small">${timestamp}</td>
                            <td>${targetDisplay}</td>
                            <td>
                                <div class="d-flex align-items-center gap-2">
                                    <i class="bi bi-${cmdInfo.icon} text-${cmdInfo.color}"></i>
                                    <div>
                                        <div>${cmdInfo.name}</div>
                                        ${commandDetail}
                                    </div>
                                </div>
                            </td>
                            <td class="text-center small">${durationDisplay}</td>
                            <td class="${statusClass}">
                                <span class="badge bg-${getStatusBadgeColor(entry.status)}">
                                    <i class="bi bi-${getStatusIcon(entry.status)}"></i>
                                    ${entry.status}
                                </span>
                            </td>
                            <td class="text-center">
                                <i class="bi bi-chevron-right text-muted"></i>
                            </td>
                        </tr>
                    `;
                }

                html += '</tbody></table></div>';
                container.innerHTML = html;

                // Initialize popovers for the log entries
                const popoverTriggerList = container.querySelectorAll('[data-bs-toggle="popover"]');
                const popovers = [];
                popoverTriggerList.forEach(el => {
                    const popover = new bootstrap.Popover(el, {
                        container: 'body',
                        sanitize: false
                    });
                    popovers.push(popover);
                });

                // Close popover when clicking outside
                document.addEventListener('click', function closePopover(e) {
                    // Check if click is outside any popover and its trigger
                    const isPopoverClick = e.target.closest('.popover') || e.target.closest('[data-bs-toggle="popover"]');
                    if (!isPopoverClick) {
                        popovers.forEach(p => p.hide());
                    }
                }, { once: false });
            } else {
                container.innerHTML = `
                    <div class="text-center py-5 text-muted">
                        <i class="bi bi-journal fs-1 d-block mb-2"></i>
                        No admin commands logged yet.<br>
                        <small>Commands will appear here when you interact with nodes.</small>
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> Error loading audit log: ${error.message}
                </div>
            `;
        }
    }

    // Get display info for command types
    function getCommandDisplayInfo(commandType) {
        const commands = {
            'get_config': { name: 'Get Config', icon: 'gear', color: 'primary' },
            'set_config': { name: 'Set Config', icon: 'gear-fill', color: 'warning' },
            'get_module_config': { name: 'Get Module Config', icon: 'puzzle', color: 'primary' },
            'set_module_config': { name: 'Set Module Config', icon: 'puzzle-fill', color: 'warning' },
            'get_channel': { name: 'Get Channel', icon: 'broadcast', color: 'primary' },
            'set_channel': { name: 'Set Channel', icon: 'broadcast-pin', color: 'warning' },
            'reboot': { name: 'Reboot', icon: 'arrow-clockwise', color: 'danger' },
            'shutdown': { name: 'Shutdown', icon: 'power', color: 'danger' },
            'factory_reset': { name: 'Factory Reset', icon: 'exclamation-triangle', color: 'danger' },
            'nodedb_reset': { name: 'NodeDB Reset', icon: 'database-x', color: 'danger' },
            'remove_node': { name: 'Remove Node', icon: 'person-x', color: 'warning' },
            'enter_dfu': { name: 'Enter DFU', icon: 'download', color: 'info' },
            'traceroute': { name: 'Traceroute', icon: 'diagram-3', color: 'info' },
            'request_position': { name: 'Request Position', icon: 'geo-alt', color: 'info' },
            'begin_edit': { name: 'Begin Edit', icon: 'pencil-square', color: 'secondary' },
            'commit_edit': { name: 'Commit Edit', icon: 'check-square', color: 'success' },
            'set_owner': { name: 'Set Owner', icon: 'person-badge', color: 'warning' },
            'set_fixed_position': { name: 'Set Position', icon: 'geo-alt-fill', color: 'warning' },
        };

        return commands[commandType] || { name: commandType, icon: 'terminal', color: 'secondary' };
    }

    // Get badge color for status
    function getStatusBadgeColor(status) {
        const colors = {
            'success': 'success',
            'failed': 'danger',
            'pending': 'warning',
            'timeout': 'secondary'
        };
        return colors[status] || 'secondary';
    }

    // Basic HTML escape (for simple strings, not for data attributes)
    function escapeHtmlBasic(text) {
        if (!text) return '';
        return text.replace(/&/g, '&amp;')
                   .replace(/</g, '&lt;')
                   .replace(/>/g, '&gt;');
    }

    // Build popover content for a log entry
    function buildLogPopoverContent(entry) {
        let content = '';
        const cmdInfo = getCommandDisplayInfo(entry.command_type);

        // Header with action info
        content += `<div class="log-popover-header mb-2 pb-2 border-bottom">`;
        content += `<div class="d-flex align-items-center gap-2">`;
        content += `<i class="bi bi-${cmdInfo.icon} text-${cmdInfo.color}"></i>`;
        content += `<strong>${cmdInfo.name}</strong>`;
        content += `</div>`;

        // Target node info
        const targetHex = entry.target_node_hex || `!${(entry.target_node_id >>> 0).toString(16).padStart(8, '0')}`;
        content += `<div class="small text-muted mt-1">`;
        content += `Target: <code>${targetHex}</code>`;
        if (entry.target_node_name) {
            content += ` (${escapeHtmlBasic(entry.target_node_name)})`;
        }
        content += `</div>`;

        // Timestamp
        const timestamp = formatAdminDateTime(new Date(entry.timestamp * 1000));
        content += `<div class="small text-muted">Sent: ${timestamp}</div>`;
        content += `</div>`;

        // Command data section
        if (entry.command_data) {
            try {
                const cmdData = JSON.parse(entry.command_data);
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label"><i class="bi bi-send"></i> Request Data</div>`;
                content += `<div class="log-details-content"><pre style="margin:0; white-space:pre-wrap; font-size:0.75rem;">${escapeHtmlBasic(JSON.stringify(cmdData, null, 2))}</pre></div>`;
                content += `</div>`;
            } catch (e) {
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label"><i class="bi bi-send"></i> Request Data</div>`;
                content += `<div class="log-details-content">${escapeHtmlBasic(entry.command_data)}</div>`;
                content += `</div>`;
            }
        }

        // Response data section
        if (entry.response_data) {
            try {
                const respData = JSON.parse(entry.response_data);
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label"><i class="bi bi-reply"></i> Response Data</div>`;
                content += `<div class="log-details-content log-success-content"><pre style="margin:0; white-space:pre-wrap; font-size:0.75rem;">${escapeHtmlBasic(JSON.stringify(respData, null, 2))}</pre></div>`;
                content += `</div>`;
            } catch (e) {
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label"><i class="bi bi-reply"></i> Response Data</div>`;
                content += `<div class="log-details-content log-success-content">${escapeHtmlBasic(entry.response_data)}</div>`;
                content += `</div>`;
            }
        }

        // Error message section
        if (entry.error_message) {
            content += `<div class="log-details-section">`;
            content += `<div class="log-details-label text-danger"><i class="bi bi-exclamation-circle"></i> Error</div>`;
            content += `<div class="log-details-content log-error-content">${escapeHtmlBasic(entry.error_message)}</div>`;
            content += `</div>`;
        }

        // If no command or response details, show a message
        if (!entry.command_data && !entry.response_data && !entry.error_message) {
            content += `<div class="text-muted small">No additional details recorded.</div>`;
        }

        // Footer with timing info
        content += `<div class="log-popover-footer mt-2 pt-2 border-top small text-muted">`;
        content += `<div class="d-flex justify-content-between">`;
        content += `<span>Log ID: ${entry.id}</span>`;
        if (entry.duration_ms !== undefined) {
            content += `<span>Duration: ${entry.duration_ms}ms</span>`;
        } else if (entry.response_timestamp && entry.timestamp) {
            const durationMs = ((entry.response_timestamp - entry.timestamp) * 1000).toFixed(0);
            content += `<span>Duration: ${durationMs}ms</span>`;
        }
        content += `</div>`;
        content += `</div>`;

        return content;
    }

    // Escape HTML for safe insertion into data attributes
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function getStatusIcon(status) {
        const icons = {
            'success': 'check-circle-fill',
            'failed': 'x-circle-fill',
            'pending': 'clock-fill',
            'timeout': 'exclamation-triangle-fill'
        };
        return icons[status] || 'question-circle';
    }

    // Show confirmation modal
    function showConfirmModal(title, body, onConfirm) {
        document.getElementById('confirmModalTitle').textContent = title;
        document.getElementById('confirmModalBody').innerHTML = body;

        const confirmBtn = document.getElementById('confirmModalBtn');
        confirmBtn.onclick = async () => {
            const modal = bootstrap.Modal.getInstance(document.getElementById('confirmModal'));
            modal.hide();
            await onConfirm();
        };

        const modal = new bootstrap.Modal(document.getElementById('confirmModal'));
        modal.show();
    }

    // Show toast alert
    function showAlert(type, message) {
        // Create a simple alert at the top of the page
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
        alertDiv.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px;';
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        document.body.appendChild(alertDiv);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }

    // Restore saved settings from localStorage
    function restoreSavedSettings() {
        // Restore connection type
        const savedConnType = loadSetting(STORAGE_KEYS.connectionType);
        if (savedConnType) {
            const connTypeSelect = document.getElementById('connectionTypeSelect');
            if (connTypeSelect && (savedConnType === 'mqtt' || savedConnType === 'tcp')) {
                connTypeSelect.value = savedConnType;
                // Update visibility of settings panels
                document.getElementById('mqttSettings').classList.toggle('d-none', savedConnType !== 'mqtt');
                document.getElementById('tcpSettings').classList.toggle('d-none', savedConnType !== 'tcp');
            }
        }

        // Restore TCP host
        const savedHost = loadSetting(STORAGE_KEYS.tcpHost);
        if (savedHost) {
            const hostInput = document.getElementById('tcpHostInput');
            if (hostInput) hostInput.value = savedHost;
        }

        // Restore TCP port
        const savedPort = loadSetting(STORAGE_KEYS.tcpPort);
        if (savedPort) {
            const portInput = document.getElementById('tcpPortInput');
            if (portInput) portInput.value = savedPort;
        }

        // Restore gateway node
        const savedGateway = loadSetting(STORAGE_KEYS.gatewayNode);
        if (savedGateway) {
            const gatewayInput = document.getElementById('gatewayNodeInput');
            if (gatewayInput && !gatewayInput.value) gatewayInput.value = savedGateway;
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        // Restore saved settings from localStorage
        restoreSavedSettings();

        // Load audit log when tab is shown
        document.getElementById('log-tab').addEventListener('shown.bs.tab', function() {
            refreshLog();
        });

        // Load templates when tab is shown
        document.getElementById('templates-tab').addEventListener('shown.bs.tab', function() {
            loadTemplates();
            loadDeploymentHistory();
            loadDeployNodesList();
        });

        // Check for node parameter in URL and pre-fill the target node
        const urlParams = new URLSearchParams(window.location.search);
        const nodeParam = urlParams.get('node');
        if (nodeParam) {
            setTargetNode(nodeParam);
            // Store the node ID for commands
            window.selectedTargetNode = nodeParam;
            // Switch to the Commands tab
            const commandsTab = document.getElementById('commands-tab');
            if (commandsTab) {
                const tab = new bootstrap.Tab(commandsTab);
                tab.show();
            }
        }
    });

    // ============================================================================
    // Configuration Templates
    // ============================================================================

    let currentTemplateId = null;

    async function loadTemplates() {
        const container = document.getElementById('templatesList');
        const typeFilter = document.getElementById('templateTypeFilter').value;

        container.innerHTML = '<div class="text-center py-3 text-muted"><i class="bi bi-arrow-clockwise spin"></i> Loading...</div>';

        try {
            const url = typeFilter ? `/api/admin/templates?type=${typeFilter}` : '/api/admin/templates';
            const response = await fetch(url);
            const data = await response.json();

            if (data.templates && data.templates.length > 0) {
                let html = '';
                for (const template of data.templates) {
                    const isActive = template.id === currentTemplateId ? 'active' : '';
                    const typeIcon = getTemplateTypeIcon(template.template_type);
                    html += `
                        <a href="#" class="list-group-item list-group-item-action ${isActive}"
                           onclick="selectTemplate(${template.id}); return false;">
                            <div class="d-flex justify-content-between align-items-start">
                                <div>
                                    <i class="bi ${typeIcon}"></i>
                                    <strong>${escapeHtml(template.name)}</strong>
                                    <br>
                                    <small class="text-muted">
                                        <span class="badge bg-secondary">${template.template_type}</span>
                                        ${template.description ? escapeHtml(template.description) : ''}
                                    </small>
                                </div>
                            </div>
                        </a>
                    `;
                }
                container.innerHTML = html;
            } else {
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-folder2-open"></i>
                        <p class="small mb-0">No templates found.<br>Click "New Template" to create one.</p>
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `<div class="text-danger p-3">Error loading templates: ${error.message}</div>`;
        }
    }

    function getTemplateTypeIcon(type) {
        const icons = {
            'device': 'bi-cpu',
            'lora': 'bi-broadcast',
            'channel': 'bi-hash',
            'position': 'bi-geo-alt',
            'power': 'bi-battery-charging',
            'network': 'bi-wifi',
            'display': 'bi-display',
            'bluetooth': 'bi-bluetooth',
        };
        return icons[type] || 'bi-file-earmark-code';
    }

    async function selectTemplate(templateId) {
        currentTemplateId = templateId;

        // Update active state in list
        document.querySelectorAll('#templatesList .list-group-item').forEach(el => {
            el.classList.remove('active');
        });

        try {
            const response = await fetch(`/api/admin/templates/${templateId}`);
            const template = await response.json();

            if (template.error) {
                showAlert('danger', template.error);
                return;
            }

            // Populate editor
            document.getElementById('templateName').value = template.name;
            document.getElementById('templateType').value = template.template_type;
            document.getElementById('templateDescription').value = template.description || '';

            const configData = typeof template.config_data === 'object'
                ? JSON.stringify(template.config_data, null, 2)
                : template.config_data;
            document.getElementById('templateConfigData').value = configData;

            // Show editor, hide placeholder
            document.getElementById('templateEditorSection').style.display = 'block';
            document.getElementById('templatePlaceholder').style.display = 'none';
            document.getElementById('templateEditorTitle').innerHTML = '<i class="bi bi-pencil"></i> Edit Template';
            document.getElementById('deleteTemplateBtn').style.display = 'inline-block';

            // Reload templates list to update active state
            loadTemplates();

            // Load compliance summary if available
            loadComplianceSummary();

            // Reset compliance results display
            document.getElementById('complianceResults').style.display = 'none';
            document.getElementById('complianceResultsContent').innerHTML = '';

        } catch (error) {
            showAlert('danger', `Error loading template: ${error.message}`);
        }
    }

    function showCreateTemplateModal() {
        currentTemplateId = null;

        // Clear editor
        document.getElementById('templateName').value = '';
        document.getElementById('templateType').value = 'lora';
        document.getElementById('templateDescription').value = '';
        document.getElementById('templateConfigData').value = '{\n  \n}';

        // Show editor
        document.getElementById('templateEditorSection').style.display = 'block';
        document.getElementById('templatePlaceholder').style.display = 'none';
        document.getElementById('templateEditorTitle').innerHTML = '<i class="bi bi-plus-lg"></i> Create New Template';
        document.getElementById('deleteTemplateBtn').style.display = 'none';

        // Focus on name field
        document.getElementById('templateName').focus();
    }

    async function saveTemplate() {
        const name = document.getElementById('templateName').value.trim();
        const templateType = document.getElementById('templateType').value;
        const description = document.getElementById('templateDescription').value.trim();
        const configDataStr = document.getElementById('templateConfigData').value.trim();

        if (!name) {
            showAlert('warning', 'Template name is required');
            return;
        }

        // Validate JSON
        let configData;
        try {
            configData = JSON.parse(configDataStr);
        } catch (e) {
            showAlert('danger', 'Invalid JSON in configuration data');
            return;
        }

        const saveBtn = document.getElementById('saveTemplateBtn');
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

        try {
            const url = currentTemplateId
                ? `/api/admin/templates/${currentTemplateId}`
                : '/api/admin/templates';
            const method = currentTemplateId ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    template_type: templateType,
                    description: description || null,
                    config_data: configData,
                }),
            });

            const result = await response.json();

            if (result.success || result.template_id) {
                showAlert('success', currentTemplateId ? 'Template updated!' : 'Template created!');
                if (result.template_id) {
                    currentTemplateId = result.template_id;
                }
                loadTemplates();
            } else {
                showAlert('danger', result.error || 'Failed to save template');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="bi bi-save"></i> Save';
        }
    }

    async function deleteTemplate() {
        if (!currentTemplateId) return;

        showConfirmModal(
            'Delete Template',
            'Are you sure you want to delete this template? This action cannot be undone.',
            async () => {
                try {
                    const response = await fetch(`/api/admin/templates/${currentTemplateId}`, {
                        method: 'DELETE',
                    });

                    const result = await response.json();

                    if (result.success) {
                        showAlert('success', 'Template deleted');
                        currentTemplateId = null;
                        document.getElementById('templateEditorSection').style.display = 'none';
                        document.getElementById('templatePlaceholder').style.display = 'block';
                        loadTemplates();
                    } else {
                        showAlert('danger', result.error || 'Failed to delete template');
                    }
                } catch (error) {
                    showAlert('danger', `Error: ${error.message}`);
                }
            }
        );
    }

    // ============================================================================
    // Template Deployment
    // ============================================================================

    async function loadDeployNodesList() {
        const container = document.getElementById('deployNodesList');

        try {
            const response = await fetch('/api/admin/nodes');
            const data = await response.json();

            if (data.nodes && data.nodes.length > 0) {
                let html = '';
                for (const node of data.nodes) {
                    const displayName = node.long_name || node.short_name || node.hex_id || `!${node.node_id.toString(16).padStart(8, '0')}`;
                    html += `
                        <div class="form-check">
                            <input class="form-check-input deploy-node-checkbox" type="checkbox"
                                   value="${node.node_id}" id="deployNode${node.node_id}">
                            <label class="form-check-label" for="deployNode${node.node_id}">
                                ${escapeHtml(displayName)}
                                <code class="text-muted small">${node.hex_id || ''}</code>
                            </label>
                        </div>
                    `;
                }
                container.innerHTML = html;
            } else {
                container.innerHTML = '<span class="text-muted small">No administrable nodes available</span>';
            }
        } catch (error) {
            container.innerHTML = `<span class="text-danger small">Error: ${error.message}</span>`;
        }
    }

    function selectAllDeployNodes() {
        document.querySelectorAll('.deploy-node-checkbox').forEach(cb => cb.checked = true);
    }

    function deselectAllDeployNodes() {
        document.querySelectorAll('.deploy-node-checkbox').forEach(cb => cb.checked = false);
    }

    // Deployment log lines for SSE streaming
    let deployLogLines = [];

    function initDeployLog() {
        deployLogLines = [];
    }

    function addDeployLog(message) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        deployLogLines.push(`[${timestamp}] ${message}`);
    }

    function renderDeployProgress(status, progress, logLines, nodeResults = []) {
        let html = `
            <div class="mb-2">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <span class="small fw-bold">${escapeHtml(status)}</span>
                    <span class="badge bg-primary">${progress}%</span>
                </div>
                <div class="progress" style="height: 8px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar"
                         style="width: ${progress}%;" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
            </div>
        `;

        // Show node results if any
        if (nodeResults.length > 0) {
            html += '<ul class="list-unstyled mb-2 small">';
            for (const r of nodeResults) {
                const icon = r.success ? 'check-circle text-success' : 'x-circle text-danger';
                const message = r.success ? 'Deployed successfully' : r.error;
                html += `
                    <li>
                        <i class="bi bi-${icon}"></i>
                        <code>${escapeHtml(r.node)}</code>: ${escapeHtml(message || 'Unknown')}
                    </li>
                `;
            }
            html += '</ul>';
        }

        // Show log console
        html += `
            <div class="bg-dark text-light rounded p-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                <pre id="deployLogPre" style="margin: 0; white-space: pre-wrap;">${escapeHtml(logLines.join('\n'))}</pre>
            </div>
        `;

        return html;
    }

    async function deployTemplate(forceDeployment = false, acknowledgedWarnings = false) {
        if (!currentTemplateId) {
            showAlert('warning', 'Please save the template first');
            return;
        }

        const selectedNodes = [];
        document.querySelectorAll('.deploy-node-checkbox:checked').forEach(cb => {
            selectedNodes.push(parseInt(cb.value));
        });

        if (selectedNodes.length === 0) {
            showAlert('warning', 'Please select at least one node');
            return;
        }

        const deployBtn = document.getElementById('deployTemplateBtn');
        deployBtn.disabled = true;
        deployBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Deploying...';

        const resultsDiv = document.getElementById('deploymentResults');
        resultsDiv.style.display = 'block';

        // Initialize deployment log
        initDeployLog();
        addDeployLog(`Starting deployment to ${selectedNodes.length} node(s)`);
        addDeployLog(`Template ID: ${currentTemplateId}`);
        addDeployLog(`Force: ${forceDeployment}, Acknowledged: ${acknowledgedWarnings}`);

        resultsDiv.innerHTML = renderDeployProgress('Connecting to server...', 0, deployLogLines);

        // Track node results for display
        const nodeResults = [];

        try {
            // Build SSE URL with query parameters
            const params = new URLSearchParams({
                node_ids: selectedNodes.join(','),
                force: forceDeployment.toString(),
                acknowledged_warnings: acknowledgedWarnings.toString(),
            });
            const url = `/api/admin/templates/${currentTemplateId}/deploy/stream?${params}`;

            addDeployLog(`Connecting to: ${url}`);
            resultsDiv.innerHTML = renderDeployProgress('Connecting...', 0, deployLogLines);

            const eventSource = new EventSource(url);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);

                // Check for completion
                if (data.complete) {
                    eventSource.close();

                    if (data.requires_force || data.requires_acknowledgment) {
                        // Handle warnings/blocking issues - show confirmation UI
                        let html = '';

                        // Show log first
                        addDeployLog('Validation issues detected');
                        html += `
                            <div class="bg-dark text-light rounded p-2 mb-2" style="max-height: 100px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                                <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                            </div>
                        `;

                        // Show blocking issues (critical)
                        if (data.blocking_issues && data.blocking_issues.length > 0) {
                            html += `
                                <div class="alert alert-danger py-2 mb-2">
                                    <strong><i class="bi bi-exclamation-octagon"></i> Critical Issues:</strong>
                                    <ul class="mb-0 mt-1">
                            `;
                            for (const issue of data.blocking_issues) {
                                html += `<li>${escapeHtml(issue)}</li>`;
                            }
                            html += `</ul></div>`;
                        }

                        // Show warnings
                        if (data.warnings && data.warnings.length > 0) {
                            html += `
                                <div class="alert alert-warning py-2 mb-2">
                                    <strong><i class="bi bi-exclamation-triangle"></i> Warnings:</strong>
                                    <ul class="mb-0 mt-1">
                            `;
                            for (const warning of data.warnings) {
                                html += `<li>${escapeHtml(warning)}</li>`;
                            }
                            html += `</ul></div>`;
                        }

                        // Show action buttons
                        if (data.requires_force) {
                            html += `
                                <div class="d-flex gap-2">
                                    <button class="btn btn-outline-secondary btn-sm" onclick="cancelDeploy()">Cancel</button>
                                    <button class="btn btn-danger btn-sm" onclick="deployTemplate(true, true)">
                                        <i class="bi bi-exclamation-triangle"></i> Deploy Anyway (Dangerous)
                                    </button>
                                </div>
                                <p class="text-muted small mt-2 mb-0">
                                    <i class="bi bi-info-circle"></i>
                                    Deploying this configuration may make nodes unreachable for future remote administration.
                                </p>
                            `;
                        } else if (data.requires_acknowledgment) {
                            html += `
                                <div class="d-flex gap-2">
                                    <button class="btn btn-outline-secondary btn-sm" onclick="cancelDeploy()">Cancel</button>
                                    <button class="btn btn-warning btn-sm" onclick="deployTemplate(false, true)">
                                        <i class="bi bi-check-lg"></i> I Understand, Proceed
                                    </button>
                                </div>
                            `;
                        }

                        resultsDiv.innerHTML = html;
                        deployBtn.disabled = false;
                        deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
                        return;
                    }

                    // Normal completion
                    addDeployLog('─────────────────────');
                    if (data.success) {
                        addDeployLog(`✓ Deployment complete: ${data.summary.successful}/${data.summary.total} successful`);
                    } else {
                        addDeployLog(`✗ Deployment finished with errors: ${data.summary.failed} failed`);
                    }

                    // Build final summary
                    const alertClass = data.success ? 'alert-success' : 'alert-warning';
                    let html = `
                        <div class="alert ${alertClass} py-2 mb-2">
                            <strong><i class="bi bi-${data.success ? 'check-circle' : 'exclamation-triangle'}"></i>
                                Deployment Complete:</strong>
                            ${data.summary.successful}/${data.summary.total} successful
                        </div>
                    `;

                    // Show log console
                    html += `
                        <div class="bg-dark text-light rounded p-2 mb-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                            <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                        </div>
                    `;

                    // Show node results
                    if (data.results && data.results.length > 0) {
                        html += '<ul class="list-unstyled mb-0 small">';
                        for (const r of data.results) {
                            const icon = r.success ? 'check-circle text-success' : 'x-circle text-danger';
                            const message = r.success ? r.message : r.error;
                            html += `
                                <li>
                                    <i class="bi bi-${icon}"></i>
                                    <code>${r.hex_id}</code>: ${escapeHtml(message || 'Unknown')}
                                </li>
                            `;
                        }
                        html += '</ul>';
                    }

                    resultsDiv.innerHTML = html;
                    loadDeploymentHistory();
                    deployBtn.disabled = false;
                    deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
                    return;
                }

                // Progress update
                if (data.status) {
                    addDeployLog(data.status);
                }

                // Track node results
                if (data.node_result) {
                    nodeResults.push(data.node_result);
                }

                const progress = data.progress || 0;
                const status = data.status || 'Processing...';

                resultsDiv.innerHTML = renderDeployProgress(status, progress, deployLogLines, nodeResults);

                // Auto-scroll log
                const logPre = document.getElementById('deployLogPre');
                if (logPre) {
                    logPre.parentElement.scrollTop = logPre.parentElement.scrollHeight;
                }
            };

            eventSource.onerror = function(error) {
                eventSource.close();
                addDeployLog('✗ Connection error');
                resultsDiv.innerHTML = `
                    <div class="alert alert-danger py-2 mb-2">
                        <i class="bi bi-x-circle"></i> Connection error during deployment
                    </div>
                    <div class="bg-dark text-light rounded p-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                        <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                    </div>
                `;
                deployBtn.disabled = false;
                deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
            };

        } catch (error) {
            addDeployLog(`✗ Error: ${error.message}`);
            resultsDiv.innerHTML = `
                <div class="alert alert-danger py-2 mb-2">${escapeHtml(error.message)}</div>
                <div class="bg-dark text-light rounded p-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                    <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                </div>
            `;
            deployBtn.disabled = false;
            deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
        }
    }

    function cancelDeploy() {
        const resultsDiv = document.getElementById('deploymentResults');
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
    }

    async function loadDeploymentHistory() {
        const tbody = document.getElementById('deploymentHistoryBody');

        try {
            const response = await fetch('/api/admin/deployments?limit=20');
            const data = await response.json();

            if (data.deployments && data.deployments.length > 0) {
                let html = '';
                for (const dep of data.deployments) {
                    const time = formatAdminDateTime(new Date(dep.deployed_at * 1000));
                    const statusClass = dep.status === 'success' ? 'text-success' : (dep.status === 'failed' ? 'text-danger' : 'text-warning');
                    const statusIcon = dep.status === 'success' ? 'check-circle' : (dep.status === 'failed' ? 'x-circle' : 'hourglass-split');
                    const nodeName = dep.node_name || dep.node_hex || `!${dep.node_id.toString(16).padStart(8, '0')}`;

                    html += `
                        <tr>
                            <td>
                                <span class="badge bg-secondary">${dep.template_type}</span>
                                ${escapeHtml(dep.template_name)}
                            </td>
                            <td><code>${escapeHtml(nodeName)}</code></td>
                            <td class="${statusClass}">
                                <i class="bi bi-${statusIcon}"></i> ${dep.status}
                            </td>
                            <td class="small text-muted">${time}</td>
                        </tr>
                    `;
                }
                tbody.innerHTML = html;
            } else {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No deployments yet</td></tr>';
            }
        } catch (error) {
            tbody.innerHTML = `<tr><td colspan="4" class="text-danger">Error: ${error.message}</td></tr>`;
        }
    }

    // ============================================================================
    // Compliance Check Functions
    // ============================================================================

    // Store template config for diff display
    let currentComplianceTemplateConfig = null;
    let complianceEventSource = null;
    let complianceAdminNodes = [];  // Cache of admin nodes for selection
    let nonCompliantNodeIds = [];   // Track non-compliant nodes for fix action

    // Initialize node filter dropdown behavior
    document.getElementById('complianceNodeFilter')?.addEventListener('change', function() {
        const selector = document.getElementById('complianceNodeSelector');
        if (this.value === 'selected') {
            selector.style.display = 'block';
            refreshComplianceNodeList();
        } else {
            selector.style.display = 'none';
        }
    });

    async function refreshComplianceNodeList() {
        const nodeList = document.getElementById('complianceNodeList');
        nodeList.innerHTML = '<span class="text-muted small"><i class="bi bi-arrow-clockwise spin"></i> Loading...</span>';

        try {
            const response = await fetch('/api/admin/nodes');
            const data = await response.json();

            complianceAdminNodes = data.nodes || [];

            if (complianceAdminNodes.length === 0) {
                nodeList.innerHTML = '<span class="text-muted small">No administrable nodes found</span>';
                return;
            }

            let html = '';
            for (const node of complianceAdminNodes) {
                const nodeHex = node.node_hex || `!${node.node_id.toString(16).padStart(8, '0')}`;
                const nodeName = node.long_name || node.short_name || nodeHex;
                html += `
                    <div class="form-check">
                        <input class="form-check-input compliance-node-check" type="checkbox"
                               value="${node.node_id}" id="complianceNode_${node.node_id}" checked>
                        <label class="form-check-label small" for="complianceNode_${node.node_id}">
                            ${escapeHtml(nodeName)} <code class="text-muted">${nodeHex}</code>
                        </label>
                    </div>
                `;
            }
            nodeList.innerHTML = html;
            updateComplianceSelectedCount();

            // Add change handlers
            document.querySelectorAll('.compliance-node-check').forEach(cb => {
                cb.addEventListener('change', updateComplianceSelectedCount);
            });

        } catch (error) {
            nodeList.innerHTML = `<span class="text-danger small">Error: ${error.message}</span>`;
        }
    }

    function selectAllComplianceNodes(select) {
        document.querySelectorAll('.compliance-node-check').forEach(cb => {
            cb.checked = select;
        });
        updateComplianceSelectedCount();
    }

    function updateComplianceSelectedCount() {
        const checked = document.querySelectorAll('.compliance-node-check:checked').length;
        const total = document.querySelectorAll('.compliance-node-check').length;
        document.getElementById('complianceSelectedCount').textContent = `${checked}/${total} selected`;
    }

    function getSelectedComplianceNodeIds() {
        const filter = document.getElementById('complianceNodeFilter').value;
        if (filter === 'all') {
            return null;  // null means check all admin nodes
        }
        const checked = document.querySelectorAll('.compliance-node-check:checked');
        return Array.from(checked).map(cb => parseInt(cb.value));
    }

    async function runComplianceCheck() {
        if (!currentTemplateId) {
            showAlert('warning', 'Please select a template first');
            return;
        }

        const selectedNodeIds = getSelectedComplianceNodeIds();
        if (selectedNodeIds && selectedNodeIds.length === 0) {
            showAlert('warning', 'Please select at least one node to check');
            return;
        }

        // Close any existing event source
        if (complianceEventSource) {
            complianceEventSource.close();
            complianceEventSource = null;
        }

        const runBtn = document.getElementById('runComplianceBtn');
        const resultsDiv = document.getElementById('complianceResults');
        const progressDiv = document.getElementById('complianceProgress');
        const contentDiv = document.getElementById('complianceResultsContent');

        runBtn.disabled = true;
        runBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Checking...';
        resultsDiv.style.display = 'block';
        progressDiv.style.display = 'block';

        // Initialize progress display
        document.getElementById('complianceProgressBar').style.width = '0%';
        document.getElementById('complianceProgressText').textContent = 'Initializing...';

        // Clear previous results and prepare real-time display
        contentDiv.innerHTML = `
            <div class="d-flex gap-3 mb-3" id="complianceSummaryRow">
                <div class="text-center">
                    <div class="h4 mb-0 text-success" id="complianceCompliantCount">0</div>
                    <small class="text-muted">Compliant</small>
                </div>
                <div class="text-center">
                    <div class="h4 mb-0 text-danger" id="complianceNonCompliantCount">0</div>
                    <small class="text-muted">Non-Compliant</small>
                </div>
                <div class="text-center">
                    <div class="h4 mb-0 text-warning" id="complianceErrorCount">0</div>
                    <small class="text-muted">Errors</small>
                </div>
            </div>
            <div class="compliance-results-list" id="complianceResultsList" style="max-height: 350px; overflow-y: auto;"></div>
        `;

        // Reset non-compliant tracking
        nonCompliantNodeIds = [];
        document.getElementById('complianceFixActions').style.display = 'none';

        try {
            // Build request body with optional node_ids
            const requestBody = { timeout: 30, max_retries: 3 };
            if (selectedNodeIds) {
                requestBody.node_ids = selectedNodeIds;
            }

            // Use fetch with POST to start the SSE stream
            const response = await fetch(`/api/admin/templates/${currentTemplateId}/compliance-check`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to start compliance check');
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(line.slice(6));
                            handleComplianceEvent(eventData);
                        } catch (e) {
                            console.error('Error parsing SSE data:', e);
                        }
                    }
                }
            }

        } catch (error) {
            progressDiv.style.display = 'none';
            contentDiv.innerHTML = `<div class="alert alert-danger py-2">Error: ${escapeHtml(error.message)}</div>`;
        } finally {
            runBtn.disabled = false;
            runBtn.innerHTML = '<i class="bi bi-search"></i> Run Compliance Check';
        }
    }

    function handleComplianceEvent(event) {
        const progressDiv = document.getElementById('complianceProgress');
        const progressBar = document.getElementById('complianceProgressBar');
        const progressText = document.getElementById('complianceProgressText');
        const resultsList = document.getElementById('complianceResultsList');

        switch (event.type) {
            case 'start':
                currentComplianceTemplateConfig = event.template_config;
                progressText.textContent = `Checking ${event.total_nodes} node${event.total_nodes !== 1 ? 's' : ''}...`;
                break;

            case 'checking':
                const percent = Math.round((event.current - 1) / event.total * 100);
                progressBar.style.width = `${percent}%`;
                progressText.innerHTML = `<i class="bi bi-arrow-repeat spin"></i> Checking <strong>${escapeHtml(event.node_name)}</strong> (${event.current}/${event.total})...`;
                break;

            case 'result':
                // Update counts
                document.getElementById('complianceCompliantCount').textContent = event.compliant_count;
                document.getElementById('complianceNonCompliantCount').textContent = event.non_compliant_count;
                document.getElementById('complianceErrorCount').textContent = event.error_count;

                // Track non-compliant nodes for fix action
                if (!event.result.is_compliant && !event.result.error) {
                    nonCompliantNodeIds.push(event.result.node_id);
                }

                // Update progress
                const resultPercent = Math.round(event.current / event.total * 100);
                progressBar.style.width = `${resultPercent}%`;
                progressText.textContent = `Checked ${event.current}/${event.total} nodes`;

                // Add result card
                appendComplianceResult(event.result);

                // Update summary badge
                updateComplianceSummaryBadge({
                    compliant_count: event.compliant_count,
                    non_compliant_count: event.non_compliant_count,
                    error_count: event.error_count,
                    total_checked: event.current,
                });
                break;

            case 'complete':
                progressDiv.style.display = 'none';
                currentComplianceTemplateConfig = event.template_config;

                // Add completion timestamp
                const timestamp = new Date().toLocaleString();
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'text-muted small mt-2';
                timestampDiv.textContent = `Last checked: ${timestamp}`;
                resultsList.parentNode.appendChild(timestampDiv);

                // Show fix actions if there are non-compliant nodes
                if (nonCompliantNodeIds.length > 0) {
                    document.getElementById('nonCompliantCountLabel').textContent = nonCompliantNodeIds.length;
                    document.getElementById('complianceFixActions').style.display = 'block';
                }
                break;
        }
    }

    function appendComplianceResult(result) {
        const resultsList = document.getElementById('complianceResultsList');
        const nodeName = result.node_name || result.node_hex;
        const nodeHex = result.node_hex;
        const resultId = `compliance-result-${result.node_id}`;
        const diffs = result.differences || [];

        let cardHtml = '';

        if (result.error) {
            // Error case
            cardHtml = `
                <div class="card mb-2 border-warning">
                    <div class="card-body py-2 px-3">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <span class="fw-semibold">${escapeHtml(nodeName)}</span>
                                <code class="text-muted small ms-2">${nodeHex}</code>
                            </div>
                            <span class="badge bg-warning"><i class="bi bi-exclamation-triangle"></i> Error</span>
                        </div>
                        <small class="text-muted">${escapeHtml(result.error)}</small>
                    </div>
                </div>
            `;
        } else if (result.is_compliant) {
            // Compliant case
            cardHtml = `
                <div class="card mb-2 border-success">
                    <div class="card-body py-2 px-3">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <span class="fw-semibold">${escapeHtml(nodeName)}</span>
                                <code class="text-muted small ms-2">${nodeHex}</code>
                            </div>
                            <span class="badge bg-success"><i class="bi bi-check-circle"></i> Compliant</span>
                        </div>
                    </div>
                </div>
            `;
        } else {
            // Non-compliant with expandable diff view
            let diffRows = '';
            for (const diff of diffs) {
                const expectedVal = diff.expected !== null && diff.expected !== undefined
                    ? (typeof diff.expected === 'object' ? JSON.stringify(diff.expected) : String(diff.expected))
                    : '<em class="text-muted">not set</em>';
                const actualVal = diff.actual !== null && diff.actual !== undefined
                    ? (typeof diff.actual === 'object' ? JSON.stringify(diff.actual) : String(diff.actual))
                    : '<em class="text-muted">not set</em>';

                diffRows += `
                    <tr>
                        <td><code>${escapeHtml(diff.field)}</code></td>
                        <td class="bg-success bg-opacity-10"><code>${diff.expected !== null ? escapeHtml(expectedVal) : expectedVal}</code></td>
                        <td class="bg-danger bg-opacity-10"><code>${diff.actual !== null ? escapeHtml(actualVal) : actualVal}</code></td>
                    </tr>
                `;
            }

            cardHtml = `
                <div class="card mb-2 border-danger">
                    <div class="card-header py-2 px-3 bg-danger bg-opacity-10"
                         style="cursor: pointer;"
                         onclick="toggleComplianceDiff('${resultId}')">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <i class="bi bi-chevron-right me-1" id="${resultId}-chevron"></i>
                                <span class="fw-semibold">${escapeHtml(nodeName)}</span>
                                <code class="text-muted small ms-2">${nodeHex}</code>
                            </div>
                            <span class="badge bg-danger">
                                <i class="bi bi-x-circle"></i> ${diffs.length} difference${diffs.length !== 1 ? 's' : ''}
                            </span>
                        </div>
                    </div>
                    <div class="collapse" id="${resultId}">
                        <div class="card-body py-2 px-3">
                            <table class="table table-sm table-bordered mb-0" style="font-size: 0.8rem;">
                                <thead class="table-light">
                                    <tr>
                                        <th style="width: 30%;">Field</th>
                                        <th style="width: 35%;" class="text-success">Expected (Template)</th>
                                        <th style="width: 35%;" class="text-danger">Actual (Node)</th>
                                    </tr>
                                </thead>
                                <tbody>${diffRows}</tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        resultsList.insertAdjacentHTML('beforeend', cardHtml);

        // Auto-scroll to show new result
        resultsList.scrollTop = resultsList.scrollHeight;
    }

    async function loadComplianceResults() {
        if (!currentTemplateId) {
            showAlert('warning', 'Please select a template first');
            return;
        }

        const loadBtn = document.getElementById('loadComplianceBtn');
        const resultsDiv = document.getElementById('complianceResults');
        const contentDiv = document.getElementById('complianceResultsContent');

        loadBtn.disabled = true;
        loadBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
        resultsDiv.style.display = 'block';
        contentDiv.innerHTML = '<div class="text-center text-muted"><span class="spinner-border spinner-border-sm"></span> Loading...</div>';

        try {
            const response = await fetch(`/api/admin/templates/${currentTemplateId}/compliance`);
            const data = await response.json();

            if (data.error) {
                contentDiv.innerHTML = `<div class="alert alert-danger py-2"><i class="bi bi-x-circle"></i> ${escapeHtml(data.error)}</div>`;
                return;
            }

            if (!data.results || data.results.length === 0) {
                contentDiv.innerHTML = '<div class="text-muted text-center py-2">No compliance checks run yet for this template</div>';
                updateComplianceSummaryBadge(null);
                return;
            }

            // Store template config for diff display
            currentComplianceTemplateConfig = data.template_config;

            displayComplianceResults(data);

        } catch (error) {
            contentDiv.innerHTML = `<div class="alert alert-danger py-2">Error: ${escapeHtml(error.message)}</div>`;
        } finally {
            loadBtn.disabled = false;
            loadBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i> Load Last Results';
        }
    }

    function displayComplianceResults(data) {
        const contentDiv = document.getElementById('complianceResultsContent');
        const summary = data.summary || {
            compliant_count: data.compliant_count || 0,
            non_compliant_count: data.non_compliant_count || 0,
            error_count: data.error_count || 0,
            total_checked: data.nodes_checked || 0,
        };

        // Update summary badge
        updateComplianceSummaryBadge(summary);

        let html = '';

        // Summary row
        html += `
            <div class="d-flex gap-3 mb-3">
                <div class="text-center">
                    <div class="h4 mb-0 text-success">${summary.compliant_count || 0}</div>
                    <small class="text-muted">Compliant</small>
                </div>
                <div class="text-center">
                    <div class="h4 mb-0 text-danger">${summary.non_compliant_count || 0}</div>
                    <small class="text-muted">Non-Compliant</small>
                </div>
                <div class="text-center">
                    <div class="h4 mb-0 text-warning">${summary.error_count || 0}</div>
                    <small class="text-muted">Errors</small>
                </div>
            </div>
        `;

        // Results list - accordion style for non-compliant nodes
        if (data.results && data.results.length > 0) {
            html += `<div class="compliance-results-list" style="max-height: 350px; overflow-y: auto;">`;

            for (const result of data.results) {
                const nodeName = result.node_name || result.short_name || result.node_hex || `!${result.node_id.toString(16).padStart(8, '0')}`;
                const nodeHex = result.node_hex || `!${result.node_id.toString(16).padStart(8, '0')}`;
                const resultId = `compliance-result-${result.node_id}`;
                const diffs = result.differences || result.diff_data || [];

                if (result.error || result.error_message) {
                    // Error case
                    html += `
                        <div class="card mb-2">
                            <div class="card-body py-2 px-3">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <span class="fw-semibold">${escapeHtml(nodeName)}</span>
                                        <code class="text-muted small ms-2">${nodeHex}</code>
                                    </div>
                                    <span class="badge bg-warning"><i class="bi bi-exclamation-triangle"></i> Error</span>
                                </div>
                                <small class="text-muted">${escapeHtml(result.error || result.error_message)}</small>
                            </div>
                        </div>
                    `;
                } else if (result.is_compliant) {
                    // Compliant case
                    html += `
                        <div class="card mb-2 border-success">
                            <div class="card-body py-2 px-3">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <span class="fw-semibold">${escapeHtml(nodeName)}</span>
                                        <code class="text-muted small ms-2">${nodeHex}</code>
                                    </div>
                                    <span class="badge bg-success"><i class="bi bi-check-circle"></i> Compliant</span>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Non-compliant with expandable diff view
                    html += `
                        <div class="card mb-2 border-danger">
                            <div class="card-header py-2 px-3 bg-danger bg-opacity-10"
                                 style="cursor: pointer;"
                                 onclick="toggleComplianceDiff('${resultId}')">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <i class="bi bi-chevron-right me-1" id="${resultId}-chevron"></i>
                                        <span class="fw-semibold">${escapeHtml(nodeName)}</span>
                                        <code class="text-muted small ms-2">${nodeHex}</code>
                                    </div>
                                    <span class="badge bg-danger">
                                        <i class="bi bi-x-circle"></i> ${diffs.length} difference${diffs.length !== 1 ? 's' : ''}
                                    </span>
                                </div>
                            </div>
                            <div class="collapse" id="${resultId}">
                                <div class="card-body py-2 px-3">
                                    <table class="table table-sm table-bordered mb-0" style="font-size: 0.8rem;">
                                        <thead class="table-light">
                                            <tr>
                                                <th style="width: 30%;">Field</th>
                                                <th style="width: 35%;" class="text-success">Expected (Template)</th>
                                                <th style="width: 35%;" class="text-danger">Actual (Node)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                    `;

                    for (const diff of diffs) {
                        const expectedVal = diff.expected !== null && diff.expected !== undefined
                            ? (typeof diff.expected === 'object' ? JSON.stringify(diff.expected) : String(diff.expected))
                            : '<em class="text-muted">not set</em>';
                        const actualVal = diff.actual !== null && diff.actual !== undefined
                            ? (typeof diff.actual === 'object' ? JSON.stringify(diff.actual) : String(diff.actual))
                            : '<em class="text-muted">not set</em>';

                        html += `
                            <tr>
                                <td><code>${escapeHtml(diff.field)}</code></td>
                                <td class="bg-success bg-opacity-10"><code>${diff.expected !== null ? escapeHtml(expectedVal) : expectedVal}</code></td>
                                <td class="bg-danger bg-opacity-10"><code>${diff.actual !== null ? escapeHtml(actualVal) : actualVal}</code></td>
                            </tr>
                        `;
                    }

                    html += `
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            html += `</div>`;

            // Last checked time
            if (summary.last_checked) {
                html += `<div class="text-muted small mt-2">Last checked: ${formatAdminDateTime(new Date(summary.last_checked * 1000))}</div>`;
            }
        }

        contentDiv.innerHTML = html;
    }

    function toggleComplianceDiff(resultId) {
        const collapseDiv = document.getElementById(resultId);
        const chevron = document.getElementById(resultId + '-chevron');

        if (collapseDiv.classList.contains('show')) {
            collapseDiv.classList.remove('show');
            chevron.classList.remove('bi-chevron-down');
            chevron.classList.add('bi-chevron-right');
        } else {
            collapseDiv.classList.add('show');
            chevron.classList.remove('bi-chevron-right');
            chevron.classList.add('bi-chevron-down');
        }
    }

    async function runComplianceFix() {
        if (!currentTemplateId || nonCompliantNodeIds.length === 0) {
            showAlert('warning', 'No non-compliant nodes to fix');
            return;
        }

        const rebootAfter = document.getElementById('rebootAfterFixCheckbox')?.checked || false;
        const nodeCount = nonCompliantNodeIds.length;
        let confirmMsg = `Are you sure you want to apply the template configuration to ${nodeCount} non-compliant node(s)?\n\nThis will modify the node settings to match the template.`;
        if (rebootAfter) {
            confirmMsg += `\n\n⚠️ Nodes will be REBOOTED after configuration is applied.`;
        }

        // Confirm action
        if (!confirm(confirmMsg)) {
            return;
        }

        const fixBtn = document.getElementById('runComplianceFixBtn');
        fixBtn.disabled = true;
        fixBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Starting fix...';

        try {
            const response = await fetch(`/api/admin/templates/${currentTemplateId}/compliance-fix`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    node_ids: nonCompliantNodeIds,
                    verify_after: true,
                    reboot_after: rebootAfter,
                }),
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Failed to start compliance fix');
            }

            if (data.success && data.job_id) {
                showAlert('success', `Compliance fix job started for ${data.node_count} node(s). Check the Jobs tab for progress.`);

                // Hide fix actions since job is running
                document.getElementById('complianceFixActions').style.display = 'none';

                // Switch to Jobs tab to show progress
                const jobsTab = document.querySelector('[data-bs-target="#jobs-pane"]');
                if (jobsTab) {
                    jobsTab.click();
                }

                // Refresh job list
                refreshJobsList();
            } else {
                throw new Error(data.error || 'Unknown error');
            }

        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            fixBtn.disabled = false;
            fixBtn.innerHTML = '<i class="bi bi-wrench"></i> Fix All Non-Compliant';
        }
    }

    function updateComplianceSummaryBadge(summary) {
        const badge = document.getElementById('complianceSummaryBadge');
        if (!badge) return;

        if (!summary || summary.total_checked === 0) {
            badge.style.display = 'none';
            return;
        }

        const total = (summary.compliant_count || 0) + (summary.non_compliant_count || 0);
        const compliant = summary.compliant_count || 0;

        if (compliant === total && total > 0) {
            badge.className = 'badge bg-success';
            badge.textContent = `${compliant}/${total} compliant`;
        } else if (compliant === 0) {
            badge.className = 'badge bg-danger';
            badge.textContent = `0/${total} compliant`;
        } else {
            badge.className = 'badge bg-warning text-dark';
            badge.textContent = `${compliant}/${total} compliant`;
        }
        badge.style.display = 'inline';
    }

    async function loadComplianceSummary() {
        if (!currentTemplateId) {
            updateComplianceSummaryBadge(null);
            return;
        }

        const resultsDiv = document.getElementById('complianceResults');
        const contentDiv = document.getElementById('complianceResultsContent');

        try {
            const response = await fetch(`/api/admin/templates/${currentTemplateId}/compliance`);
            const data = await response.json();

            if (data.error || !data.summary) {
                updateComplianceSummaryBadge(null);
                return;
            }

            // Store template config for diff display
            currentComplianceTemplateConfig = data.template_config;

            // Update the summary badge
            updateComplianceSummaryBadge(data.summary);

            // If there are results, display them automatically
            if (data.results && data.results.length > 0) {
                resultsDiv.style.display = 'block';
                displayComplianceResults(data);
            }

        } catch (error) {
            updateComplianceSummaryBadge(null);
        }
    }

    // ============================================================================
    // Create Template from Node
    // ============================================================================

    let extractedConfigType = null;
    let extractedConfig = null;

    function showCreateFromNodeModal() {
        resetExtractModal();

        // Populate node dropdown with administrable nodes
        const nodeSelect = document.getElementById('extractSourceNode');
        nodeSelect.innerHTML = '<option value="">Loading nodes...</option>';

        fetch('/api/admin/nodes')
            .then(r => r.json())
            .then(data => {
                if (data.nodes && data.nodes.length > 0) {
                    let html = '<option value="">Select an administrable node...</option>';
                    for (const node of data.nodes) {
                        const hexId = node.hex_id || `!${node.node_id.toString(16).padStart(8, '0')}`;
                        const displayName = node.long_name || node.short_name || hexId;
                        html += `<option value="${node.node_id}">${escapeHtml(displayName)} (${hexId})</option>`;
                    }
                    nodeSelect.innerHTML = html;
                } else {
                    nodeSelect.innerHTML = '<option value="">No administrable nodes found</option>';
                }
            })
            .catch(err => {
                nodeSelect.innerHTML = '<option value="">Error loading nodes</option>';
            });

        // Show/hide channel index based on config type
        document.getElementById('extractConfigType').addEventListener('change', function() {
            document.getElementById('channelIndexRow').style.display =
                this.value === 'channel' ? 'block' : 'none';
        });

        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('createFromNodeModal'));
        modal.show();
    }

    function resetExtractModal() {
        // Reset to step 1
        document.getElementById('extractStep1').style.display = 'block';
        document.getElementById('extractStep2').style.display = 'none';
        document.getElementById('extractBackBtn').style.display = 'none';
        document.getElementById('saveExtractedTemplateBtn').style.display = 'none';

        // Reset form
        document.getElementById('extractSourceNode').value = '';
        document.getElementById('extractConfigType').value = 'lora';
        document.getElementById('extractChannelIndex').value = '0';
        document.getElementById('channelIndexRow').style.display = 'none';
        document.getElementById('extractTemplateName').value = '';
        document.getElementById('extractTemplateDescription').value = '';
        document.getElementById('extractedConfigData').value = '';

        // Reset button state
        const btn = document.getElementById('extractConfigBtn');
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';

        extractedConfigType = null;
        extractedConfig = null;
    }

    async function extractConfigFromNode() {
        const nodeId = document.getElementById('extractSourceNode').value;
        const configType = document.getElementById('extractConfigType').value;
        const channelIndex = document.getElementById('extractChannelIndex').value;

        if (!nodeId) {
            showAlert('warning', 'Please select a source node');
            return;
        }

        const btn = document.getElementById('extractConfigBtn');
        const progressDiv = document.getElementById('extractionProgress');
        const statusEl = document.getElementById('extractionStatus');
        const progressBar = document.getElementById('extractionProgressBar');
        const detailsEl = document.getElementById('extractionDetails');

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Extracting...';
        progressDiv.style.display = 'block';
        statusEl.textContent = 'Connecting to node...';
        progressBar.style.width = '0%';
        detailsEl.textContent = '';

        // Build the SSE URL with query parameters
        const params = new URLSearchParams({
            node_id: nodeId,
            config_type: configType,
            channel_index: channelIndex
        });
        const sseUrl = `/api/admin/templates/extract-from-node/stream?${params.toString()}`;

        let eventSource = null;
        let lastData = null;

        try {
            eventSource = new EventSource(sseUrl);

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    lastData = data;

                    // Update progress display
                    if (data.status) {
                        statusEl.textContent = data.status;
                    }
                    if (data.progress !== undefined) {
                        progressBar.style.width = data.progress + '%';
                    }
                    if (data.details) {
                        detailsEl.textContent = data.details;
                    }

                    // Handle completion
                    if (data.complete) {
                        eventSource.close();
                        progressDiv.style.display = 'none';

                        if (data.success) {
                            // Store extracted data
                            extractedConfigType = configType;
                            extractedConfig = data.config_data;

                            // Show extracted node info
                            const nodeName = document.getElementById('extractSourceNode').selectedOptions[0].text;
                            document.getElementById('extractedFromNode').textContent = nodeName;

                            // Show excluded fields warning if any
                            if (data.excluded_fields && data.excluded_fields.length > 0) {
                                document.getElementById('excludedFieldsList').textContent = data.excluded_fields.join(', ');
                                document.getElementById('excludedFieldsWarning').style.display = 'block';
                            } else {
                                document.getElementById('excludedFieldsWarning').style.display = 'none';
                            }

                            // Populate config preview
                            document.getElementById('extractedConfigData').value = JSON.stringify(data.config_data, null, 2);

                            // Suggest a template name
                            const typeLabel = configType.charAt(0).toUpperCase() + configType.slice(1);
                            document.getElementById('extractTemplateName').value = `${typeLabel} Config from ${nodeName.split(' (')[0]}`;

                            // Switch to step 2
                            document.getElementById('extractStep1').style.display = 'none';
                            document.getElementById('extractStep2').style.display = 'block';
                            document.getElementById('extractBackBtn').style.display = 'inline-block';
                            document.getElementById('saveExtractedTemplateBtn').style.display = 'inline-block';
                        } else {
                            let errorMsg = data.error || 'Failed to extract configuration';
                            if (data.attempts) {
                                errorMsg += ` (after ${data.attempts} attempt(s))`;
                            }
                            showAlert('danger', errorMsg);
                        }

                        btn.disabled = false;
                        btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
                    }
                } catch (e) {
                    console.error('Error parsing SSE message:', e, event.data);
                }
            };

            eventSource.onerror = function(err) {
                console.error('SSE error:', err);
                eventSource.close();
                progressDiv.style.display = 'none';

                // If we got a final response before the error, it may have succeeded
                if (lastData && lastData.complete && lastData.success) {
                    return; // Already handled
                }

                showAlert('danger', 'Connection error while extracting configuration. Please try again.');
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
            };

        } catch (error) {
            progressDiv.style.display = 'none';
            showAlert('danger', `Error: ${error.message}`);
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
        }
    }

    async function saveExtractedTemplate() {
        const name = document.getElementById('extractTemplateName').value.trim();
        const description = document.getElementById('extractTemplateDescription').value.trim();

        if (!name) {
            showAlert('warning', 'Please enter a template name');
            return;
        }

        if (!extractedConfig) {
            showAlert('danger', 'No configuration data to save');
            return;
        }

        const btn = document.getElementById('saveExtractedTemplateBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

        try {
            const response = await fetch('/api/admin/templates', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    template_type: extractedConfigType,
                    description: description,
                    config_data: extractedConfig,
                }),
            });

            const data = await response.json();

            if (response.ok && data.success) {
                // Close modal
                bootstrap.Modal.getInstance(document.getElementById('createFromNodeModal')).hide();

                // Refresh templates list
                loadTemplates();

                // Select the new template
                setTimeout(() => {
                    selectTemplate(data.template_id);
                }, 500);

                showAlert('success', `Template "${name}" created successfully`);
            } else {
                showAlert('danger', data.error || 'Failed to create template');
            }

        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-save"></i> Create Template';
        }
    }

    // ============================================================================
    // Node Backup Functions
    // ============================================================================

    let currentBackupId = null;
    let currentBackupData = null;

    async function loadBackups() {
        const backupsList = document.getElementById('backupsList');

        backupsList.innerHTML = '<div class="text-center py-3 text-muted"><i class="bi bi-arrow-clockwise spin"></i> Loading backups...</div>';

        try {
            const response = await fetch('/api/admin/backups');
            const data = await response.json();

            if (data.backups && data.backups.length > 0) {
                // Group backups by node hex ID for consistent grouping
                const nodeGroups = {};
                for (const backup of data.backups) {
                    const nodeHex = backup.current_hex_id || backup.node_hex_id || `!${backup.node_id.toString(16).padStart(8, '0')}`;
                    if (!nodeGroups[nodeHex]) {
                        // Use current node name from node_info, fallback to backup's stored name
                        const currentName = backup.current_long_name || backup.current_short_name;
                        const backupName = backup.node_long_name || backup.node_short_name;
                        nodeGroups[nodeHex] = {
                            nodeId: backup.node_id,
                            nodeHex: nodeHex,
                            nodeName: currentName || backupName || nodeHex,
                            backups: []
                        };
                    }
                    // If we find a current name, always prefer it over backup names
                    if (backup.current_long_name || backup.current_short_name) {
                        nodeGroups[nodeHex].nodeName = backup.current_long_name || backup.current_short_name;
                    }
                    nodeGroups[nodeHex].backups.push(backup);
                }

                // Sort nodes by name, then sort backups within each node by date (newest first)
                const sortedNodes = Object.values(nodeGroups).sort((a, b) =>
                    a.nodeName.localeCompare(b.nodeName)
                );

                let html = '';
                for (const nodeGroup of sortedNodes) {
                    const backupCount = nodeGroup.backups.length;
                    const nodeId = `backup-node-${nodeGroup.nodeId}`;

                    // Sort backups by date (newest first)
                    nodeGroup.backups.sort((a, b) => b.created_at - a.created_at);

                    html += `
                        <div class="backup-node-group mb-2">
                            <div class="backup-node-header d-flex align-items-center p-2 rounded bg-light"
                                 onclick="toggleBackupNode('${nodeId}')"
                                 style="cursor: pointer; border: 1px solid #dee2e6;">
                                <i class="bi bi-chevron-right backup-chevron me-2" id="${nodeId}-chevron"></i>
                                <i class="bi bi-router text-primary me-2"></i>
                                <span class="fw-semibold flex-grow-1">${escapeHtml(nodeGroup.nodeName)}</span>
                                <code class="text-muted small me-2">${nodeGroup.nodeHex}</code>
                                <span class="badge bg-primary">${backupCount}</span>
                            </div>
                            <div class="backup-node-children ps-3" id="${nodeId}" style="display: none;">
                    `;

                    for (const backup of nodeGroup.backups) {
                        const created = formatAdminDateTime(new Date(backup.created_at * 1000));
                        const summary = backup.config_summary;
                        const configCount = (summary?.core_configs || 0) + (summary?.module_configs || 0) + (summary?.channels || 0);

                        html += `
                            <a href="#" class="list-group-item list-group-item-action backup-item ${backup.id === currentBackupId ? 'active' : ''}"
                               onclick="selectBackup(${backup.id}); return false;"
                               style="border-left: 2px solid #dee2e6; margin-left: 8px;">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span><i class="bi bi-archive me-1"></i> ${escapeHtml(backup.backup_name)}</span>
                                    <span class="badge bg-secondary">${configCount}</span>
                                </div>
                                <small class="text-muted">
                                    <i class="bi bi-clock"></i> ${created}
                                </small>
                            </a>
                        `;
                    }

                    html += `
                            </div>
                        </div>
                    `;
                }
                backupsList.innerHTML = html;

                // Auto-expand the node containing the currently selected backup
                if (currentBackupId) {
                    const activeItem = backupsList.querySelector('.backup-item.active');
                    if (activeItem) {
                        const parentNode = activeItem.closest('.backup-node-children');
                        if (parentNode) {
                            parentNode.style.display = 'block';
                            const chevron = document.getElementById(parentNode.id + '-chevron');
                            if (chevron) {
                                chevron.classList.remove('bi-chevron-right');
                                chevron.classList.add('bi-chevron-down');
                            }
                        }
                    }
                }
            } else {
                backupsList.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-inbox" style="font-size: 2rem;"></i>
                        <p class="mt-2 mb-0">No backups found</p>
                    </div>
                `;
            }
        } catch (error) {
            backupsList.innerHTML = `<div class="alert alert-danger m-2">Error: ${error.message}</div>`;
        }
    }

    function toggleBackupNode(nodeId) {
        const childrenDiv = document.getElementById(nodeId);
        const chevron = document.getElementById(nodeId + '-chevron');

        if (childrenDiv.style.display === 'none') {
            childrenDiv.style.display = 'block';
            chevron.classList.remove('bi-chevron-right');
            chevron.classList.add('bi-chevron-down');
        } else {
            childrenDiv.style.display = 'none';
            chevron.classList.remove('bi-chevron-down');
            chevron.classList.add('bi-chevron-right');
        }
    }

    function toggleAllBackupNodes(expand) {
        const nodeGroups = document.querySelectorAll('.backup-node-children');
        nodeGroups.forEach(group => {
            group.style.display = expand ? 'block' : 'none';
            const chevron = document.getElementById(group.id + '-chevron');
            if (chevron) {
                chevron.classList.remove(expand ? 'bi-chevron-right' : 'bi-chevron-down');
                chevron.classList.add(expand ? 'bi-chevron-down' : 'bi-chevron-right');
            }
        });
    }

    async function selectBackup(backupId) {
        currentBackupId = backupId;

        // Update list selection
        document.querySelectorAll('#backupsList .list-group-item').forEach(item => {
            item.classList.remove('active');
        });

        try {
            const response = await fetch(`/api/admin/backups/${backupId}`);
            const backup = await response.json();

            if (backup.error) {
                showAlert('danger', backup.error);
                return;
            }

            currentBackupData = backup;

            // Show viewer section
            document.getElementById('noBackupSelected').style.display = 'none';
            document.getElementById('backupViewerSection').style.display = 'block';

            // Populate metadata
            const nodeName = backup.node_long_name || backup.node_short_name || backup.node_hex_id || `!${backup.node_id.toString(16).padStart(8, '0')}`;
            document.getElementById('backupName').textContent = backup.backup_name;
            document.getElementById('backupNode').innerHTML = `<code>${escapeHtml(nodeName)}</code>`;
            document.getElementById('backupCreated').textContent = formatAdminDateTime(new Date(backup.created_at * 1000));
            document.getElementById('backupDescription').textContent = backup.description || 'No description';

            const data = backup.backup_data || {};

            // Core configs
            const coreConfigs = data.core_configs || {};
            document.getElementById('coreConfigsCount').textContent = Object.keys(coreConfigs).length;
            let coreHtml = '';
            for (const [key, value] of Object.entries(coreConfigs)) {
                coreHtml += `
                    <div class="mb-2">
                        <strong class="text-primary">${key.toUpperCase()}</strong>
                        <pre class="bg-light p-2 rounded small mb-0" style="max-height: 150px; overflow-y: auto;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>
                    </div>
                `;
            }
            document.getElementById('coreConfigsContent').innerHTML = coreHtml || '<p class="text-muted">No core configs in backup</p>';

            // Module configs
            const moduleConfigs = data.module_configs || {};
            document.getElementById('moduleConfigsCount').textContent = Object.keys(moduleConfigs).length;
            let moduleHtml = '';
            for (const [key, value] of Object.entries(moduleConfigs)) {
                moduleHtml += `
                    <div class="mb-2">
                        <strong class="text-info">${key.toUpperCase()}</strong>
                        <pre class="bg-light p-2 rounded small mb-0" style="max-height: 150px; overflow-y: auto;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>
                    </div>
                `;
            }
            document.getElementById('moduleConfigsContent').innerHTML = moduleHtml || '<p class="text-muted">No module configs in backup</p>';

            // Channels
            const channels = data.channels || {};
            document.getElementById('channelsCount').textContent = Object.keys(channels).length;
            let channelHtml = '';
            for (const [idx, value] of Object.entries(channels)) {
                const chName = value.settings?.name || `Channel ${idx}`;
                channelHtml += `
                    <div class="mb-2">
                        <strong class="text-success">Channel ${idx}: ${escapeHtml(chName)}</strong>
                        <pre class="bg-light p-2 rounded small mb-0" style="max-height: 150px; overflow-y: auto;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>
                    </div>
                `;
            }
            document.getElementById('channelsContent').innerHTML = channelHtml || '<p class="text-muted">No channels in backup</p>';

            // Enable restore button when target is selected
            const restoreSelect = document.getElementById('restoreTargetNode');
            restoreSelect.onchange = function() {
                document.getElementById('restoreBackupBtn').disabled = !this.value;
            };

            // Reload the backups list to update selection
            loadBackups();

        } catch (error) {
            showAlert('danger', `Error loading backup: ${error.message}`);
        }
    }

    function showCreateBackupModal() {
        // Reset form
        document.getElementById('backupSourceNode').value = '';
        document.getElementById('backupNameInput').value = '';
        document.getElementById('backupDescriptionInput').value = '';
        document.getElementById('backupProgressSection').style.display = 'none';
        const startBtn = document.getElementById('startBackupJobBtn');
        if (startBtn) {
            startBtn.disabled = false;
            startBtn.innerHTML = '<i class="bi bi-cloud-download"></i> Create Backup';
        }

        // Auto-generate backup name when node is selected
        document.getElementById('backupSourceNode').onchange = function() {
            const option = this.options[this.selectedIndex];
            if (option.value) {
                const nodeName = option.dataset.name || 'Node';
                const date = new Date().toISOString().split('T')[0];
                document.getElementById('backupNameInput').value = `${nodeName} - Backup ${date}`;
            }
        };

        const modal = new bootstrap.Modal(document.getElementById('createBackupModal'));
        modal.show();
    }

    let backupEventSource = null;

    // Clean up SSE on modal close (for any leftover connections)
    document.getElementById('createBackupModal')?.addEventListener('hidden.bs.modal', function() {
        if (backupEventSource) {
            backupEventSource.close();
            backupEventSource = null;
        }
    });

    async function deleteBackup() {
        if (!currentBackupId) return;

        const backup = currentBackupData;
        const confirmText = `Delete backup "${backup?.backup_name || 'this backup'}"? This action cannot be undone.`;

        if (!confirm(confirmText)) return;

        try {
            const response = await fetch(`/api/admin/backups/${currentBackupId}`, {
                method: 'DELETE'
            });

            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Backup deleted');
                currentBackupId = null;
                currentBackupData = null;
                document.getElementById('backupViewerSection').style.display = 'none';
                document.getElementById('noBackupSelected').style.display = 'block';
                loadBackups();
            } else {
                showAlert('danger', data.error || 'Failed to delete backup');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    function downloadBackup() {
        if (!currentBackupData) return;

        const dataStr = JSON.stringify(currentBackupData.backup_data, null, 2);
        const blob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${currentBackupData.backup_name.replace(/[^a-zA-Z0-9-_]/g, '_')}_backup.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async function restoreBackup() {
        const targetNodeId = document.getElementById('restoreTargetNode').value;
        if (!targetNodeId || !currentBackupData) return;

        // Populate the restore modal with backup details
        const backup = currentBackupData;
        const backupData = backup.backup_data || {};

        document.getElementById('restoreBackupName').textContent = backup.backup_name || 'Unknown';
        document.getElementById('restoreOriginalNode').textContent =
            backup.node_long_name || backup.node_short_name || backup.node_hex_id || 'Unknown';
        document.getElementById('restoreBackupCreated').textContent =
            backup.created_at ? formatAdminDateTime(new Date(backup.created_at * 1000)) : 'Unknown';

        // Get items from backup
        const coreConfigs = Object.keys(backupData.core_configs || {});
        const moduleConfigs = Object.keys(backupData.module_configs || {});
        const channels = Object.keys(backupData.channels || {});

        // Update counts
        document.getElementById('restoreCoreCount').textContent = coreConfigs.length;
        document.getElementById('restoreModuleCount').textContent = moduleConfigs.length;
        document.getElementById('restoreChannelCount').textContent = channels.length;

        // Populate checkboxes for selective restore
        populateRestoreCheckboxes('core', coreConfigs, backupData.core_configs || {});
        populateRestoreCheckboxes('module', moduleConfigs, backupData.module_configs || {});
        populateRestoreChannelCheckboxes(channels, backupData.channels || {});

        // Select all items by default
        selectAllRestoreItems(true);
        updateRestoreSelectedCount();

        // Reset modal state
        document.getElementById('restoreConfigSection').style.display = 'block';
        document.getElementById('restoreProgressSection').style.display = 'none';
        document.getElementById('restoreCompleteSection').style.display = 'none';
        document.getElementById('startRestoreJobBtn').style.display = 'inline-block';
        document.getElementById('restoreDoneBtn').style.display = 'none';
        document.getElementById('restoreCancelBtn').style.display = 'inline-block';
        document.getElementById('restoreModalClose').disabled = false;

        // Store target node for startRestoreJob
        document.getElementById('startRestoreJobBtn').dataset.targetNodeId = targetNodeId;
        document.getElementById('startRestoreJobBtn').dataset.backupId = currentBackupId;

        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('restoreBackupModal'));
        modal.show();
    }

    // Friendly display names for config types
    const configDisplayNames = {
        // Core configs
        device: 'Device Settings',
        position: 'Position Settings',
        power: 'Power Settings',
        network: 'Network Settings',
        display: 'Display Settings',
        lora: 'LoRa Radio Settings',
        bluetooth: 'Bluetooth Settings',
        security: 'Security Settings',
        // Module configs
        mqtt: 'MQTT Module',
        serial: 'Serial Module',
        extnotif: 'External Notifications',
        storeforward: 'Store & Forward',
        rangetest: 'Range Test',
        telemetry: 'Telemetry Module',
        cannedmsg: 'Canned Messages',
        audio: 'Audio Module',
        remotehardware: 'Remote Hardware',
        neighborinfo: 'Neighbor Info',
        ambientlighting: 'Ambient Lighting',
        detectionsensor: 'Detection Sensor',
        paxcounter: 'PAX Counter'
    };

    function populateRestoreCheckboxes(category, items, configData) {
        const container = document.getElementById(`restore${category.charAt(0).toUpperCase() + category.slice(1)}ConfigsContainer`);
        if (!container) return;

        container.innerHTML = '';

        items.forEach(item => {
            const displayName = configDisplayNames[item.toLowerCase()] || item;
            const checkboxId = `restore_${category}_${item}`;

            const div = document.createElement('div');
            div.className = 'form-check mb-1';
            div.innerHTML = `
                <input class="form-check-input restore-item-checkbox" type="checkbox"
                       id="${checkboxId}"
                       data-category="${category}"
                       data-item="${item}"
                       onchange="updateRestoreCategoryCheckbox('${category}'); updateRestoreSelectedCount()">
                <label class="form-check-label small" for="${checkboxId}">
                    ${displayName}
                </label>
            `;
            container.appendChild(div);
        });
    }

    function populateRestoreChannelCheckboxes(channelKeys, channelsData) {
        const container = document.getElementById('restoreChannelsContainer');
        if (!container) return;

        container.innerHTML = '';

        // Sort channel keys numerically
        const sortedKeys = channelKeys.sort((a, b) => parseInt(a) - parseInt(b));

        sortedKeys.forEach(channelIdx => {
            const channelData = channelsData[channelIdx] || {};
            const channelName = channelData.settings?.name || `Channel ${channelIdx}`;
            const isPrimary = parseInt(channelIdx) === 0;
            const checkboxId = `restore_channel_${channelIdx}`;

            const div = document.createElement('div');
            div.className = 'form-check mb-1';
            div.innerHTML = `
                <input class="form-check-input restore-item-checkbox" type="checkbox"
                       id="${checkboxId}"
                       data-category="channel"
                       data-item="${channelIdx}"
                       onchange="updateRestoreCategoryCheckbox('channel'); updateRestoreSelectedCount()">
                <label class="form-check-label small" for="${checkboxId}">
                    ${isPrimary ? '<span class="badge bg-warning text-dark me-1">Primary</span>' : ''}
                    Channel ${channelIdx}${channelName ? `: ${channelName}` : ''}
                </label>
            `;
            container.appendChild(div);
        });
    }

    function toggleRestoreCategory(category, checked) {
        const checkboxes = document.querySelectorAll(`.restore-item-checkbox[data-category="${category}"]`);
        checkboxes.forEach(cb => cb.checked = checked);
        updateRestoreSelectedCount();
    }

    function updateRestoreCategoryCheckbox(category) {
        const categoryCheckbox = document.getElementById(`restoreSelectAll${category.charAt(0).toUpperCase() + category.slice(1)}${category === 'channel' ? 's' : 's'}`);
        const checkboxes = document.querySelectorAll(`.restore-item-checkbox[data-category="${category}"]`);

        if (!categoryCheckbox || checkboxes.length === 0) return;

        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        const someChecked = Array.from(checkboxes).some(cb => cb.checked);

        categoryCheckbox.checked = allChecked;
        categoryCheckbox.indeterminate = someChecked && !allChecked;
    }

    function selectAllRestoreItems(checked) {
        // Select/deselect all category checkboxes
        ['restoreSelectAllCore', 'restoreSelectAllModules', 'restoreSelectAllChannels'].forEach(id => {
            const cb = document.getElementById(id);
            if (cb) {
                cb.checked = checked;
                cb.indeterminate = false;
            }
        });

        // Select/deselect all individual checkboxes
        document.querySelectorAll('.restore-item-checkbox').forEach(cb => {
            cb.checked = checked;
        });

        updateRestoreSelectedCount();
    }

    function updateRestoreSelectedCount() {
        const count = document.querySelectorAll('.restore-item-checkbox:checked').length;
        const countEl = document.getElementById('restoreSelectedCount');
        if (countEl) countEl.textContent = count;
    }

    function getSelectedRestoreItems() {
        const selected = {
            coreConfigs: [],
            moduleConfigs: [],
            channels: []
        };

        document.querySelectorAll('.restore-item-checkbox:checked').forEach(cb => {
            const category = cb.dataset.category;
            const item = cb.dataset.item;

            if (category === 'core') {
                selected.coreConfigs.push(item);
            } else if (category === 'module') {
                selected.moduleConfigs.push(item);
            } else if (category === 'channel') {
                selected.channels.push(item);
            }
        });

        return selected;
    }

    // Load backups when tab is shown
    document.getElementById('backups-tab')?.addEventListener('shown.bs.tab', function() {
        loadBackups();
    });

    // ============================================================================
    // Background Jobs Management
    // ============================================================================

    // Initialize job manager when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initJobManager();
    });

    function initJobManager() {
        jobManager = new JobManager({
            pollInterval: 2000,
            onJobUpdate: handleJobUpdate,
            onJobComplete: handleJobComplete,
            onQueueUpdate: handleQueueUpdate
        });

        // Start polling for queue status
        jobManager.startQueuePolling(5000);

        // Resume polling for any active jobs
        jobManager.resumePolling();
    }

    function handleJobUpdate(job) {
        // Update job in the list if visible
        updateJobInList(job);

        // Update tab badge
        updateJobsTabBadge();
    }

    function handleJobComplete(job) {
        // Show notification
        const isSuccess = job.status === 'completed';
        const message = isSuccess
            ? `${job.job_name} completed successfully`
            : `${job.job_name} failed: ${job.error_message || 'Unknown error'}`;

        showAlert(isSuccess ? 'success' : 'danger', message);

        // Refresh backups list if a backup job completed
        if (job.job_type === 'backup' && isSuccess) {
            loadBackups();
        }

        // Refresh jobs list
        refreshJobsList();
    }

    function handleQueueUpdate(status) {
        // Update counts
        const runningEl = document.getElementById('runningJobsCount');
        const queuedEl = document.getElementById('queuedJobsCount');
        const tabBadge = document.getElementById('jobsTabBadge');

        if (runningEl) runningEl.textContent = status.running_jobs;
        if (queuedEl) queuedEl.textContent = status.queued_jobs;

        const total = status.running_jobs + status.queued_jobs;
        if (tabBadge) {
            tabBadge.textContent = total;
            tabBadge.className = `badge ${total > 0 ? 'bg-primary' : 'bg-secondary'}`;
        }
    }

    async function refreshJobsList() {
        const container = document.getElementById('jobsListContainer');
        if (!container) return;

        try {
            const response = await fetch('/api/jobs?limit=50');
            const data = await response.json();

            if (data.jobs && data.jobs.length > 0) {
                container.innerHTML = renderJobsList(data.jobs);
            } else {
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-inbox fs-1 d-block mb-2"></i>
                        No jobs found
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Error loading jobs: ${escapeHtml(error.message)}
                </div>
            `;
        }
    }

    function renderJobsList(jobs) {
        return `
            <div class="table-responsive">
                <table class="table table-sm table-hover">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Job</th>
                            <th>Target Node</th>
                            <th>Progress</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${jobs.map(job => renderJobRow(job)).join('')}
                    </tbody>
                </table>
            </div>
        `;
    }

    function renderJobRow(job) {
        const statusBadge = getJobStatusBadge(job.status, job.cancel_requested, job.pause_requested);
        const created = job.created_at ? formatTimestamp(job.created_at) : 'Unknown';
        const progress = job.progress || 0;
        const jobTypeInfo = getJobTypeDisplayInfo(job.job_type);

        // Format target node display
        let targetNodeDisplay = '<span class="text-muted">-</span>';
        if (job.target_node_id) {
            const nodeHex = job.target_node_hex || `!${(job.target_node_id >>> 0).toString(16).padStart(8, '0')}`;
            if (job.target_node_name) {
                targetNodeDisplay = `
                    <code class="small">${nodeHex}</code>
                    <br>
                    <small class="text-muted">${escapeHtml(job.target_node_name)}</small>
                `;
            } else {
                targetNodeDisplay = `<code class="small">${nodeHex}</code>`;
            }
        }

        let progressBar = '';
        if (job.status === 'running') {
            // Check if the progress message indicates an error or timeout
            const progressMsg = job.progress_message || '';
            const isError = progressMsg.startsWith('✗') || progressMsg.includes('failed');
            const isTimeout = progressMsg.startsWith('⏱') || progressMsg.includes('timeout');
            let msgClass = 'text-muted';
            if (isError) msgClass = 'text-danger';
            else if (isTimeout) msgClass = 'text-warning';
            else if (progressMsg.startsWith('✓')) msgClass = 'text-success';

            progressBar = `
                <div class="progress" style="height: 6px; min-width: 100px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated"
                         style="width: ${progress}%"></div>
                </div>
                <small class="${msgClass}">${escapeHtml(progressMsg)}</small>
            `;
        } else if (job.status === 'queued' && job.queue_position) {
            progressBar = `<small class="text-muted">Position: ${job.queue_position}</small>`;
        } else if (job.status === 'paused') {
            progressBar = '<small class="text-warning"><i class="bi bi-pause-fill"></i> Paused</small>';
        } else if (job.status === 'completed') {
            progressBar = '<small class="text-success">Done</small>';
        } else if (job.status === 'failed') {
            progressBar = `<small class="text-danger">${escapeHtml(job.error_message || 'Failed')}</small>`;
        } else if (job.status === 'cancelled') {
            progressBar = '<small class="text-secondary"><i class="bi bi-slash-circle"></i> Cancelled</small>';
        }

        let actions = '';
        // Details button - always show for all jobs
        actions += `
            <button class="btn btn-sm btn-outline-secondary me-1" onclick="viewJobDetails(${job.id})" title="Details">
                <i class="bi bi-eye"></i>
            </button>
        `;

        if (job.status === 'queued') {
            actions += `
                <button class="btn btn-sm btn-outline-warning me-1" onclick="pauseJob(${job.id})" title="Pause">
                    <i class="bi bi-pause-fill"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="cancelJob(${job.id})" title="Cancel">
                    <i class="bi bi-x"></i>
                </button>
            `;
        } else if (job.status === 'paused') {
            actions += `
                <button class="btn btn-sm btn-outline-success me-1" onclick="resumeJob(${job.id})" title="Resume">
                    <i class="bi bi-play-fill"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="cancelJob(${job.id})" title="Cancel">
                    <i class="bi bi-x"></i>
                </button>
            `;
        } else if (job.status === 'running') {
            // Running jobs can be paused or cancelled (request at next checkpoint)
            // Disable buttons if already requested
            const pauseDisabled = job.pause_requested || job.cancel_requested;
            const cancelDisabled = job.cancel_requested;

            if (job.pause_requested) {
                actions += `
                    <button class="btn btn-sm btn-warning me-1" disabled title="Pause pending...">
                        <i class="bi bi-hourglass-split"></i>
                    </button>
                `;
            } else if (job.cancel_requested) {
                actions += `
                    <button class="btn btn-sm btn-secondary me-1" disabled title="Cancelling...">
                        <i class="bi bi-pause-fill"></i>
                    </button>
                `;
            } else {
                actions += `
                    <button class="btn btn-sm btn-outline-warning me-1" onclick="pauseJob(${job.id})" title="Pause (will pause at next checkpoint)">
                        <i class="bi bi-pause-fill"></i>
                    </button>
                `;
            }

            if (job.cancel_requested) {
                actions += `
                    <button class="btn btn-sm btn-danger" disabled title="Cancel pending...">
                        <i class="bi bi-hourglass-split"></i>
                    </button>
                `;
            } else {
                actions += `
                    <button class="btn btn-sm btn-outline-danger" onclick="cancelJob(${job.id})" title="Cancel (will stop at next checkpoint)">
                        <i class="bi bi-stop-fill"></i>
                    </button>
                `;
            }
        }

        return `
            <tr id="job-row-${job.id}" class="job-row" style="cursor: pointer;" onclick="viewJobDetails(${job.id})">
                <td>${statusBadge}</td>
                <td>
                    <div class="d-flex align-items-center gap-2">
                        <i class="bi bi-${jobTypeInfo.icon} text-${jobTypeInfo.color}"></i>
                        <div>
                            <strong>${escapeHtml(job.job_name)}</strong>
                            <br>
                            <small class="text-muted">${jobTypeInfo.name}</small>
                        </div>
                    </div>
                </td>
                <td>${targetNodeDisplay}</td>
                <td>${progressBar}</td>
                <td><small>${created}</small></td>
                <td onclick="event.stopPropagation()">${actions}</td>
            </tr>
        `;
    }

    function updateJobInList(job) {
        const row = document.getElementById(`job-row-${job.id}`);
        if (row) {
            row.outerHTML = renderJobRow(job);
        }
    }

    function getJobStatusBadge(status, cancelRequested, pauseRequested) {
        // Show transitional states first
        if (status === 'running' && cancelRequested) {
            return '<span class="badge bg-danger"><i class="bi bi-hourglass-split spin"></i> Cancelling...</span>';
        }
        if (status === 'running' && pauseRequested) {
            return '<span class="badge bg-warning text-dark"><i class="bi bi-hourglass-split spin"></i> Pausing...</span>';
        }

        const badges = {
            'queued': '<span class="badge bg-secondary"><i class="bi bi-hourglass"></i> Queued</span>',
            'running': '<span class="badge bg-primary"><i class="bi bi-arrow-repeat spin"></i> Running</span>',
            'paused': '<span class="badge bg-warning text-dark"><i class="bi bi-pause-fill"></i> Paused</span>',
            'completed': '<span class="badge bg-success"><i class="bi bi-check-circle"></i> Completed</span>',
            'failed': '<span class="badge bg-danger"><i class="bi bi-x-circle"></i> Failed</span>',
            'cancelled': '<span class="badge bg-secondary"><i class="bi bi-slash-circle"></i> Cancelled</span>'
        };
        return badges[status] || `<span class="badge bg-secondary">${escapeHtml(status)}</span>`;
    }

    // Get display info for job types
    function getJobTypeDisplayInfo(jobType) {
        const types = {
            'backup': {
                name: 'Backup Node',
                icon: 'download',
                color: 'primary',
                description: 'Creates a backup of node configuration and settings'
            },
            'restore': {
                name: 'Restore Node',
                icon: 'upload',
                color: 'warning',
                description: 'Restores node configuration from a backup'
            },
            'bulk_command': {
                name: 'Bulk Command',
                icon: 'collection',
                color: 'info',
                description: 'Sends commands to multiple nodes'
            },
            'config_deploy': {
                name: 'Deploy Config',
                icon: 'gear',
                color: 'success',
                description: 'Deploys configuration changes to a node'
            },
            'compliance_fix': {
                name: 'Compliance Fix',
                icon: 'shield-check',
                color: 'purple',
                description: 'Applies template settings to bring nodes into compliance'
            }
        };
        return types[jobType] || {
            name: jobType || 'Unknown',
            icon: 'question-circle',
            color: 'secondary',
            description: 'Background job'
        };
    }

    // Format duration in human-readable form
    function formatDuration(seconds) {
        if (!seconds && seconds !== 0) return '-';
        seconds = Math.round(seconds);
        if (seconds < 60) {
            return `${seconds}s`;
        } else if (seconds < 3600) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }
    }

    // Format job data summary based on job type
    function formatJobDataSummary(jobType, jobData) {
        if (!jobData) return '';

        let items = [];

        switch (jobType) {
            case 'config_deploy':
                if (jobData.config_type) {
                    items.push(`<strong>Config Type:</strong> ${escapeHtml(jobData.config_type)}`);
                }
                if (jobData.config_changes) {
                    const changes = typeof jobData.config_changes === 'object'
                        ? Object.entries(jobData.config_changes).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join(', ')
                        : jobData.config_changes;
                    items.push(`<strong>Changes:</strong> <code class="small">${escapeHtml(changes.substring(0, 200))}${changes.length > 200 ? '...' : ''}</code>`);
                }
                break;

            case 'backup':
                if (jobData.backup_type) {
                    items.push(`<strong>Backup Type:</strong> ${escapeHtml(jobData.backup_type)}`);
                }
                if (jobData.include_channels !== undefined) {
                    items.push(`<strong>Include Channels:</strong> ${jobData.include_channels ? 'Yes' : 'No'}`);
                }
                break;

            case 'restore':
                if (jobData.backup_id) {
                    items.push(`<strong>Backup ID:</strong> ${escapeHtml(jobData.backup_id)}`);
                }
                if (jobData.restore_type) {
                    items.push(`<strong>Restore Type:</strong> ${escapeHtml(jobData.restore_type)}`);
                }
                break;

            case 'bulk_command':
                if (jobData.command_type) {
                    items.push(`<strong>Command:</strong> ${escapeHtml(jobData.command_type)}`);
                }
                if (jobData.node_count) {
                    items.push(`<strong>Target Nodes:</strong> ${jobData.node_count} nodes`);
                }
                if (Array.isArray(jobData.node_ids)) {
                    items.push(`<strong>Target Nodes:</strong> ${jobData.node_ids.length} nodes`);
                }
                break;

            case 'compliance_fix':
                if (jobData.template_type) {
                    items.push(`<strong>Template:</strong> ${escapeHtml(jobData.template_type)}`);
                }
                if (jobData.node_count) {
                    items.push(`<strong>Nodes to Fix:</strong> ${jobData.node_count}`);
                }
                break;
        }

        // Fallback: show raw data if no specific formatting
        if (items.length === 0 && Object.keys(jobData).length > 0) {
            const summary = JSON.stringify(jobData, null, 2);
            if (summary.length > 500) {
                return `<pre class="mb-0 small" style="max-height: 150px; overflow-y: auto;"><code>${escapeHtml(summary.substring(0, 500))}...</code></pre>`;
            }
            return `<pre class="mb-0 small" style="max-height: 150px; overflow-y: auto;"><code>${escapeHtml(summary)}</code></pre>`;
        }

        return items.map(item => `<div class="mb-1">${item}</div>`).join('');
    }

    async function cancelJob(jobId) {
        if (!confirm('Cancel this job?')) return;

        try {
            const result = await jobManager.cancelJob(jobId);
            if (result.success) {
                showAlert('info', 'Job cancelled');
                refreshJobsList();
            } else {
                showAlert('warning', result.error || 'Could not cancel job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function pauseJob(jobId) {
        try {
            const result = await jobManager.pauseJob(jobId);
            if (result.success) {
                showAlert('info', 'Job paused');
                refreshJobsList();
            } else {
                showAlert('warning', result.error || 'Could not pause job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function resumeJob(jobId) {
        try {
            const result = await jobManager.resumeJob(jobId);
            if (result.success) {
                showAlert('success', 'Job resumed');
                refreshJobsList();
            } else {
                showAlert('warning', result.error || 'Could not resume job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Format compliance fix job result for better display
    function formatComplianceFixResult(data) {
        const fixedCount = data.fixed_count || 0;
        const failedCount = data.failed_count || 0;
        const totalNodes = data.total_nodes || 0;
        const nowCompliant = data.now_compliant || 0;
        const stillNonCompliant = data.still_non_compliant || 0;
        const verificationResults = data.verification_results || [];
        const templateType = data.template_type || '';
        const rebootedNodes = data.rebooted_nodes || [];

        // Summary section
        let html = `
            <div class="mb-4">
                <h6 class="text-muted mb-2">Fix Summary</h6>
                <div class="d-flex gap-4 mb-3">
                    <div class="text-center">
                        <div class="h4 mb-0 text-primary">${fixedCount}/${totalNodes}</div>
                        <small class="text-muted">Config Sent</small>
                    </div>
                    <div class="text-center">
                        <div class="h4 mb-0 text-success">${nowCompliant}</div>
                        <small class="text-muted">Now Compliant</small>
                    </div>
                    <div class="text-center">
                        <div class="h4 mb-0 ${stillNonCompliant > 0 ? 'text-warning' : 'text-muted'}">${stillNonCompliant}</div>
                        <small class="text-muted">Still Non-Compliant</small>
                    </div>
                    ${failedCount > 0 ? `
                    <div class="text-center">
                        <div class="h4 mb-0 text-danger">${failedCount}</div>
                        <small class="text-muted">Send Failed</small>
                    </div>
                    ` : ''}
                    ${rebootedNodes.length > 0 ? `
                    <div class="text-center">
                        <div class="h4 mb-0 text-info">${rebootedNodes.length}</div>
                        <small class="text-muted">Rebooted</small>
                    </div>
                    ` : ''}
                </div>
        `;

        // Show rebooted nodes
        if (rebootedNodes.length > 0) {
            html += `
                <div class="alert alert-info py-2 mb-3">
                    <i class="bi bi-arrow-clockwise"></i>
                    <strong>Reboot sent to:</strong> ${rebootedNodes.map(n => escapeHtml(n)).join(', ')}
                    <br><small class="text-muted">Configuration changes will take effect after reboot completes (~10-15 seconds).</small>
                </div>
            `;
        }

        // Verification details for non-compliant nodes
        const nonCompliantVerifications = verificationResults.filter(v => !v.is_compliant && v.differences);
        if (nonCompliantVerifications.length > 0) {
            // Show reboot suggestion for certain config types
            const configTypesNeedingReboot = ['bluetooth', 'network', 'lora'];
            const needsRebootHint = configTypesNeedingReboot.includes(templateType.toLowerCase()) && rebootedNodes.length === 0;

            html += `
                <h6 class="text-muted mb-2"><i class="bi bi-exclamation-triangle text-warning"></i> Fields Not Applied</h6>
            `;

            if (needsRebootHint) {
                html += `
                    <div class="alert alert-warning py-2 mb-2">
                        <i class="bi bi-lightbulb"></i>
                        <strong>Tip:</strong> ${templateType.charAt(0).toUpperCase() + templateType.slice(1)} configuration changes typically require a <strong>node reboot</strong> to take effect.
                        Try running the fix again with <em>"Reboot nodes after fix"</em> enabled.
                    </div>
                `;
            }

            html += `
                <p class="small text-muted mb-2">
                    The following settings were sent but did not take effect. This can happen if:
                </p>
                <ul class="small text-muted mb-3">
                    <li>The node requires a <strong>reboot</strong> for settings to apply</li>
                    <li><strong>fixed_pin</strong>: Cannot be changed remotely for security reasons - must be set via USB/Serial</li>
                    <li>The field requires physical button press to confirm</li>
                    <li>The node's firmware doesn't support this setting</li>
                    <li>The setting is protected or read-only on the node</li>
                </ul>
                <div style="max-height: 300px; overflow-y: auto;">
            `;

            for (const v of nonCompliantVerifications) {
                const nodeName = v.node_hex;
                html += `
                    <div class="card mb-2 border-warning">
                        <div class="card-header py-2 px-3 bg-warning bg-opacity-10">
                            <strong>${escapeHtml(nodeName)}</strong>
                            <span class="badge bg-warning text-dark ms-2">${v.differences.length} field(s) unchanged</span>
                        </div>
                        <div class="card-body py-2 px-3">
                            <table class="table table-sm table-bordered mb-0" style="font-size: 0.8rem;">
                                <thead class="table-light">
                                    <tr>
                                        <th style="width: 35%;">Field</th>
                                        <th style="width: 32%;" class="text-success">Expected</th>
                                        <th style="width: 33%;" class="text-danger">Actual (on node)</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;

                for (const diff of v.differences) {
                    const expected = diff.expected !== null && diff.expected !== undefined
                        ? (typeof diff.expected === 'object' ? JSON.stringify(diff.expected) : String(diff.expected))
                        : '<em class="text-muted">not set</em>';
                    const actual = diff.actual !== null && diff.actual !== undefined
                        ? (typeof diff.actual === 'object' ? JSON.stringify(diff.actual) : String(diff.actual))
                        : '<em class="text-muted">not set</em>';

                    html += `
                        <tr>
                            <td><code>${escapeHtml(diff.field)}</code></td>
                            <td class="bg-success bg-opacity-10"><code>${diff.expected !== null ? escapeHtml(expected) : expected}</code></td>
                            <td class="bg-danger bg-opacity-10"><code>${diff.actual !== null ? escapeHtml(actual) : actual}</code></td>
                        </tr>
                    `;
                }

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }

            html += '</div>';
        }

        // Show successfully fixed nodes
        const compliantNodes = verificationResults.filter(v => v.is_compliant);
        if (compliantNodes.length > 0) {
            html += `
                <h6 class="text-muted mb-2 mt-3"><i class="bi bi-check-circle text-success"></i> Successfully Fixed</h6>
                <div class="d-flex flex-wrap gap-2">
            `;
            for (const v of compliantNodes) {
                html += `<span class="badge bg-success">${escapeHtml(v.node_hex)}</span>`;
            }
            html += '</div>';
        }

        html += '</div>';
        return html;
    }

    let currentJobDetailsId = null;
    let jobDetailsPollingInterval = null;

    async function viewJobDetails(jobId) {
        currentJobDetailsId = jobId;
        const modal = new bootstrap.Modal(document.getElementById('jobDetailsModal'));
        modal.show();

        // Start polling for updates if job is active
        await refreshJobDetails(jobId);
    }

    async function refreshJobDetails(jobId) {
        try {
            const job = await jobManager.getJob(jobId);
            renderJobDetailsModal(job);

            // Set up polling for active jobs - faster polling for real-time updates
            if (job.status === 'running' || job.status === 'queued') {
                if (!jobDetailsPollingInterval) {
                    // Poll every 800ms for responsive progress updates
                    jobDetailsPollingInterval = setInterval(async () => {
                        if (currentJobDetailsId) {
                            try {
                                const updatedJob = await jobManager.getJob(currentJobDetailsId);
                                renderJobDetailsModal(updatedJob);
                                if (updatedJob.status !== 'running' && updatedJob.status !== 'queued') {
                                    clearJobDetailsPolling();
                                }
                            } catch (e) {
                                clearJobDetailsPolling();
                            }
                        }
                    }, 800);
                }
            }
        } catch (error) {
            document.getElementById('jobDetailsBody').innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Error loading job details: ${escapeHtml(error.message)}
                </div>
            `;
        }
    }

    function clearJobDetailsPolling() {
        if (jobDetailsPollingInterval) {
            clearInterval(jobDetailsPollingInterval);
            jobDetailsPollingInterval = null;
        }
    }

    // Stop polling when modal is closed
    document.getElementById('jobDetailsModal')?.addEventListener('hidden.bs.modal', function() {
        clearJobDetailsPolling();
        currentJobDetailsId = null;
    });

    function renderJobDetailsModal(job) {
        const titleEl = document.getElementById('jobDetailsTitle');
        const bodyEl = document.getElementById('jobDetailsBody');
        const cancelBtn = document.getElementById('jobDetailsCancelBtn');
        const pauseBtn = document.getElementById('jobDetailsPauseBtn');
        const resumeBtn = document.getElementById('jobDetailsResumeBtn');
        const forceCancelBtn = document.getElementById('jobDetailsForceCancelBtn');

        titleEl.textContent = job.job_name || 'Job Details';

        // Show/hide action buttons based on status
        cancelBtn.classList.add('d-none');
        pauseBtn.classList.add('d-none');
        resumeBtn.classList.add('d-none');
        forceCancelBtn.classList.add('d-none');

        // Reset button states
        cancelBtn.disabled = false;
        pauseBtn.disabled = false;
        cancelBtn.innerHTML = '<i class="bi bi-x-circle me-1"></i> Cancel';
        pauseBtn.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pause';
        if (job.status === 'queued') {
            cancelBtn.classList.remove('d-none');
            pauseBtn.classList.remove('d-none');
        } else if (job.status === 'paused') {
            cancelBtn.classList.remove('d-none');
            resumeBtn.classList.remove('d-none');
        } else if (job.status === 'running') {
            // Running jobs can be paused or cancelled (request at next checkpoint)
            cancelBtn.classList.remove('d-none');
            cancelBtn.innerHTML = '<i class="bi bi-stop-fill me-1"></i> Stop Job';
            cancelBtn.title = 'Request cancellation - job will stop at next checkpoint';

            // Show pause button for running jobs
            pauseBtn.classList.remove('d-none');
            pauseBtn.title = 'Request pause - job will pause at next checkpoint';

            // Also show force cancel for running jobs (in case they're stuck/orphaned)
            forceCancelBtn.classList.remove('d-none');

            // Disable buttons if already requested
            if (job.cancel_requested) {
                cancelBtn.disabled = true;
                cancelBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i> Cancelling...';
                pauseBtn.disabled = true;
            } else if (job.pause_requested) {
                pauseBtn.disabled = true;
                pauseBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i> Pausing...';
            }

            // Check if this job might be stuck (not updated recently)
            if (job.updated_at) {
                const lastUpdate = new Date(job.updated_at * 1000);
                const now = new Date();
                const minutesSinceUpdate = (now - lastUpdate) / 1000 / 60;
                if (minutesSinceUpdate > 2) {
                    // Job hasn't been updated in 2+ minutes, highlight force cancel
                    forceCancelBtn.classList.add('animate__animated', 'animate__pulse');
                    forceCancelBtn.title = `Job may be stuck (last update ${Math.floor(minutesSinceUpdate)} min ago). Use force cancel to stop it.`;
                }
            }
        }

        const statusBadge = getJobStatusBadge(job.status, job.cancel_requested, job.pause_requested);
        const created = job.created_at ? formatTimestamp(job.created_at) : 'Unknown';
        const started = job.started_at ? formatTimestamp(job.started_at) : '-';
        const completed = job.completed_at ? formatTimestamp(job.completed_at) : '-';

        // Get friendly job type info
        const jobTypeInfo = getJobTypeDisplayInfo(job.job_type);

        // Format target node display
        let targetNodeDisplay = '-';
        if (job.target_node_id) {
            const nodeHex = job.target_node_hex || `!${(job.target_node_id >>> 0).toString(16).padStart(8, '0')}`;
            targetNodeDisplay = `<code>${nodeHex}</code>`;
            if (job.target_node_name) {
                targetNodeDisplay += ` <span class="text-muted">(${escapeHtml(job.target_node_name)})</span>`;
            }
        }

        // Calculate duration
        let durationDisplay = '-';
        if (job.duration_seconds) {
            durationDisplay = formatDuration(job.duration_seconds);
        } else if (job.elapsed_seconds) {
            durationDisplay = formatDuration(job.elapsed_seconds) + ' (running)';
        } else if (job.started_at && job.completed_at) {
            durationDisplay = formatDuration(job.completed_at - job.started_at);
        } else if (job.started_at) {
            const elapsed = Math.floor(Date.now() / 1000 - job.started_at);
            durationDisplay = formatDuration(elapsed) + ' (running)';
        }

        let progressSection = '';
        if (job.status === 'running') {
            const progress = job.progress || 0;
            // Check if the progress message indicates an error or timeout
            const progressMsg = job.progress_message || 'Processing...';
            const isError = progressMsg.startsWith('✗') || progressMsg.includes('failed');
            const isTimeout = progressMsg.startsWith('⏱') || progressMsg.includes('timeout');
            let msgClass = 'text-muted';
            if (isError) msgClass = 'text-danger fw-bold';
            else if (isTimeout) msgClass = 'text-warning fw-bold';
            else if (progressMsg.startsWith('✓')) msgClass = 'text-success';

            progressSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Progress</h6>
                    <div class="progress mb-2" style="height: 20px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated"
                             style="width: ${progress}%">
                            ${progress}%
                        </div>
                    </div>
                    <div class="${msgClass} small">${escapeHtml(progressMsg)}</div>
                </div>
            `;
        } else if (job.status === 'queued' && job.queue_position) {
            progressSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Queue Status</h6>
                    <div class="alert alert-info">
                        <i class="bi bi-hourglass me-2"></i>
                        Position in queue: <strong>${job.queue_position}</strong>
                    </div>
                </div>
            `;
        } else if (job.status === 'paused') {
            progressSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Status</h6>
                    <div class="alert alert-warning">
                        <i class="bi bi-pause-fill me-2"></i>
                        This job is paused. Click <strong>Resume</strong> to continue.
                    </div>
                </div>
            `;
        }

        let resultSection = '';
        if (job.status === 'completed' && job.result_data) {
            // Check for compliance_fix job type for custom rendering
            if (job.job_type === 'compliance_fix' && job.result_data.data) {
                resultSection = formatComplianceFixResult(job.result_data.data);
            } else {
                resultSection = `
                    <div class="mb-4">
                        <h6 class="text-muted mb-2">Result</h6>
                        <pre class="bg-light p-3 rounded" style="max-height: 200px; overflow-y: auto;"><code>${escapeHtml(JSON.stringify(job.result_data, null, 2))}</code></pre>
                    </div>
                `;
            }
        }

        let errorSection = '';
        if (job.status === 'failed' && job.error_message) {
            errorSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2"><i class="bi bi-exclamation-triangle text-danger me-1"></i> Error</h6>
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        ${escapeHtml(job.error_message)}
                    </div>
                </div>
            `;
        }

        // Job data section - show input parameters
        let jobDataSection = '';
        if (job.job_data && Object.keys(job.job_data).length > 0) {
            const jobDataSummary = formatJobDataSummary(job.job_type, job.job_data);
            if (jobDataSummary) {
                jobDataSection = `
                    <div class="mb-4">
                        <h6 class="text-muted mb-2"><i class="bi bi-info-circle me-1"></i> Job Parameters</h6>
                        <div class="bg-light p-3 rounded">
                            ${jobDataSummary}
                        </div>
                    </div>
                `;
            }
        }

        bodyEl.innerHTML = `
            <!-- Job Header with Icon -->
            <div class="d-flex align-items-center gap-3 mb-3 pb-3 border-bottom">
                <div class="rounded-circle bg-${jobTypeInfo.color} bg-opacity-10 p-3">
                    <i class="bi bi-${jobTypeInfo.icon} text-${jobTypeInfo.color} fs-4"></i>
                </div>
                <div>
                    <h5 class="mb-1">${jobTypeInfo.name}</h5>
                    <div class="text-muted small">${jobTypeInfo.description}</div>
                </div>
                <div class="ms-auto">${statusBadge}</div>
            </div>

            <div class="row mb-3">
                <div class="col-md-6">
                    <table class="table table-sm table-borderless mb-0">
                        <tr>
                            <td class="text-muted" style="width: 100px;">Target Node:</td>
                            <td>${targetNodeDisplay}</td>
                        </tr>
                        <tr>
                            <td class="text-muted">Job ID:</td>
                            <td><code class="small">${job.id}</code></td>
                        </tr>
                        <tr>
                            <td class="text-muted">Duration:</td>
                            <td>${durationDisplay}</td>
                        </tr>
                    </table>
                </div>
                <div class="col-md-6">
                    <table class="table table-sm table-borderless mb-0">
                        <tr>
                            <td class="text-muted" style="width: 100px;">Created:</td>
                            <td>${created}</td>
                        </tr>
                        <tr>
                            <td class="text-muted">Started:</td>
                            <td>${started}</td>
                        </tr>
                        <tr>
                            <td class="text-muted">Completed:</td>
                            <td>${completed}</td>
                        </tr>
                    </table>
                </div>
            </div>
            ${progressSection}
            ${jobDataSection}
            ${resultSection}
            ${errorSection}
        `;
    }

    async function cancelJobFromModal() {
        if (!currentJobDetailsId) return;
        if (!confirm('Cancel this job?')) return;

        try {
            const result = await jobManager.cancelJob(currentJobDetailsId);
            if (result.success) {
                showAlert('info', 'Job cancelled');
                refreshJobsList();
                bootstrap.Modal.getInstance(document.getElementById('jobDetailsModal')).hide();
            } else {
                showAlert('warning', result.error || 'Could not cancel job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function forceCancelJobFromModal() {
        if (!currentJobDetailsId) return;
        if (!confirm('Force cancel this job? This is useful for stuck/orphaned jobs that are not responding to normal cancellation.')) return;

        try {
            const result = await jobManager.forceCancelJob(currentJobDetailsId);
            if (result.success) {
                showAlert('info', 'Job force cancelled');
                refreshJobsList();
                bootstrap.Modal.getInstance(document.getElementById('jobDetailsModal')).hide();
            } else {
                showAlert('warning', result.error || 'Could not force cancel job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function pauseJobFromModal() {
        if (!currentJobDetailsId) return;

        try {
            const result = await jobManager.pauseJob(currentJobDetailsId);
            if (result.success) {
                showAlert('info', 'Job paused');
                refreshJobsList();
                refreshJobDetails(currentJobDetailsId);
            } else {
                showAlert('warning', result.error || 'Could not pause job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function resumeJobFromModal() {
        if (!currentJobDetailsId) return;

        try {
            const result = await jobManager.resumeJob(currentJobDetailsId);
            if (result.success) {
                showAlert('success', 'Job resumed');
                refreshJobsList();
                refreshJobDetails(currentJobDetailsId);
            } else {
                showAlert('warning', result.error || 'Could not resume job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    function updateJobsTabBadge() {
        if (jobManager) {
            jobManager.getServiceStatus().then(handleQueueUpdate);
        }
    }

    // Load jobs when tab is shown
    document.getElementById('jobs-tab')?.addEventListener('shown.bs.tab', function() {
        refreshJobsList();
    });

    // ============================================================================
    // Server Logs Functions
    // ============================================================================

    let serverLogsPollingInterval = null;
    let lastLogTimestamp = null;

    // Initialize server logs when tab is shown
    document.getElementById('server-logs-tab')?.addEventListener('shown.bs.tab', function() {
        refreshServerLogs();
        startServerLogsPolling();
    });

    // Stop polling when tab is hidden
    document.getElementById('server-logs-tab')?.addEventListener('hidden.bs.tab', function() {
        stopServerLogsPolling();
    });

    // Handle auto-refresh toggle
    document.getElementById('serverLogsAutoRefresh')?.addEventListener('change', function() {
        if (this.checked) {
            startServerLogsPolling();
        } else {
            stopServerLogsPolling();
        }
    });

    // Handle level filter change
    document.getElementById('serverLogsLevelFilter')?.addEventListener('change', function() {
        refreshServerLogs();
    });

    // Handle search with debounce
    let serverLogsSearchTimeout = null;
    document.getElementById('serverLogsSearch')?.addEventListener('input', function() {
        clearTimeout(serverLogsSearchTimeout);
        serverLogsSearchTimeout = setTimeout(refreshServerLogs, 300);
    });

    function startServerLogsPolling() {
        if (serverLogsPollingInterval) return;
        const autoRefresh = document.getElementById('serverLogsAutoRefresh');
        if (!autoRefresh?.checked) return;

        serverLogsPollingInterval = setInterval(refreshServerLogs, 2000);
    }

    function stopServerLogsPolling() {
        if (serverLogsPollingInterval) {
            clearInterval(serverLogsPollingInterval);
            serverLogsPollingInterval = null;
        }
    }

    async function refreshServerLogs() {
        const container = document.getElementById('serverLogsContainer');
        const level = document.getElementById('serverLogsLevelFilter')?.value || 'INFO';
        const search = document.getElementById('serverLogsSearch')?.value || '';

        try {
            const params = new URLSearchParams({
                limit: '200',
                level: level,
            });
            if (search) params.append('search', search);

            const response = await fetch(`/api/admin/logs?${params}`);
            const data = await response.json();

            if (data.error) {
                container.innerHTML = `<div class="text-danger p-3"><i class="bi bi-exclamation-triangle"></i> ${escapeHtml(data.error)}</div>`;
                return;
            }

            // Update stats
            if (data.stats) {
                document.getElementById('logStatTotal').textContent = data.stats.total_entries || 0;
                const counts = data.stats.level_counts || {};
                document.getElementById('logStatInfo').textContent = counts.INFO || 0;
                document.getElementById('logStatWarning').textContent = counts.WARNING || 0;
                document.getElementById('logStatError').textContent = (counts.ERROR || 0) + (counts.CRITICAL || 0);

                // Update error badge
                const errorBadge = document.getElementById('serverLogsErrorBadge');
                const errorCount = (counts.ERROR || 0) + (counts.CRITICAL || 0);
                if (errorCount > 0) {
                    errorBadge.textContent = errorCount;
                    errorBadge.classList.remove('d-none');
                } else {
                    errorBadge.classList.add('d-none');
                }
            }

            // Render logs (apply client-side filters)
            let filteredLogs = data.logs.filter(log => logMatchesFilters(log));

            if (filteredLogs.length === 0) {
                const hasFilters = serverLogFilters.length > 0;
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-inbox fs-1 d-block mb-2"></i>
                        ${hasFilters ? 'No logs match the current filters' : 'No log entries found'}
                        ${hasFilters ? '<br><button class="btn btn-link btn-sm" onclick="clearAllLogFilters()">Clear filters</button>' : ''}
                    </div>
                `;
                return;
            }

            // Check if we should auto-scroll (user is at bottom)
            const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

            let html = '';
            for (const log of filteredLogs.reverse()) {
                html += renderLogEntry(log);
            }
            container.innerHTML = html;

            // Auto-scroll to bottom if user was there
            if (wasAtBottom) {
                container.scrollTop = container.scrollHeight;
            }

        } catch (error) {
            container.innerHTML = `<div class="text-danger p-3"><i class="bi bi-exclamation-triangle"></i> Error loading logs: ${escapeHtml(error.message)}</div>`;
        }
    }

    // Active log filters (array of {type, value, display} objects)
    let serverLogFilters = [];

    function addLogFilter(type, value, display) {
        // Check if filter already exists
        if (serverLogFilters.some(f => f.type === type && f.value === value)) {
            return; // Already filtered
        }
        serverLogFilters.push({ type, value, display: display || value });
        updateLogFilterBadges();
        refreshServerLogs();
    }

    function removeLogFilter(index) {
        serverLogFilters.splice(index, 1);
        updateLogFilterBadges();
        refreshServerLogs();
    }

    function clearAllLogFilters() {
        serverLogFilters = [];
        updateLogFilterBadges();
        refreshServerLogs();
    }

    function updateLogFilterBadges() {
        const container = document.getElementById('serverLogsFilters');
        const badgesContainer = document.getElementById('serverLogsFilterBadges');

        if (serverLogFilters.length === 0) {
            container.classList.add('d-none');
            badgesContainer.innerHTML = '';
            return;
        }

        container.classList.remove('d-none');

        const typeColors = {
            'logger': 'primary',
            'level': 'info',
            'text': 'secondary'
        };

        const typeIcons = {
            'logger': 'bi-journal-code',
            'level': 'bi-filter',
            'text': 'bi-search'
        };

        badgesContainer.innerHTML = serverLogFilters.map((f, i) => `
            <span class="badge bg-${typeColors[f.type] || 'secondary'} log-filter-badge me-1">
                <i class="bi ${typeIcons[f.type] || 'bi-tag'}"></i>
                ${escapeHtml(f.display)}
                <button type="button" class="btn-close btn-close-white" aria-label="Remove" onclick="removeLogFilter(${i})"></button>
            </span>
        `).join('');
    }

    function logMatchesFilters(log) {
        if (serverLogFilters.length === 0) return true;

        for (const filter of serverLogFilters) {
            let matches = false;
            switch (filter.type) {
                case 'logger':
                    matches = log.logger_name.includes(filter.value);
                    break;
                case 'level':
                    matches = log.level === filter.value;
                    break;
                case 'text':
                    matches = log.message.toLowerCase().includes(filter.value.toLowerCase());
                    break;
                default:
                    matches = true;
            }
            if (!matches) return false;
        }
        return true;
    }

    function renderLogEntry(log) {
        const timestamp = new Date(log.timestamp * 1000);
        const timeStr = timestamp.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const dateStr = timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        let levelClass = 'text-secondary';
        let levelIcon = 'bi-dot';
        switch (log.level) {
            case 'DEBUG':
                levelClass = 'text-secondary';
                levelIcon = 'bi-bug';
                break;
            case 'INFO':
                levelClass = 'text-info';
                levelIcon = 'bi-info-circle';
                break;
            case 'WARNING':
                levelClass = 'text-warning';
                levelIcon = 'bi-exclamation-triangle';
                break;
            case 'ERROR':
                levelClass = 'text-danger';
                levelIcon = 'bi-x-circle';
                break;
            case 'CRITICAL':
                levelClass = 'text-danger fw-bold';
                levelIcon = 'bi-exclamation-octagon-fill';
                break;
        }

        // Shorten logger name (show last two parts)
        const loggerParts = log.logger_name.split('.');
        const shortLogger = loggerParts.slice(-2).join('.');

        let excInfo = '';
        if (log.exc_info) {
            excInfo = `<pre class="text-danger small mb-0 mt-1" style="white-space: pre-wrap;">${escapeHtml(log.exc_info)}</pre>`;
        }

        // Make message words clickable (extract significant tokens)
        const messageHtml = makeMessageClickable(log.message);

        return `
            <div class="log-entry py-1 px-2 border-bottom border-secondary border-opacity-25 ${log.level === 'ERROR' || log.level === 'CRITICAL' ? 'bg-danger bg-opacity-10' : ''}">
                <span class="text-muted">${dateStr} ${timeStr}</span>
                <span class="${levelClass} mx-2 log-clickable" onclick="addLogFilter('level', '${log.level}', '${log.level}')" title="Filter by level: ${log.level}"><i class="bi ${levelIcon}"></i> ${log.level.padEnd(8)}</span>
                <span class="text-primary log-clickable" onclick="addLogFilter('logger', '${escapeHtml(log.logger_name)}', '[${escapeHtml(shortLogger)}]')" title="Filter by logger: ${log.logger_name}">[${shortLogger}]</span>
                <span class="ms-2">${messageHtml}</span>
                ${excInfo}
            </div>
        `;
    }

    function makeMessageClickable(message) {
        // Split message into tokens that could be useful filters
        // Match: identifiers, hex IDs, URLs, quoted strings, etc.
        const escaped = escapeHtml(message);

        // Pattern to match significant tokens:
        // - Hex node IDs like !aabbccdd
        // - Identifiers with underscores/dots like some_function or module.name
        // - Quoted strings
        // - IP addresses
        // - File paths
        const tokenPattern = /(!?[0-9a-fA-F]{8})|([a-zA-Z_][a-zA-Z0-9_.]{3,})|(\/[a-zA-Z0-9_\/.]+)|(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/g;

        let result = escaped;
        const matches = [...escaped.matchAll(tokenPattern)];

        // Process matches in reverse order to preserve positions
        for (let i = matches.length - 1; i >= 0; i--) {
            const match = matches[i];
            const token = match[0];
            const start = match.index;
            const end = start + token.length;

            // Skip very common/short tokens
            if (['true', 'false', 'null', 'None', 'self', 'this'].includes(token)) continue;

            const clickable = `<span class="log-clickable text-body" onclick="addLogFilter('text', '${token.replace(/'/g, "\\'")}', '${token.replace(/'/g, "\\'").substring(0, 20)}${token.length > 20 ? '…' : ''}')" title="Filter by: ${token}">${token}</span>`;
            result = result.substring(0, start) + clickable + result.substring(end);
        }

        return result;
    }

    async function clearServerLogs() {
        if (!confirm('Clear all captured log entries from memory? This cannot be undone.')) return;

        try {
            const response = await fetch('/api/admin/logs/clear', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Logs cleared');
                refreshServerLogs();
            } else {
                showAlert('danger', data.error || 'Failed to clear logs');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // ============================================================================
    // Background Job Backup/Restore Functions
    // ============================================================================

    // Toggle visibility of custom delay input
    function updateBackupDelayUI() {
        const mode = document.getElementById('backupDelayMode').value;
        const customGroup = document.getElementById('backupCustomDelayGroup');
        if (mode === 'custom') {
            customGroup.classList.remove('d-none');
        } else {
            customGroup.classList.add('d-none');
        }
    }

    // Get the configured delay value for backup
    function getBackupDelayValue() {
        const mode = document.getElementById('backupDelayMode')?.value || 'auto';
        switch (mode) {
            case 'auto':
                return null;  // Let server calculate
            case 'fast':
                return 0;
            case 'normal':
                return 1.5;
            case 'slow':
                return 3;
            case 'custom':
                return parseFloat(document.getElementById('backupCustomDelay')?.value) || 1.5;
            default:
                return null;
        }
    }

    // Queue backup as background job instead of SSE
    async function startBackupJob() {
        const nodeId = document.getElementById('backupSourceNode').value;
        const backupName = document.getElementById('backupNameInput').value.trim();
        const description = document.getElementById('backupDescriptionInput').value.trim();
        const interRequestDelay = getBackupDelayValue();

        if (!nodeId) {
            showAlert('warning', 'Please select a node to backup');
            return;
        }
        if (!backupName) {
            showAlert('warning', 'Please enter a backup name');
            return;
        }

        const btn = document.getElementById('startBackupJobBtn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Queueing...';
        }

        try {
            const result = await jobManager.queueBackup(nodeId, backupName, description, interRequestDelay);

            if (result.success) {
                showAlert('success', `Backup job queued (position: ${result.queue_position || 1}). You can close this and check the Jobs tab for progress.`);

                // Close the modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('createBackupModal'));
                if (modal) modal.hide();

                // Show jobs tab badge update
                updateJobsTabBadge();
            } else {
                showAlert('warning', result.error || 'Failed to queue backup job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-cloud-download"></i> Create Backup';
            }
        }
    }

    // Queue restore as background job
    async function startRestoreJob() {
        // Get backup ID and target node from the restore button's dataset
        const startBtn = document.getElementById('startRestoreJobBtn');
        const backupId = startBtn?.dataset.backupId;
        const targetNodeId = startBtn?.dataset.targetNodeId;

        if (!backupId) {
            showAlert('warning', 'No backup selected');
            return;
        }

        if (!targetNodeId) {
            showAlert('warning', 'Please select a target node');
            return;
        }

        // Get selected items for selective restore
        const selectedItems = getSelectedRestoreItems();

        if (selectedItems.coreConfigs.length === 0 &&
            selectedItems.moduleConfigs.length === 0 &&
            selectedItems.channels.length === 0) {
            showAlert('warning', 'Please select at least one item to restore');
            return;
        }

        // Get options from the restore modal (restoreBackupModal)
        const skipLora = document.getElementById('restoreSkipLora')?.checked === true;
        const skipSecurity = document.getElementById('restoreSkipSecurity')?.checked !== false;
        const rebootAfter = document.getElementById('restoreRebootAfter')?.checked === true;

        const btn = document.getElementById('startRestoreJobBtn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Queueing...';
        }

        try {
            const result = await jobManager.queueRestore(backupId, targetNodeId, {
                skipLora,
                skipSecurity,
                rebootAfter,
                selectedCoreConfigs: selectedItems.coreConfigs,
                selectedModuleConfigs: selectedItems.moduleConfigs,
                selectedChannels: selectedItems.channels
            });

            if (result.success) {
                showAlert('success', `Restore job queued (position: ${result.queue_position || 1}). You can close this and check the Jobs tab for progress.`);

                // Close the restore modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('restoreBackupModal'));
                if (modal) modal.hide();

                // Show jobs tab badge update
                updateJobsTabBadge();
            } else {
                showAlert('warning', result.error || 'Failed to queue restore job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-arrow-counterclockwise"></i> Start Restore';
            }
        }
    }

    function formatTimestamp(ts) {
        if (!ts) return 'Unknown';
        const d = new Date(ts * 1000);
        return d.toLocaleString();
    }

    // ============================================================================
    // Mesh Bot Management
    // ============================================================================

    let botStatusInterval = null;
    let botActivityInterval = null;
    let lastActivityTimestamp = null;

    // Initialize bot status when tab is shown
    document.getElementById('bot-tab')?.addEventListener('shown.bs.tab', function() {
        refreshBotStatus();
        refreshBotActivity();
        // Start polling for bot status and activity
        if (!botStatusInterval) {
            botStatusInterval = setInterval(refreshBotStatus, 3000);
        }
        if (!botActivityInterval) {
            botActivityInterval = setInterval(refreshBotActivity, 2000);
        }
    });

    // Stop polling when leaving bot tab
    document.querySelectorAll('#adminTabs .nav-link').forEach(tab => {
        tab.addEventListener('shown.bs.tab', function(e) {
            if (e.target.id !== 'bot-tab') {
                if (botStatusInterval) {
                    clearInterval(botStatusInterval);
                    botStatusInterval = null;
                }
                if (botActivityInterval) {
                    clearInterval(botActivityInterval);
                    botActivityInterval = null;
                }
            }
        });
    });

    async function refreshBotStatus() {
        try {
            const response = await fetch('/api/bot/status');
            const data = await response.json();

            if (data.error) {
                console.error('Bot status error:', data.error);
                return;
            }

            // Update status indicator
            const indicator = document.getElementById('botStatusIndicator');
            const statusText = document.getElementById('botStatusText');
            const runningBadge = document.getElementById('botRunningBadge');
            const startBtn = document.getElementById('startBotBtn');
            const stopBtn = document.getElementById('stopBotBtn');

            if (data.running) {
                indicator.classList.remove('status-disconnected');
                indicator.classList.add('status-connected');
                statusText.textContent = 'Running';
                runningBadge.classList.remove('d-none');
                startBtn.disabled = true;
                stopBtn.disabled = false;
            } else {
                indicator.classList.remove('status-connected');
                indicator.classList.add('status-disconnected');
                statusText.textContent = data.enabled ? 'Enabled (not running)' : 'Stopped';
                runningBadge.classList.add('d-none');
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }

            // Update stats
            document.getElementById('botQueueSize').textContent = data.queue_size || 0;
            document.getElementById('botCommandCount').textContent = data.commands?.length || 0;

            // Update detailed stats
            if (data.stats) {
                document.getElementById('botStatsSent').textContent = data.stats.messages_sent || 0;
                document.getElementById('botStatsReceived').textContent = data.stats.commands_processed || 0;
                document.getElementById('botStatsErrors').textContent = data.stats.errors || 0;

                // Format uptime
                if (data.stats.uptime) {
                    const uptime = data.stats.uptime;
                    const hours = Math.floor(uptime / 3600);
                    const mins = Math.floor((uptime % 3600) / 60);
                    const secs = Math.floor(uptime % 60);
                    if (hours > 0) {
                        document.getElementById('botUptime').textContent = `${hours}h ${mins}m`;
                    } else if (mins > 0) {
                        document.getElementById('botUptime').textContent = `${mins}m ${secs}s`;
                    } else {
                        document.getElementById('botUptime').textContent = `${secs}s`;
                    }
                } else {
                    document.getElementById('botUptime').textContent = '--';
                }
            }

            // Update commands table with toggle switches
            updateBotCommandsTable(data.commands || []);

            // Update config fields (only if not focused)
            const listenChannelsEl = document.getElementById('botListenChannels');
            if (document.activeElement !== listenChannelsEl) {
                listenChannelsEl.value = (data.listen_channels || []).join(', ');
            }
            const respondChannelEl = document.getElementById('botRespondChannelIndex');
            if (document.activeElement !== respondChannelEl) {
                respondChannelEl.value = data.respond_channel_index || 1;
            }
            document.getElementById('botWaitForJobs').checked = data.wait_for_jobs !== false;

        } catch (error) {
            console.error('Error fetching bot status:', error);
        }
    }

    function updateBotCommandsTable(commands) {
        const tbody = document.getElementById('botCommandsTable');
        if (!commands || commands.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="3" class="text-center text-muted py-3">No commands registered</td>
                </tr>
            `;
            return;
        }

        tbody.innerHTML = commands.map(cmd => {
            const isEnabled = cmd.enabled !== false;
            return `
                <tr class="${isEnabled ? '' : 'bot-cmd-disabled'}">
                    <td class="text-center">
                        <div class="form-check form-switch mb-0">
                            <input class="form-check-input bot-cmd-toggle" type="checkbox"
                                   ${isEnabled ? 'checked' : ''}
                                   onchange="toggleBotCommand('${escapeHtml(cmd.name)}', this.checked)"
                                   title="${isEnabled ? 'Click to disable' : 'Click to enable'}">
                        </div>
                    </td>
                    <td><code class="${isEnabled ? '' : 'text-muted'}">!${escapeHtml(cmd.name)}</code></td>
                    <td class="small ${isEnabled ? '' : 'text-muted'}">${escapeHtml(cmd.description || '')}</td>
                </tr>
            `;
        }).join('');
    }

    async function toggleBotCommand(commandName, enabled) {
        try {
            const endpoint = enabled ? 'enable' : 'disable';
            const response = await fetch(`/api/bot/command/${encodeURIComponent(commandName)}/${endpoint}`, {
                method: 'POST'
            });
            const data = await response.json();

            if (!data.success) {
                showAlert('danger', data.error || `Failed to ${endpoint} command`);
                refreshBotStatus(); // Revert UI
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
            refreshBotStatus(); // Revert UI
        }
    }

    async function refreshBotActivity() {
        try {
            let url = '/api/bot/activity?limit=50';
            if (lastActivityTimestamp) {
                url += `&since=${lastActivityTimestamp}`;
            }

            const response = await fetch(url);
            const data = await response.json();

            if (data.error) {
                console.error('Bot activity error:', data.error);
                return;
            }

            if (data.activity && data.activity.length > 0) {
                // Update last timestamp
                lastActivityTimestamp = Math.max(...data.activity.map(a => a.timestamp));

                // If this is initial load or we have new entries
                if (!lastActivityTimestamp || data.activity.length > 0) {
                    renderBotActivity(data.activity, !lastActivityTimestamp);
                }
            }
        } catch (error) {
            console.error('Error fetching bot activity:', error);
        }
    }

    function renderBotActivity(activities, replace = false) {
        const container = document.getElementById('botActivityLog');

        if (replace || container.querySelector('.text-center')) {
            container.innerHTML = '';
        }

        if (activities.length === 0 && container.children.length === 0) {
            container.innerHTML = `
                <div class="text-center text-muted py-4">
                    <i class="bi bi-clock-history fs-2"></i>
                    <p class="mb-0 small">No activity yet</p>
                </div>
            `;
            return;
        }

        // Sort by timestamp descending (newest first)
        activities.sort((a, b) => b.timestamp - a.timestamp);

        activities.forEach(entry => {
            const div = document.createElement('div');
            div.className = 'bot-activity-entry';

            const time = new Date(entry.timestamp * 1000);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            let icon, iconClass, title, detail;

            switch (entry.type) {
                case 'command_received':
                    icon = 'bi-arrow-down-circle';
                    iconClass = 'event-command';
                    title = `!${entry.data.command}`;
                    const dmTag = entry.data.is_dm ? ' [DM]' : '';
                    const channelInfo = entry.data.channel ? ` on ${entry.data.channel}` : '';
                    detail = `from ${entry.data.sender_name || entry.data.sender_id}${dmTag}${channelInfo}`;
                    break;
                case 'response_queued':
                    icon = 'bi-arrow-up-circle';
                    iconClass = 'event-response';
                    title = 'Response queued';
                    const destInfo = entry.data.destination ? ` → ${entry.data.destination}` : '';
                    detail = (entry.data.response_preview || '') + destInfo;
                    break;
                case 'message_sent':
                    icon = 'bi-check-circle';
                    iconClass = 'event-response';
                    title = 'Sent';
                    const sentDestInfo = entry.data.destination ? ` → ${entry.data.destination}` : '';
                    detail = (entry.data.text_preview || '') + sentDestInfo;
                    break;
                case 'message_failed':
                    icon = 'bi-x-circle';
                    iconClass = 'event-error';
                    title = 'Send failed';
                    detail = entry.data.reason || '';
                    break;
                case 'command_error':
                    icon = 'bi-exclamation-triangle';
                    iconClass = 'event-error';
                    title = `Error: !${entry.data.command}`;
                    detail = entry.data.error || '';
                    break;
                case 'bot_started':
                    icon = 'bi-play-circle';
                    iconClass = 'event-system';
                    title = 'Bot started';
                    detail = '';
                    break;
                case 'bot_stopped':
                    icon = 'bi-stop-circle';
                    iconClass = 'event-system';
                    title = 'Bot stopped';
                    detail = '';
                    break;
                case 'command_enabled':
                    icon = 'bi-toggle-on';
                    iconClass = 'event-system';
                    title = `Enabled: !${entry.data.command}`;
                    detail = '';
                    break;
                case 'command_disabled':
                    icon = 'bi-toggle-off';
                    iconClass = 'event-system';
                    title = `Disabled: !${entry.data.command}`;
                    detail = '';
                    break;
                default:
                    icon = 'bi-info-circle';
                    iconClass = 'event-system';
                    title = entry.type;
                    detail = JSON.stringify(entry.data);
            }

            div.innerHTML = `
                <span class="bot-activity-time">${timeStr}</span>
                <i class="bi ${icon} bot-activity-icon ${iconClass}"></i>
                <div class="bot-activity-content">
                    <div class="bot-activity-title">${escapeHtml(title)}</div>
                    ${detail ? `<div class="bot-activity-detail" title="${escapeHtml(detail)}">${escapeHtml(detail)}</div>` : ''}
                </div>
            `;

            // Insert at beginning for newest-first order
            if (container.firstChild) {
                container.insertBefore(div, container.firstChild);
            } else {
                container.appendChild(div);
            }
        });

        // Limit displayed entries
        while (container.children.length > 50) {
            container.removeChild(container.lastChild);
        }
    }

    function clearActivityLog() {
        lastActivityTimestamp = null;
        document.getElementById('botActivityLog').innerHTML = `
            <div class="text-center text-muted py-4">
                <i class="bi bi-clock-history fs-2"></i>
                <p class="mb-0 small">No activity yet</p>
            </div>
        `;
    }

    async function startBot() {
        const btn = document.getElementById('startBotBtn');
        btn.disabled = true;
        btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Starting...';

        try {
            const response = await fetch('/api/bot/start', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Bot started successfully');
                refreshBotStatus();
                refreshBotActivity();
            } else {
                showAlert('danger', data.error || 'Failed to start bot');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            btn.innerHTML = '<i class="bi bi-play-fill"></i> Start';
            refreshBotStatus();
        }
    }

    async function stopBot() {
        const btn = document.getElementById('stopBotBtn');
        btn.disabled = true;
        btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Stopping...';

        try {
            const response = await fetch('/api/bot/stop', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Bot stopped successfully');
                refreshBotStatus();
                refreshBotActivity();
            } else {
                showAlert('danger', data.error || 'Failed to stop bot');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            btn.innerHTML = '<i class="bi bi-stop-fill"></i> Stop';
            refreshBotStatus();
        }
    }

    async function saveBotConfig() {
        const listenChannels = document.getElementById('botListenChannels').value
            .split(',')
            .map(c => c.trim())
            .filter(c => c.length > 0);
        const respondChannelIndex = parseInt(document.getElementById('botRespondChannelIndex').value) || 1;
        const waitForJobs = document.getElementById('botWaitForJobs').checked;

        try {
            const response = await fetch('/api/bot/config', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    listen_channels: listenChannels,
                    respond_channel_index: respondChannelIndex,
                    wait_for_jobs: waitForJobs
                })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Bot configuration saved');
            } else {
                showAlert('danger', data.error || 'Failed to save configuration');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function sendBotMessage() {
        const text = document.getElementById('botMessageText').value.trim();
        if (!text) {
            showAlert('warning', 'Please enter a message');
            return;
        }

        const destination = document.getElementById('botMessageDestination').value;
        const priority = document.getElementById('botMessagePriority').value;

        try {
            const response = await fetch('/api/bot/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text, destination, priority })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Message queued (queue size: ${data.queue_size})`);
                document.getElementById('botMessageText').value = '';
                refreshBotStatus();
            } else {
                showAlert('danger', data.error || 'Failed to queue message');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function sendQuickMessage(text) {
        try {
            const response = await fetch('/api/bot/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text, destination: 'broadcast', priority: 'normal' })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Message queued: "${text.substring(0, 30)}..."`);
                refreshBotStatus();
            } else {
                showAlert('danger', data.error || 'Failed to queue message');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function sendCustomQuickMessage() {
        const text = document.getElementById('botQuickMessageText').value.trim();
        if (!text) {
            showAlert('warning', 'Please enter a message');
            return;
        }
        await sendQuickMessage(text);
        document.getElementById('botQuickMessageText').value = '';
    }

    async function broadcastStatus() {
        try {
            const statusResponse = await fetch('/api/bot/status');
            const botStatus = await statusResponse.json();

            const stats = botStatus.stats || {};
            const statusText = `📊 Mesh Bot: ${botStatus.running ? '✅ Running' : '⏹️ Stopped'} | Sent: ${stats.messages_sent || 0} | Cmds: ${stats.commands_processed || 0}`;

            const response = await fetch('/api/bot/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: statusText, destination: 'broadcast', priority: 'normal' })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Status broadcast queued');
                refreshBotStatus();
            } else {
                showAlert('danger', data.error || 'Failed to broadcast status');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function clearBotQueue() {
        if (!confirm('Clear all queued bot messages?')) {
            return;
        }

        try {
            const response = await fetch('/api/bot/queue/clear', { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                showAlert('success', data.message || 'Queue cleared');
                refreshBotStatus();
            } else {
                showAlert('danger', data.error || 'Failed to clear queue');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // ============================================================================
    // VISIBILITY-AWARE POLLING - Pause all polling when tab is hidden
    // ============================================================================

    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // Pause all polling when tab is hidden
            stopServerLogsPolling();
            if (botStatusInterval) {
                clearInterval(botStatusInterval);
                botStatusInterval = null;
            }
            if (botActivityInterval) {
                clearInterval(botActivityInterval);
                botActivityInterval = null;
            }
        } else {
            // Resume polling when tab becomes visible (if on appropriate tabs)
            const activeTab = document.querySelector('#adminTabs .nav-link.active');
            if (activeTab?.id === 'server-logs-tab') {
                refreshServerLogs();
                startServerLogsPolling();
            }
            if (activeTab?.id === 'bot-tab') {
                refreshBotStatus();
                refreshBotActivity();
                botStatusInterval = setInterval(refreshBotStatus, 3000);
                botActivityInterval = setInterval(refreshBotActivity, 2000);
            }
        }
    });
</script>
{% endblock %}
