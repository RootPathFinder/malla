{% extends "base.html" %}

{% block title %}Mesh Admin - {{ APP_NAME }}{% endblock %}

{% block extra_css %}
<style>
    .admin-card {
        transition: all 0.2s ease;
    }
    .admin-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .node-admin-badge {
        font-size: 0.7rem;
        padding: 2px 6px;
    }
    .command-btn {
        min-width: 120px;
    }
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
    }
    .status-connected {
        background-color: #198754;
        box-shadow: 0 0 8px rgba(25, 135, 84, 0.5);
    }
    .status-disconnected {
        background-color: #dc3545;
    }
    .log-entry {
        font-size: 0.875rem;
    }
    .log-timestamp {
        color: #6c757d;
        font-family: monospace;
    }
    .log-status-success {
        color: #198754;
    }
    .log-status-failed {
        color: #dc3545;
    }
    .log-status-pending {
        color: #ffc107;
    }
    .log-status-timeout {
        color: #fd7e14;
    }
    .log-entry {
        cursor: pointer;
    }
    .log-entry:hover {
        background-color: var(--bs-tertiary-bg);
    }
    .log-details-popover {
        max-width: 450px;
        font-size: 0.8rem;
    }
    .log-details-popover .popover-body {
        padding: 0.75rem;
    }
    .log-details-section {
        margin-bottom: 0.5rem;
    }
    .log-details-section:last-child {
        margin-bottom: 0;
    }
    .log-details-label {
        font-weight: 600;
        color: var(--bs-secondary-color);
        font-size: 0.7rem;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
    }
    .log-details-content {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.75rem;
        background: var(--bs-tertiary-bg);
        padding: 0.5rem;
        border-radius: 0.25rem;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 150px;
        overflow-y: auto;
    }
    [data-bs-theme="dark"] .log-details-content {
        background: #161b22;
    }
    .log-error-content {
        color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
    }
    .log-success-content {
        color: #198754;
    }
    /* Node autocomplete styles */
    .node-autocomplete-container {
        position: relative;
    }
    .node-autocomplete-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        z-index: 1000;
        max-height: 300px;
        overflow-y: auto;
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-top: none;
        border-radius: 0 0 0.375rem 0.375rem;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .node-autocomplete-item {
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        border-bottom: 1px solid var(--bs-border-color);
    }
    .node-autocomplete-item:last-child {
        border-bottom: none;
    }
    .node-autocomplete-item:hover,
    .node-autocomplete-item.active {
        background: var(--bs-primary);
        color: white;
    }
    .node-autocomplete-item .node-name {
        font-weight: 500;
    }
    .node-autocomplete-item .node-id {
        font-size: 0.8rem;
        font-family: monospace;
        opacity: 0.8;
    }
    .config-display {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.8rem;
        background: var(--bs-tertiary-bg);
        color: var(--bs-body-color);
        padding: 1rem;
        border-radius: 0.5rem;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--bs-border-color);
    }
    [data-bs-theme="dark"] .config-display {
        background: #161b22;
        border-color: #30363d;
    }
    .config-form {
        max-height: 500px;
        overflow-y: auto;
        padding: 1rem;
        background: var(--bs-tertiary-bg);
        border-radius: 0.5rem;
        border: 1px solid var(--bs-border-color);
    }
    [data-bs-theme="dark"] .config-form {
        background: #161b22;
        border-color: #30363d;
    }
    .config-form .form-control,
    .config-form .form-select {
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        border-color: var(--bs-border-color);
    }
    .config-form .form-control:focus,
    .config-form .form-select:focus {
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        border-color: var(--bs-primary);
    }
    [data-bs-theme="dark"] .config-form .form-control,
    [data-bs-theme="dark"] .config-form .form-select {
        background-color: #0d1117;
        color: #c9d1d9;
        border-color: #30363d;
    }
    [data-bs-theme="dark"] .config-form .form-control:focus,
    [data-bs-theme="dark"] .config-form .form-select:focus {
        background-color: #0d1117;
        border-color: var(--bs-primary);
    }
    [data-bs-theme="dark"] .config-form .form-control::placeholder {
        color: #6e7681;
    }
    .config-field {
        margin-bottom: 1rem;
    }
    .config-field label {
        font-weight: 500;
        color: var(--bs-body-color);
    }
    .config-field .form-text {
        font-size: 0.75rem;
        color: var(--bs-secondary-color);
    }
    .config-field-unit {
        font-size: 0.8rem;
        color: var(--bs-secondary-color);
    }
    [data-bs-theme="dark"] .config-field-unit {
        color: #8b949e;
    }
    .spinner-border-sm {
        width: 1rem;
        height: 1rem;
    }
    #nodeSearchResults {
        max-height: 300px;
        overflow-y: auto;
    }
    /* Admin status banner styles */
    .admin-status-banner {
        border-radius: 0.5rem;
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
        border: 1px solid;
    }
    .admin-status-banner.status-success {
        background-color: rgba(25, 135, 84, 0.1);
        border-color: rgba(25, 135, 84, 0.3);
    }
    .admin-status-banner.status-warning {
        background-color: rgba(255, 193, 7, 0.1);
        border-color: rgba(255, 193, 7, 0.3);
    }
    .admin-status-banner.status-danger {
        background-color: rgba(220, 53, 69, 0.1);
        border-color: rgba(220, 53, 69, 0.3);
    }
    .admin-status-banner .status-icon {
        font-size: 1.25rem;
        margin-right: 0.5rem;
    }
    .admin-status-banner .status-message {
        font-weight: 500;
    }
    .admin-status-banner .status-details {
        font-size: 0.85rem;
        margin-top: 0.5rem;
    }
    .admin-status-banner .check-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0;
    }
    .admin-status-banner .check-item i {
        font-size: 0.9rem;
    }
    .admin-status-banner .check-passed {
        color: #198754;
    }
    .admin-status-banner .check-failed {
        color: #dc3545;
    }
    .admin-status-banner .suggestions {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid var(--bs-border-color);
    }
    .admin-status-banner .suggestion-item {
        font-size: 0.85rem;
        color: var(--bs-secondary-color);
        margin-top: 0.25rem;
    }
    .admin-status-banner .suggestion-item i {
        color: var(--bs-info);
        margin-right: 0.25rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/">Home</a></li>
                    <li class="breadcrumb-item active">Mesh Admin</li>
                </ol>
            </nav>
            <h1>
                <i class="bi bi-gear-wide-connected"></i> Mesh Admin
                <small class="text-muted fs-5">Remote Node Administration</small>
            </h1>
        </div>
    </div>

    <!-- Connection Status Card -->
    <div class="row mb-4">
        <div class="col-lg-6">
            <div class="card admin-card">
                <div class="card-header">
                    <i class="bi bi-wifi"></i> Connection Status
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="connectionTypeSelect" class="form-label"><strong>Connection Type</strong></label>
                            <select class="form-select" id="connectionTypeSelect" onchange="changeConnectionType()">
                                <option value="mqtt" {{ 'selected' if connection_status.connection_type == 'mqtt' else '' }}>MQTT (via broker)</option>
                                <option value="tcp" {{ 'selected' if connection_status.connection_type == 'tcp' else '' }}>TCP (direct connection)</option>
                                <option value="serial" {{ 'selected' if connection_status.connection_type == 'serial' else '' }}>USB/Serial (local device)</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <p class="mb-2 mt-4">
                                <strong>Status:</strong>
                                <span id="connectionStatus">
                                    {% if connection_status.connected %}
                                        <span class="status-indicator status-connected"></span>Connected
                                    {% else %}
                                        <span class="status-indicator status-disconnected"></span>Disconnected
                                    {% endif %}
                                </span>
                            </p>
                        </div>
                    </div>

                    <!-- MQTT Settings -->
                    <div id="mqttSettings" class="{{ 'd-none' if connection_status.connection_type != 'mqtt' else '' }}">
                        <div class="row">
                            <div class="col-md-6">
                                <p class="mb-2">
                                    <strong>MQTT Connected:</strong>
                                    <span id="mqttStatus">
                                        {% if connection_status.mqtt_connected %}
                                            <span class="badge bg-success">Yes</span>
                                        {% else %}
                                            <span class="badge bg-secondary">No</span>
                                        {% endif %}
                                    </span>
                                </p>
                            </div>
                            <div class="col-md-6">
                                <p class="mb-2">
                                    <strong>Gateway Node:</strong>
                                    <span id="gatewayNodeDisplay">
                                        {% if connection_status.gateway_node_hex %}
                                            <code>{{ connection_status.gateway_node_hex }}</code>
                                        {% else %}
                                            <span class="text-warning">Not configured</span>
                                        {% endif %}
                                    </span>
                                </p>
                            </div>
                        </div>
                        <hr>
                        <div class="row">
                            <div class="col">
                                <label for="gatewayNodeInput" class="form-label">Set Gateway Node ID</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="gatewayNodeInput"
                                           placeholder="e.g., !abcd1234 or 2882400052"
                                           value="{{ connection_status.gateway_node_hex or '' }}">
                                    <button class="btn btn-primary" type="button" onclick="setGatewayNode()">
                                        <i class="bi bi-check-lg"></i> Set Gateway
                                    </button>
                                </div>
                                <div class="form-text">
                                    The gateway node is the Meshtastic device connected to the MQTT broker that will relay admin commands.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TCP Settings -->
                    <div id="tcpSettings" class="{{ 'd-none' if connection_status.connection_type != 'tcp' else '' }}">
                        <div class="row mb-3">
                            <div class="col-md-8">
                                <label for="tcpHostInput" class="form-label">Node IP Address</label>
                                <input type="text" class="form-control" id="tcpHostInput"
                                       placeholder="192.168.1.1"
                                       value="{{ connection_status.tcp_host or '192.168.1.1' }}">
                            </div>
                            <div class="col-md-4">
                                <label for="tcpPortInput" class="form-label">Port</label>
                                <input type="number" class="form-control" id="tcpPortInput"
                                       placeholder="4403"
                                       value="{{ connection_status.tcp_port or 4403 }}">
                            </div>
                        </div>
                        <div class="row mb-2">
                            <div class="col">
                                <button class="btn btn-success me-2" type="button" onclick="tcpConnect()" id="tcpConnectBtn">
                                    <i class="bi bi-plug"></i> Connect
                                </button>
                                <button class="btn btn-outline-danger me-2" type="button" onclick="tcpDisconnect()" id="tcpDisconnectBtn">
                                    <i class="bi bi-x-circle"></i> Disconnect
                                </button>
                                <button class="btn btn-outline-warning" type="button" onclick="tcpReconnect()" id="tcpReconnectBtn"
                                        title="Force reconnection - useful if connection appears stale">
                                    <i class="bi bi-arrow-clockwise"></i> Reconnect
                                </button>
                            </div>
                        </div>
                        <div id="tcpConnectResult" class="alert d-none mt-2" role="alert"></div>
                        <div id="tcpHealthWarning" class="alert alert-warning d-none mt-2" role="alert">
                            <i class="bi bi-exclamation-triangle me-2"></i>
                            <span id="tcpHealthWarningText">Connection may be stale.</span>
                            <button class="btn btn-sm btn-warning ms-2" onclick="tcpReconnect()">
                                <i class="bi bi-arrow-clockwise"></i> Reconnect Now
                            </button>
                        </div>
                        <div class="form-text">
                            Connect directly to a Meshtastic node via TCP. The node must have WiFi enabled and be accessible on the network.
                        </div>
                    </div>

                    <!-- Serial/USB Settings -->
                    <div id="serialSettings" class="{{ 'd-none' if connection_status.connection_type != 'serial' else '' }}">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="serialPortSelect" class="form-label">Serial Port</label>
                                <select class="form-select" id="serialPortSelect">
                                    <option value="">-- Select USB/Serial to scan --</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">&nbsp;</label>
                                <button class="btn btn-outline-secondary d-block w-100" type="button" onclick="discoverSerialPorts()">
                                    <i class="bi bi-search"></i> Discover
                                </button>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">&nbsp;</label>
                                <button class="btn btn-outline-info d-block w-100" type="button" onclick="probeSerialDevices()" id="probeDevicesBtn">
                                    <i class="bi bi-cpu"></i> Identify
                                </button>
                            </div>
                        </div>
                        <div id="serialPortInfo" class="alert alert-info d-none mb-3" role="alert">
                            <small></small>
                        </div>
                        <div class="row mb-2">
                            <div class="col">
                                <button class="btn btn-success me-2" type="button" onclick="serialConnect()" id="serialConnectBtn">
                                    <i class="bi bi-usb-plug"></i> Connect
                                </button>
                                <button class="btn btn-outline-danger" type="button" onclick="serialDisconnect()" id="serialDisconnectBtn">
                                    <i class="bi bi-x-circle"></i> Disconnect
                                </button>
                            </div>
                        </div>
                        <div id="serialConnectResult" class="alert d-none mt-2" role="alert"></div>
                        <div class="form-text">
                            <strong>Discover</strong> scans for USB ports. <strong>Identify</strong> connects briefly to detect actual Meshtastic hardware (takes a few seconds per device).
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Test Node Card -->
        <div class="col-lg-6">
            <div class="card admin-card">
                <div class="card-header">
                    <i class="bi bi-search"></i> Test Node Admin Access
                </div>
                <div class="card-body">
                    <p class="text-muted mb-3">
                        Test if a node has this server's public key configured and can be remotely administered.
                    </p>
                    <div class="node-autocomplete-container mb-3">
                        <div class="input-group">
                            <input type="text" class="form-control" id="testNodeInput"
                                   placeholder="Start typing node name or ID..."
                                   autocomplete="off"
                                   oninput="searchNodes(this.value, 'testNodeResults')"
                                   onfocus="if(this.value.length >= 1) searchNodes(this.value, 'testNodeResults')"
                                   onblur="setTimeout(() => hideAutocomplete('testNodeResults'), 200)">
                            <button class="btn btn-outline-primary" type="button" onclick="testNodeAdmin()" id="testNodeBtn">
                                <i class="bi bi-lightning"></i> Test
                            </button>
                        </div>
                        <div id="testNodeResults" class="node-autocomplete-results" style="display:none;"></div>
                    </div>
                    <div id="testNodeResult" class="alert d-none" role="alert"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Tabs -->
    <div class="row">
        <div class="col">
            <ul class="nav nav-tabs" id="adminTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="nodes-tab" data-bs-toggle="tab"
                            data-bs-target="#nodes-pane" type="button" role="tab">
                        <i class="bi bi-router"></i> Administrable Nodes
                        <span class="badge bg-primary">{{ administrable_nodes|length }}</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="commands-tab" data-bs-toggle="tab"
                            data-bs-target="#commands-pane" type="button" role="tab">
                        <i class="bi bi-terminal"></i> Send Command
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="templates-tab" data-bs-toggle="tab"
                            data-bs-target="#templates-pane" type="button" role="tab">
                        <i class="bi bi-file-earmark-code"></i> Config Templates
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="backups-tab" data-bs-toggle="tab"
                            data-bs-target="#backups-pane" type="button" role="tab">
                        <i class="bi bi-cloud-download"></i> Node Backups
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="jobs-tab" data-bs-toggle="tab"
                            data-bs-target="#jobs-pane" type="button" role="tab">
                        <i class="bi bi-list-task"></i> Background Jobs
                        <span class="badge bg-secondary" id="jobsTabBadge">0</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="log-tab" data-bs-toggle="tab"
                            data-bs-target="#log-pane" type="button" role="tab">
                        <i class="bi bi-journal-text"></i> Audit Log
                    </button>
                </li>
            </ul>

            <div class="tab-content border border-top-0 rounded-bottom p-3" id="adminTabContent">
                <!-- Administrable Nodes Tab -->
                <div class="tab-pane fade show active" id="nodes-pane" role="tabpanel">
                    {% if administrable_nodes %}
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Node</th>
                                        <th>Hardware</th>
                                        <th>Firmware</th>
                                        <th>Uptime</th>
                                        <th>Capabilities</th>
                                        <th>Status</th>
                                        <th>Last Confirmed</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="administrableNodesBody">
                                    {% for node in administrable_nodes %}
                                    <tr id="admin-node-row-{{ node.node_id }}">
                                        <td>
                                            <a href="/node/{{ node.node_id }}" class="text-decoration-none">
                                                <strong>{{ node.long_name or node.short_name or 'Unknown' }}</strong>
                                            </a>
                                            <br>
                                            <code class="text-muted small">{{ node.hex_id or ('!' + '%08x'|format(node.node_id)) }}</code>
                                        </td>
                                        <td id="admin-node-hw-{{ node.node_id }}">{{ node.hw_model or 'Unknown' }}</td>
                                        <td id="admin-node-fw-{{ node.node_id }}">{{ node.firmware_version or 'Unknown' }}</td>
                                        <td id="admin-node-uptime-{{ node.node_id }}">
                                            <span class="text-muted small">—</span>
                                        </td>
                                        <td id="admin-node-caps-{{ node.node_id }}">
                                            <span class="text-muted small">—</span>
                                        </td>
                                        <td id="admin-node-status-{{ node.node_id }}">
                                            {% if node.last_status_result == 'online' %}
                                                <span class="badge bg-success"><i class="bi bi-check-circle"></i> Online</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'timeout' %}
                                                <span class="badge bg-warning text-dark"><i class="bi bi-clock"></i> Timeout</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'error' %}
                                                <span class="badge bg-danger"><i class="bi bi-x-circle"></i> Error</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'offline' %}
                                                <span class="badge bg-danger"><i class="bi bi-x-circle"></i> Offline</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% else %}
                                                <span class="badge bg-secondary">Not checked</span>
                                            {% endif %}
                                        </td>
                                        <td id="admin-node-confirmed-{{ node.node_id }}">
                                            <span class="text-muted small">
                                                {{ node.last_confirmed | timestamp_to_datetime }}
                                            </span>
                                        </td>
                                        <td>
                                            <div class="btn-group btn-group-sm">
                                                <button class="btn btn-outline-success"
                                                        onclick="refreshNodeAdminInfo({{ node.node_id }})"
                                                        title="Refresh admin info"
                                                        id="admin-node-refresh-btn-{{ node.node_id }}">
                                                    <i class="bi bi-arrow-repeat"></i>
                                                </button>
                                                <button class="btn btn-outline-primary"
                                                        onclick="selectNode({{ node.node_id }})"
                                                        title="Select for commands">
                                                    <i class="bi bi-cursor"></i>
                                                </button>
                                                <button class="btn btn-outline-info"
                                                        onclick="getNodeConfig({{ node.node_id }}, 'device')"
                                                        title="Get device config">
                                                    <i class="bi bi-gear"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    {% else %}
                        <div class="text-center py-5">
                            <i class="bi bi-inbox text-muted" style="font-size: 4rem;"></i>
                            <h4 class="mt-3">No Administrable Nodes Found</h4>
                            <p class="text-muted">
                                Nodes will appear here once they respond to admin requests.<br>
                                Use the "Test Node Admin Access" feature above to check if a node is administrable.
                            </p>
                        </div>
                    {% endif %}
                </div>

                <!-- Send Command Tab -->
                <div class="tab-pane fade" id="commands-pane" role="tabpanel">
                    <div class="row">
                        <div class="col-lg-6">
                            <div class="mb-3 node-autocomplete-container">
                                <label for="targetNodeInput" class="form-label">Target Node</label>
                                <input type="text" class="form-control" id="targetNodeInput"
                                       placeholder="Start typing node name or ID..."
                                       autocomplete="off"
                                       oninput="searchNodes(this.value, 'targetNodeResults'); checkAdminStatusDebounced()"
                                       onfocus="if(this.value.length >= 1) searchNodes(this.value, 'targetNodeResults')"
                                       onblur="setTimeout(() => hideAutocomplete('targetNodeResults'), 200)">
                                <div id="targetNodeResults" class="node-autocomplete-results" style="display:none;"></div>
                            </div>

                            <!-- Admin Status Banner -->
                            <div id="adminStatusBanner" class="admin-status-banner d-none">
                                <div class="d-flex align-items-start">
                                    <i class="status-icon bi" id="adminStatusIcon"></i>
                                    <div class="flex-grow-1">
                                        <div class="status-message" id="adminStatusMessage"></div>
                                        <div class="status-details" id="adminStatusDetails"></div>
                                        <div class="suggestions" id="adminStatusSuggestions"></div>
                                    </div>
                                    <button type="button" class="btn btn-sm btn-outline-primary ms-2"
                                            onclick="refreshAdminStatus()" title="Refresh status">
                                        <i class="bi bi-arrow-clockwise"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Configuration Requests</label>
                                <div class="d-flex flex-wrap gap-2" id="configRequestBtns">
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="device" onclick="getConfig('device', this)">
                                        <i class="bi bi-cpu"></i> Device
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="lora" onclick="getConfig('lora', this)">
                                        <i class="bi bi-broadcast"></i> LoRa
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="position" onclick="getConfig('position', this)">
                                        <i class="bi bi-geo-alt"></i> Position
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="power" onclick="getConfig('power', this)">
                                        <i class="bi bi-battery-charging"></i> Power
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="network" onclick="getConfig('network', this)">
                                        <i class="bi bi-wifi"></i> Network
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="display" onclick="getConfig('display', this)">
                                        <i class="bi bi-display"></i> Display
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="bluetooth" onclick="getConfig('bluetooth', this)">
                                        <i class="bi bi-bluetooth"></i> Bluetooth
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn config-req-btn"
                                            data-config="security" onclick="getConfig('security', this)">
                                        <i class="bi bi-shield-lock"></i> Security
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Module Configuration Requests</label>
                                <div class="d-flex flex-wrap gap-2" id="moduleConfigRequestBtns">
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="mqtt" onclick="getModuleConfig('mqtt', this)">
                                        <i class="bi bi-cloud"></i> MQTT
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="serial" onclick="getModuleConfig('serial', this)">
                                        <i class="bi bi-usb-plug"></i> Serial
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="telemetry" onclick="getModuleConfig('telemetry', this)">
                                        <i class="bi bi-graph-up"></i> Telemetry
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="neighborinfo" onclick="getModuleConfig('neighborinfo', this)">
                                        <i class="bi bi-people"></i> NeighborInfo
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="storeforward" onclick="getModuleConfig('storeforward', this)">
                                        <i class="bi bi-hdd-stack"></i> Store&amp;Forward
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="rangetest" onclick="getModuleConfig('rangetest', this)">
                                        <i class="bi bi-rulers"></i> Range Test
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="extnotif" onclick="getModuleConfig('extnotif', this)">
                                        <i class="bi bi-bell"></i> Ext Notif
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="cannedmsg" onclick="getModuleConfig('cannedmsg', this)">
                                        <i class="bi bi-chat-square-text"></i> Canned Msg
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="audio" onclick="getModuleConfig('audio', this)">
                                        <i class="bi bi-volume-up"></i> Audio
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="remotehardware" onclick="getModuleConfig('remotehardware', this)">
                                        <i class="bi bi-toggles"></i> Remote HW
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="ambientlighting" onclick="getModuleConfig('ambientlighting', this)">
                                        <i class="bi bi-lightbulb"></i> Ambient Light
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="detectionsensor" onclick="getModuleConfig('detectionsensor', this)">
                                        <i class="bi bi-radar"></i> Detection
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm command-btn config-req-btn"
                                            data-config="paxcounter" onclick="getModuleConfig('paxcounter', this)">
                                        <i class="bi bi-person-walking"></i> Paxcounter
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Channel Requests</label>
                                <div class="d-flex flex-wrap gap-2" id="channelRequestBtns">
                                    {% for i in range(8) %}
                                    <button class="btn btn-outline-info btn-sm config-req-btn"
                                            data-channel="{{ i }}" onclick="getChannel({{ i }}, this)">
                                        Ch {{ i }}
                                    </button>
                                    {% endfor %}
                                </div>
                            </div>

                            <hr>

                            <div class="mb-3">
                                <label class="form-label text-danger">Dangerous Commands</label>
                                <div class="d-flex flex-wrap gap-2">
                                    <button class="btn btn-warning command-btn" onclick="confirmRebootTarget()">
                                        <i class="bi bi-arrow-clockwise"></i> Reboot
                                    </button>
                                    <button class="btn btn-danger command-btn" onclick="confirmShutdownTarget()">
                                        <i class="bi bi-power"></i> Shutdown
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="col-lg-6">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Response</label>
                                <div class="btn-group btn-group-sm" id="responseViewToggle" style="display:none;">
                                    <button type="button" class="btn btn-outline-secondary active" onclick="showFormView()">
                                        <i class="bi bi-ui-checks"></i> Form
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" onclick="showJsonView()">
                                        <i class="bi bi-code-square"></i> JSON/Log
                                    </button>
                                </div>
                            </div>
                            <div id="commandResponseForm" class="config-form" style="display:none;">
                                <form id="configEditForm">
                                    <div id="configFields">
                                        <!-- Dynamic config fields will be rendered here -->
                                    </div>
                                    <div class="d-flex gap-2 mt-3" id="configFormActions" style="display:none;">
                                        <button type="button" class="btn btn-primary" onclick="saveConfig()">
                                            <i class="bi bi-check-lg"></i> Save Changes
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary" onclick="refreshConfig()">
                                            <i class="bi bi-arrow-clockwise"></i> Refresh
                                        </button>
                                    </div>
                                </form>
                            </div>
                            <div id="commandResponse" class="config-display">
                                <span class="text-muted">Response will appear here...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Config Templates Tab -->
                <div class="tab-pane fade" id="templates-pane" role="tabpanel">
                    <div class="row">
                        <!-- Templates List -->
                        <div class="col-md-5">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0"><i class="bi bi-file-earmark-code"></i> Saved Templates</h6>
                                <div class="dropdown">
                                    <button class="btn btn-primary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                        <i class="bi bi-plus-lg"></i> New Template
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-end">
                                        <li><a class="dropdown-item" href="#" onclick="showCreateTemplateModal(); return false;">
                                            <i class="bi bi-pencil"></i> Create Empty Template
                                        </a></li>
                                        <li><a class="dropdown-item" href="#" onclick="showCreateFromNodeModal(); return false;">
                                            <i class="bi bi-download"></i> Create from Node
                                        </a></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="mb-2">
                                <select class="form-select form-select-sm" id="templateTypeFilter" onchange="loadTemplates()">
                                    <option value="">All Types</option>
                                    <option value="device">Device</option>
                                    <option value="lora">LoRa</option>
                                    <option value="channel">Channel (Single)</option>
                                    <option value="channels">Channels (Full Set)</option>
                                    <option value="position">Position</option>
                                    <option value="power">Power</option>
                                    <option value="network">Network</option>
                                    <option value="display">Display</option>
                                    <option value="bluetooth">Bluetooth</option>
                                    <option value="security">Security</option>
                                </select>
                            </div>
                            <div id="templatesList" class="list-group" style="max-height: 400px; overflow-y: auto;">
                                <div class="text-center py-3 text-muted">
                                    <i class="bi bi-arrow-clockwise spin"></i> Loading templates...
                                </div>
                            </div>
                        </div>

                        <!-- Template Editor / Deploy -->
                        <div class="col-md-7">
                            <div id="templateEditorSection" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0" id="templateEditorTitle">
                                        <i class="bi bi-pencil"></i> Edit Template
                                    </h6>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-success" onclick="saveTemplate()" id="saveTemplateBtn">
                                            <i class="bi bi-save"></i> Save
                                        </button>
                                        <button class="btn btn-outline-danger" onclick="deleteTemplate()" id="deleteTemplateBtn">
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Template Name</label>
                                    <input type="text" class="form-control" id="templateName" placeholder="e.g., Standard LoRa Settings">
                                </div>
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label class="form-label">Type</label>
                                        <select class="form-select" id="templateType">
                                            <option value="device">Device</option>
                                            <option value="lora">LoRa</option>
                                            <option value="channel">Channel (Single)</option>
                                            <option value="channels">Channels (Full Set)</option>
                                            <option value="position">Position</option>
                                            <option value="power">Power</option>
                                            <option value="network">Network</option>
                                            <option value="display">Display</option>
                                            <option value="bluetooth">Bluetooth</option>
                                            <option value="security">Security</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label">Description</label>
                                        <input type="text" class="form-control" id="templateDescription" placeholder="Optional description">
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Configuration (JSON)</label>
                                    <textarea class="form-control font-monospace" id="templateConfigData" rows="8"
                                              placeholder='{"region": "US", "modem_preset": "LONG_FAST"}'></textarea>
                                    <div class="form-text">
                                        Enter the configuration as JSON. See
                                        <a href="https://meshtastic.org/docs/configuration/" target="_blank">Meshtastic docs</a>
                                        for available settings.
                                    </div>
                                </div>

                                <!-- Deploy Section -->
                                <div class="card bg-light">
                                    <div class="card-header">
                                        <i class="bi bi-send"></i> Deploy Template
                                    </div>
                                    <div class="card-body">
                                        <div class="mb-3">
                                            <label class="form-label">Select Target Nodes</label>
                                            <div id="deployNodesList" class="border rounded p-2" style="max-height: 150px; overflow-y: auto;">
                                                <span class="text-muted small">Loading administrable nodes...</span>
                                            </div>
                                            <div class="form-text">
                                                <button class="btn btn-link btn-sm p-0" onclick="selectAllDeployNodes()">Select All</button>
                                                |
                                                <button class="btn btn-link btn-sm p-0" onclick="deselectAllDeployNodes()">Deselect All</button>
                                            </div>
                                        </div>
                                        <button class="btn btn-success" onclick="deployTemplate()" id="deployTemplateBtn">
                                            <i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes
                                        </button>
                                        <div id="deploymentResults" class="mt-3" style="display: none;"></div>
                                    </div>
                                </div>
                            </div>

                            <div id="templatePlaceholder">
                                <div class="text-center py-5 text-muted">
                                    <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                                    <p class="mt-3">Select a template from the list to edit or deploy,<br>or create a new template.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Deployment History -->
                    <div class="mt-4">
                        <h6><i class="bi bi-clock-history"></i> Recent Deployments</h6>
                        <div id="deploymentHistory" class="table-responsive" style="max-height: 200px; overflow-y: auto;">
                            <table class="table table-sm table-hover">
                                <thead class="table-light sticky-top">
                                    <tr>
                                        <th>Template</th>
                                        <th>Node</th>
                                        <th>Status</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody id="deploymentHistoryBody">
                                    <tr>
                                        <td colspan="4" class="text-center text-muted">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Node Backups Tab -->
                <div class="tab-pane fade" id="backups-pane" role="tabpanel">
                    <div class="row">
                        <!-- Backups List -->
                        <div class="col-md-5">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0"><i class="bi bi-cloud-download"></i> Saved Backups</h6>
                                <button class="btn btn-primary btn-sm" onclick="showCreateBackupModal()">
                                    <i class="bi bi-plus-lg"></i> Create Backup
                                </button>
                            </div>
                            <div class="mb-2">
                                <select class="form-select form-select-sm" id="backupNodeFilter" onchange="loadBackups()">
                                    <option value="">All Nodes</option>
                                    {% for node in administrable_nodes %}
                                    <option value="{{ node.node_id }}">
                                        {{ node.long_name or node.short_name or node.hex_id }}
                                    </option>
                                    {% endfor %}
                                </select>
                            </div>
                            <div id="backupsList" class="list-group" style="max-height: 500px; overflow-y: auto;">
                                <div class="text-center py-3 text-muted">
                                    <i class="bi bi-arrow-clockwise spin"></i> Loading backups...
                                </div>
                            </div>
                        </div>

                        <!-- Backup Viewer -->
                        <div class="col-md-7">
                            <div id="backupViewerSection" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0" id="backupViewerTitle">
                                        <i class="bi bi-archive"></i> Backup Details
                                    </h6>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-primary" onclick="downloadBackup()" title="Download as JSON">
                                            <i class="bi bi-download"></i> Export
                                        </button>
                                        <button class="btn btn-outline-danger" onclick="deleteBackup()">
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>

                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="row">
                                            <div class="col-md-6">
                                                <strong>Name:</strong> <span id="backupName">-</span><br>
                                                <strong>Node:</strong> <span id="backupNode">-</span><br>
                                                <strong>Created:</strong> <span id="backupCreated">-</span>
                                            </div>
                                            <div class="col-md-6">
                                                <strong>Description:</strong><br>
                                                <span id="backupDescription" class="text-muted">-</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="accordion" id="backupContentsAccordion">
                                    <!-- Core Configs -->
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button" type="button" data-bs-toggle="collapse"
                                                    data-bs-target="#coreConfigsCollapse">
                                                <i class="bi bi-gear me-2"></i> Core Configurations
                                                <span class="badge bg-primary ms-2" id="coreConfigsCount">0</span>
                                            </button>
                                        </h2>
                                        <div id="coreConfigsCollapse" class="accordion-collapse collapse show"
                                             data-bs-parent="#backupContentsAccordion">
                                            <div class="accordion-body" id="coreConfigsContent">
                                                <p class="text-muted">Select a backup to view contents</p>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Module Configs -->
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                                    data-bs-target="#moduleConfigsCollapse">
                                                <i class="bi bi-puzzle me-2"></i> Module Configurations
                                                <span class="badge bg-info ms-2" id="moduleConfigsCount">0</span>
                                            </button>
                                        </h2>
                                        <div id="moduleConfigsCollapse" class="accordion-collapse collapse"
                                             data-bs-parent="#backupContentsAccordion">
                                            <div class="accordion-body" id="moduleConfigsContent">
                                                <p class="text-muted">Select a backup to view contents</p>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Channels -->
                                    <div class="accordion-item">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                                    data-bs-target="#channelsCollapse">
                                                <i class="bi bi-broadcast me-2"></i> Channels
                                                <span class="badge bg-success ms-2" id="channelsCount">0</span>
                                            </button>
                                        </h2>
                                        <div id="channelsCollapse" class="accordion-collapse collapse"
                                             data-bs-parent="#backupContentsAccordion">
                                            <div class="accordion-body" id="channelsContent">
                                                <p class="text-muted">Select a backup to view contents</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Restore Section -->
                                <div class="card mt-3 border-warning">
                                    <div class="card-header bg-warning-subtle">
                                        <i class="bi bi-exclamation-triangle"></i> Restore to Node
                                    </div>
                                    <div class="card-body">
                                        <p class="small text-muted mb-2">
                                            Restoring will apply this backup's configuration to the selected node.
                                            This is a potentially destructive operation.
                                        </p>
                                        <div class="row g-2">
                                            <div class="col-md-8">
                                                <select class="form-select form-select-sm" id="restoreTargetNode">
                                                    <option value="">Select target node...</option>
                                                    {% for node in administrable_nodes %}
                                                    <option value="{{ node.node_id }}">
                                                        {{ node.long_name or node.short_name or node.hex_id }}
                                                    </option>
                                                    {% endfor %}
                                                </select>
                                            </div>
                                            <div class="col-md-4">
                                                <button class="btn btn-warning btn-sm w-100" onclick="restoreBackup()"
                                                        id="restoreBackupBtn" disabled>
                                                    <i class="bi bi-arrow-counterclockwise"></i> Restore
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- No Backup Selected Placeholder -->
                            <div id="noBackupSelected" class="text-center py-5 text-muted">
                                <i class="bi bi-cloud-download" style="font-size: 3rem;"></i>
                                <p class="mt-3">Select a backup to view its contents,<br>or create a new backup from a node.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Background Jobs Tab -->
                <div class="tab-pane fade" id="jobs-pane" role="tabpanel">
                    <div class="row">
                        <div class="col-lg-8">
                            <div class="card mb-3">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <span><i class="bi bi-list-task me-2"></i> Background Jobs</span>
                                    <button class="btn btn-outline-primary btn-sm" onclick="refreshJobsList()">
                                        <i class="bi bi-arrow-clockwise"></i> Refresh
                                    </button>
                                </div>
                                <div class="card-body">
                                    <p class="text-muted small mb-3">
                                        Background jobs run on the server and continue even if you close the browser.
                                        You can start a job and come back later to check the result.
                                    </p>
                                    <div id="jobsListContainer">
                                        <div class="text-center py-3 text-muted">
                                            <i class="bi bi-hourglass me-2"></i>
                                            Loading jobs...
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-lg-4">
                            <div class="card">
                                <div class="card-header">
                                    <i class="bi bi-info-circle me-2"></i> Job Queue Status
                                </div>
                                <div class="card-body">
                                    <div id="jobQueueStatus">
                                        <div class="d-flex justify-content-between mb-2">
                                            <span>Running:</span>
                                            <span class="badge bg-primary" id="runningJobsCount">0</span>
                                        </div>
                                        <div class="d-flex justify-content-between mb-2">
                                            <span>Queued:</span>
                                            <span class="badge bg-secondary" id="queuedJobsCount">0</span>
                                        </div>
                                        <hr>
                                        <p class="small text-muted mb-0">
                                            Jobs for the same node run sequentially to prevent conflicts.
                                            Jobs for different nodes can run in parallel.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Audit Log Tab -->
                <div class="tab-pane fade" id="log-pane" role="tabpanel">
                    <div class="mb-3">
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshLog()">
                            <i class="bi bi-arrow-clockwise"></i> Refresh
                        </button>
                    </div>
                    <div id="auditLogContainer">
                        <div class="text-center py-3">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Job Details Modal -->
<div class="modal fade" id="jobDetailsModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-list-task me-2"></i>
                    <span id="jobDetailsTitle">Job Details</span>
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="jobDetailsBody">
                <div class="text-center py-4">
                    <div class="spinner-border text-primary" role="status"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-outline-success d-none" id="jobDetailsResumeBtn" onclick="resumeJobFromModal()">
                    <i class="bi bi-play-fill me-1"></i> Resume
                </button>
                <button type="button" class="btn btn-outline-warning d-none" id="jobDetailsPauseBtn" onclick="pauseJobFromModal()">
                    <i class="bi bi-pause-fill me-1"></i> Pause
                </button>
                <button type="button" class="btn btn-outline-danger d-none" id="jobDetailsCancelBtn" onclick="cancelJobFromModal()">
                    <i class="bi bi-x-circle me-1"></i> Cancel
                </button>
                <button type="button" class="btn btn-danger d-none" id="jobDetailsForceCancelBtn" onclick="forceCancelJobFromModal()" title="Force cancel this job (use if job is stuck)">
                    <i class="bi bi-exclamation-triangle me-1"></i> Force Cancel
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Confirmation Modal -->
<div class="modal fade" id="confirmModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="confirmModalTitle">Confirm Action</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="confirmModalBody">
                Are you sure?
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmModalBtn">Confirm</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Template from Node Modal -->
<div class="modal fade" id="createFromNodeModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-download"></i> Create Template from Node
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-3">
                    Extract the current configuration from an existing node to use as a template.
                    Node-specific settings (like location, credentials, etc.) will be automatically removed.
                </p>

                <!-- Step 1: Select Node and Config Type -->
                <div id="extractStep1">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Source Node</label>
                            <select class="form-select" id="extractSourceNode">
                                <option value="">Select an administrable node...</option>
                            </select>
                            <div class="form-text">Select a node to extract config from</div>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Config Type</label>
                            <select class="form-select" id="extractConfigType">
                                <option value="device">Device</option>
                                <option value="lora" selected>LoRa</option>
                                <option value="position">Position</option>
                                <option value="power">Power</option>
                                <option value="network">Network</option>
                                <option value="display">Display</option>
                                <option value="bluetooth">Bluetooth</option>
                                <option value="security">Security</option>
                                <option value="channel">Channel (Single)</option>
                                <option value="channels">Channels (Full Set)</option>
                            </select>
                        </div>
                    </div>
                    <div class="mb-3" id="channelIndexRow" style="display: none;">
                        <label class="form-label">Channel Index</label>
                        <select class="form-select" id="extractChannelIndex">
                            <option value="0">Primary (0)</option>
                            <option value="1">Secondary (1)</option>
                            <option value="2">Channel 2</option>
                            <option value="3">Channel 3</option>
                            <option value="4">Channel 4</option>
                            <option value="5">Channel 5</option>
                            <option value="6">Channel 6</option>
                            <option value="7">Channel 7</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="extractConfigFromNode()" id="extractConfigBtn">
                        <i class="bi bi-cloud-download"></i> Extract Configuration
                    </button>

                    <!-- Real-time extraction progress -->
                    <div id="extractionProgress" class="mt-3" style="display: none;">
                        <div class="card bg-light">
                            <div class="card-body py-2">
                                <div class="d-flex align-items-center mb-2">
                                    <span class="spinner-border spinner-border-sm text-primary me-2"></span>
                                    <strong id="extractionStatus">Connecting to node...</strong>
                                </div>
                                <div class="progress" style="height: 8px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated"
                                         role="progressbar"
                                         id="extractionProgressBar"
                                         style="width: 0%"></div>
                                </div>
                                <small class="text-muted mt-1 d-block" id="extractionDetails"></small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Review and Name -->
                <div id="extractStep2" style="display: none;">
                    <div class="alert alert-success mb-3">
                        <i class="bi bi-check-circle"></i>
                        Configuration extracted successfully from node <strong id="extractedFromNode"></strong>
                    </div>

                    <div id="excludedFieldsWarning" class="alert alert-info mb-3" style="display: none;">
                        <i class="bi bi-info-circle"></i>
                        <strong>Note:</strong> The following node-specific fields were removed:
                        <code id="excludedFieldsList"></code>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Template Name</label>
                        <input type="text" class="form-control" id="extractTemplateName"
                               placeholder="e.g., Standard LoRa Settings">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Description (optional)</label>
                        <input type="text" class="form-control" id="extractTemplateDescription"
                               placeholder="Describe what this template is for">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Extracted Configuration</label>
                        <textarea class="form-control font-monospace" id="extractedConfigData" rows="10" readonly></textarea>
                        <div class="form-text">
                            You can edit this configuration after creating the template.
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-outline-secondary" id="extractBackBtn" style="display: none;"
                        onclick="resetExtractModal()">
                    <i class="bi bi-arrow-left"></i> Back
                </button>
                <button type="button" class="btn btn-success" id="saveExtractedTemplateBtn" style="display: none;"
                        onclick="saveExtractedTemplate()">
                    <i class="bi bi-save"></i> Create Template
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Create Backup Modal -->
<div class="modal fade" id="createBackupModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-cloud-download"></i> Create Node Backup
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-3">
                    Create a full backup of a node's configuration including all core configs,
                    module configs, and channels. This can be used to restore the node later.
                </p>

                <div class="mb-3">
                    <label class="form-label">Source Node</label>
                    <select class="form-select" id="backupSourceNode">
                        <option value="">Select an administrable node...</option>
                        {% for node in administrable_nodes %}
                        <option value="{{ node.node_id }}" data-hex="{{ node.hex_id }}"
                                data-name="{{ node.long_name or node.short_name or 'Unknown' }}">
                            {{ node.long_name or node.short_name or node.hex_id }}
                            ({{ node.hex_id or ('!' + '%08x'|format(node.node_id)) }})
                        </option>
                        {% endfor %}
                    </select>
                </div>

                <div class="mb-3">
                    <label class="form-label">Backup Name</label>
                    <input type="text" class="form-control" id="backupNameInput"
                           placeholder="e.g., My Node - Pre-Update Backup">
                    <div class="form-text">A descriptive name for this backup</div>
                </div>

                <div class="mb-3">
                    <label class="form-label">Description (optional)</label>
                    <textarea class="form-control" id="backupDescriptionInput" rows="2"
                              placeholder="e.g., Backup before firmware update to 2.5.0"></textarea>
                </div>

                <!-- Timing Settings -->
                <div class="mb-3">
                    <a class="text-decoration-none small" data-bs-toggle="collapse" href="#backupTimingSettings" role="button">
                        <i class="bi bi-gear"></i> Advanced Timing Settings
                    </a>
                    <div class="collapse mt-2" id="backupTimingSettings">
                        <div class="card card-body bg-light py-2">
                            <label class="form-label small">Request Delay Mode</label>
                            <select class="form-select form-select-sm" id="backupDelayMode" onchange="updateBackupDelayUI()">
                                <option value="auto" selected>Auto (based on hop count)</option>
                                <option value="fast">Fast (0s - for direct connections)</option>
                                <option value="normal">Normal (1.5s - for most mesh nodes)</option>
                                <option value="slow">Slow (3s - for distant nodes)</option>
                                <option value="custom">Custom...</option>
                            </select>
                            <div class="form-text small">Delay between config requests to prevent mesh congestion.</div>
                            <div class="mt-2 d-none" id="backupCustomDelayGroup">
                                <label class="form-label small">Custom Delay (seconds)</label>
                                <input type="number" class="form-control form-control-sm" id="backupCustomDelay"
                                       min="0" max="10" step="0.5" value="1.5" style="width: 100px;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Progress Section -->
                <div id="backupProgressSection" style="display: none;">
                    <div class="card bg-light">
                        <div class="card-body py-2">
                            <div class="d-flex align-items-center mb-2">
                                <span class="spinner-border spinner-border-sm text-primary me-2" id="backupSpinner"></span>
                                <strong id="backupProgressStatus">Starting backup...</strong>
                            </div>
                            <div class="progress" style="height: 8px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated"
                                     role="progressbar"
                                     id="backupProgressBar"
                                     style="width: 0%"></div>
                            </div>
                            <small class="text-muted mt-1 d-block" id="backupProgressDetails"></small>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="startBackupJobBtn" onclick="startBackupJob()"
                        title="Create backup as a background job">
                    <i class="bi bi-cloud-download"></i> Create Backup
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Restore Backup Modal -->
<div class="modal fade" id="restoreBackupModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-warning-subtle">
                <h5 class="modal-title">
                    <i class="bi bi-arrow-counterclockwise"></i> Restore Backup to Node
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" id="restoreModalClose"></button>
            </div>
            <div class="modal-body">
                <!-- Pre-Restore Configuration (shown before restore starts) -->
                <div id="restoreConfigSection">
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i>
                        <strong>Warning:</strong> This will overwrite the target node's configuration with the backup data.
                        Make sure you understand the implications before proceeding.
                    </div>

                    <div class="card mb-3">
                        <div class="card-body">
                            <h6><i class="bi bi-info-circle"></i> Backup Details</h6>
                            <table class="table table-sm mb-0">
                                <tr><td><strong>Name:</strong></td><td id="restoreBackupName">-</td></tr>
                                <tr><td><strong>Original Node:</strong></td><td id="restoreOriginalNode">-</td></tr>
                                <tr><td><strong>Created:</strong></td><td id="restoreBackupCreated">-</td></tr>
                            </table>
                        </div>
                    </div>

                    <div class="card mb-3">
                        <div class="card-body">
                            <h6><i class="bi bi-sliders"></i> Restore Options</h6>

                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="restoreSkipLora">
                                <label class="form-check-label" for="restoreSkipLora">
                                    <strong>Skip LoRa Configuration</strong>
                                    <small class="text-muted d-block">Keep current radio settings (frequency, bandwidth, etc.) even if selected below</small>
                                </label>
                            </div>

                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="restoreSkipSecurity" checked>
                                <label class="form-check-label" for="restoreSkipSecurity">
                                    <strong>Skip Security Configuration</strong>
                                    <small class="text-muted d-block">Recommended: Keep current admin keys to maintain access</small>
                                </label>
                            </div>

                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="restoreRebootAfter">
                                <label class="form-check-label" for="restoreRebootAfter">
                                    <strong>Reboot Node After Restore</strong>
                                    <small class="text-muted d-block">Required for some settings to take effect</small>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Selective Restore Configuration -->
                    <div class="card mb-3">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h6 class="mb-0"><i class="bi bi-list-check"></i> Select What to Restore</h6>
                            <div>
                                <button type="button" class="btn btn-sm btn-outline-secondary me-1" onclick="selectAllRestoreItems(true)">
                                    <i class="bi bi-check-all"></i> Select All
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-secondary" onclick="selectAllRestoreItems(false)">
                                    <i class="bi bi-x"></i> Deselect All
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <!-- Core Configs Section -->
                            <div class="mb-3">
                                <div class="d-flex align-items-center mb-2">
                                    <input class="form-check-input me-2" type="checkbox" id="restoreSelectAllCore" onchange="toggleRestoreCategory('core', this.checked)">
                                    <strong class="text-primary">
                                        <i class="bi bi-gear"></i> Core Configs
                                        <span id="restoreCoreCount" class="badge bg-primary ms-1">0</span>
                                    </strong>
                                    <button type="button" class="btn btn-link btn-sm ms-auto p-0" data-bs-toggle="collapse" data-bs-target="#restoreCoreConfigsList">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <div class="collapse" id="restoreCoreConfigsList">
                                    <div class="ms-4 ps-1 border-start" id="restoreCoreConfigsContainer">
                                        <!-- Dynamically populated -->
                                    </div>
                                </div>
                            </div>

                            <!-- Module Configs Section -->
                            <div class="mb-3">
                                <div class="d-flex align-items-center mb-2">
                                    <input class="form-check-input me-2" type="checkbox" id="restoreSelectAllModules" onchange="toggleRestoreCategory('module', this.checked)">
                                    <strong class="text-info">
                                        <i class="bi bi-puzzle"></i> Module Configs
                                        <span id="restoreModuleCount" class="badge bg-info ms-1">0</span>
                                    </strong>
                                    <button type="button" class="btn btn-link btn-sm ms-auto p-0" data-bs-toggle="collapse" data-bs-target="#restoreModuleConfigsList">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <div class="collapse" id="restoreModuleConfigsList">
                                    <div class="ms-4 ps-1 border-start" id="restoreModuleConfigsContainer">
                                        <!-- Dynamically populated -->
                                    </div>
                                </div>
                            </div>

                            <!-- Channels Section -->
                            <div>
                                <div class="d-flex align-items-center mb-2">
                                    <input class="form-check-input me-2" type="checkbox" id="restoreSelectAllChannels" onchange="toggleRestoreCategory('channel', this.checked)">
                                    <strong class="text-success">
                                        <i class="bi bi-broadcast"></i> Channels
                                        <span id="restoreChannelCount" class="badge bg-success ms-1">0</span>
                                    </strong>
                                    <button type="button" class="btn btn-link btn-sm ms-auto p-0" data-bs-toggle="collapse" data-bs-target="#restoreChannelsList">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <div class="collapse" id="restoreChannelsList">
                                    <div class="ms-4 ps-1 border-start" id="restoreChannelsContainer">
                                        <!-- Dynamically populated -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-footer bg-light">
                            <small class="text-muted">
                                <i class="bi bi-info-circle"></i>
                                Selected: <span id="restoreSelectedCount" class="fw-bold">0</span> items
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Restore Progress Section (shown during restore) -->
                <div id="restoreProgressSection" style="display: none;">
                    <div class="card">
                        <div class="card-body">
                            <div class="d-flex align-items-center mb-3">
                                <span class="spinner-border spinner-border-sm text-warning me-2" id="restoreSpinner"></span>
                                <strong id="restoreProgressStatus">Starting restore...</strong>
                            </div>

                            <div class="progress mb-2" style="height: 20px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated bg-warning"
                                     role="progressbar"
                                     id="restoreProgressBar"
                                     style="width: 0%">0%</div>
                            </div>

                            <div class="mb-3">
                                <small class="text-muted" id="restoreProgressDetails">Initializing...</small>
                            </div>

                            <!-- Restore Log -->
                            <div class="bg-dark text-light rounded p-2" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.8rem;" id="restoreLogContainer">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Restore Complete Section (shown after restore) -->
                <div id="restoreCompleteSection" style="display: none;">
                    <div class="text-center py-4">
                        <i class="bi bi-check-circle-fill text-success" style="font-size: 4rem;" id="restoreSuccessIcon"></i>
                        <i class="bi bi-x-circle-fill text-danger" style="font-size: 4rem; display: none;" id="restoreFailIcon"></i>
                        <h4 class="mt-3" id="restoreCompleteTitle">Restore Complete</h4>
                        <p class="text-muted" id="restoreCompleteMessage">Configuration has been restored successfully.</p>
                    </div>

                    <div class="row" id="restoreResultsSummary">
                        <div class="col-md-6">
                            <div class="card border-success mb-2">
                                <div class="card-body py-2">
                                    <strong class="text-success">Successful:</strong>
                                    <span id="restoreSuccessCount" class="badge bg-success">0</span>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card border-danger mb-2">
                                <div class="card-body py-2">
                                    <strong class="text-danger">Failed:</strong>
                                    <span id="restoreFailCount" class="badge bg-danger">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="restoreErrorDetails" style="display: none;" class="mt-3">
                        <h6 class="text-danger">Failed Items:</h6>
                        <ul class="list-group list-group-flush small" id="restoreErrorList"></ul>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="restoreCancelBtn">Cancel</button>
                <button type="button" class="btn btn-warning" id="startRestoreJobBtn" onclick="startRestoreJob()"
                        title="Restore backup as a background job">
                    <i class="bi bi-arrow-counterclockwise"></i> Start Restore
                </button>
                <button type="button" class="btn btn-primary" id="restoreDoneBtn" style="display: none;" data-bs-dismiss="modal">
                    <i class="bi bi-check"></i> Done
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/job-manager.js') }}"></script>
<script>
    let selectedNodeId = null;
    let currentConfigType = null;
    let currentConfigData = null;
    let currentConfigSchema = null;
    let searchTimeout = null;
    let cachedNodes = null;
    let adminStatusTimeout = null;
    let lastCheckedNodeId = null;

    // Global job manager instance
    let jobManager = null;
    let jobsPollingInterval = null;

    // ============================================================================
    // Admin Status Checking
    // ============================================================================

    // Debounced function to check admin status when typing
    function checkAdminStatusDebounced() {
        if (adminStatusTimeout) {
            clearTimeout(adminStatusTimeout);
        }
        adminStatusTimeout = setTimeout(() => {
            const nodeId = document.getElementById('targetNodeInput').value.trim();
            if (nodeId && nodeId.length >= 3) {
                checkAdminStatus(nodeId);
            } else {
                hideAdminStatusBanner();
            }
        }, 500);
    }

    // Check admin status for a node
    async function checkAdminStatus(nodeId) {
        // Don't re-check the same node
        if (nodeId === lastCheckedNodeId) {
            return;
        }
        lastCheckedNodeId = nodeId;

        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Show loading state
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');
        banner.classList.add('status-warning');
        iconEl.className = 'status-icon bi bi-hourglass-split text-warning';
        messageEl.textContent = 'Checking admin channel status...';
        detailsEl.innerHTML = '';
        suggestionsEl.innerHTML = '';

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/status`);
            const data = await response.json();

            if (data.error) {
                showAdminStatusError(data.error);
                return;
            }

            displayAdminStatus(data);
        } catch (error) {
            showAdminStatusError(error.message);
        }
    }

    // Refresh admin status for current node
    function refreshAdminStatus() {
        lastCheckedNodeId = null; // Force refresh
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (nodeId) {
            checkAdminStatus(nodeId);
        }
    }

    // Display admin status in the banner
    function displayAdminStatus(status) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Reset classes
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');

        // Set status level styling
        const level = status.status_level || 'warning';
        banner.classList.add(`status-${level}`);

        // Set icon
        if (level === 'success') {
            iconEl.className = 'status-icon bi bi-check-circle-fill text-success';
        } else if (level === 'warning') {
            iconEl.className = 'status-icon bi bi-exclamation-triangle-fill text-warning';
        } else {
            iconEl.className = 'status-icon bi bi-x-circle-fill text-danger';
        }

        // Set message
        messageEl.textContent = status.status_message || 'Unknown status';

        // Build checks display
        let checksHtml = '';
        if (status.checks && status.checks.length > 0) {
            for (const check of status.checks) {
                const checkClass = check.passed ? 'check-passed' : 'check-failed';
                const checkIcon = check.passed ? 'bi-check-circle-fill' : 'bi-x-circle-fill';
                checksHtml += `
                    <div class="check-item ${checkClass}">
                        <i class="bi ${checkIcon}"></i>
                        <span>${escapeHtml(check.message)}</span>
                    </div>
                `;
            }
        }
        detailsEl.innerHTML = checksHtml;

        // Build suggestions display
        let suggestionsHtml = '';
        if (status.suggestions && status.suggestions.length > 0) {
            for (const suggestion of status.suggestions) {
                suggestionsHtml += `
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        ${escapeHtml(suggestion)}
                    </div>
                `;
            }
        }

        // Add test button if node is not administrable
        const nodeAdminCheck = status.checks?.find(c => c.name === 'node_administrable');
        if (nodeAdminCheck && !nodeAdminCheck.passed) {
            suggestionsHtml += `
                <div class="mt-2">
                    <button class="btn btn-sm btn-outline-primary" onclick="testCurrentNode()">
                        <i class="bi bi-lightning"></i> Test Admin Access Now
                    </button>
                </div>
            `;
        }

        suggestionsEl.innerHTML = suggestionsHtml;
        if (!suggestionsHtml) {
            suggestionsEl.classList.add('d-none');
        } else {
            suggestionsEl.classList.remove('d-none');
        }
    }

    // Show error in admin status banner
    function showAdminStatusError(errorMessage) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        banner.classList.remove('d-none', 'status-success', 'status-warning');
        banner.classList.add('status-danger');
        iconEl.className = 'status-icon bi bi-exclamation-octagon-fill text-danger';
        messageEl.textContent = 'Error checking admin status';
        detailsEl.innerHTML = `<span class="text-danger">${escapeHtml(errorMessage)}</span>`;
        suggestionsEl.innerHTML = '';
    }

    // Update admin status banner with a simple message (for reboot/shutdown status)
    function updateAdminStatusBanner(level, message, details) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        if (!banner) return;

        // Reset classes
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');
        banner.classList.add(`status-${level}`);

        // Set icon based on level
        if (level === 'success') {
            iconEl.className = 'status-icon bi bi-check-circle-fill text-success';
        } else if (level === 'warning') {
            iconEl.className = 'status-icon bi bi-hourglass-split text-warning';
        } else {
            iconEl.className = 'status-icon bi bi-x-circle-fill text-danger';
        }

        messageEl.textContent = message || '';
        detailsEl.innerHTML = details ? `<span class="text-muted">${escapeHtml(details)}</span>` : '';
        suggestionsEl.innerHTML = '';
        suggestionsEl.classList.add('d-none');
    }

    // Hide admin status banner
    function hideAdminStatusBanner() {
        const banner = document.getElementById('adminStatusBanner');
        banner.classList.add('d-none');
        lastCheckedNodeId = null;
    }

    // Test admin access for the current target node
    async function testCurrentNode() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const banner = document.getElementById('adminStatusBanner');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Show testing state
        banner.classList.remove('status-success', 'status-danger');
        banner.classList.add('status-warning');
        document.getElementById('adminStatusIcon').className = 'status-icon bi bi-hourglass-split text-warning';
        messageEl.textContent = 'Testing admin access...';
        detailsEl.innerHTML = '<div class="spinner-border spinner-border-sm text-primary" role="status"></div> Sending device metadata request...';
        suggestionsEl.innerHTML = '';

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const data = await response.json();

            if (data.success && data.administrable) {
                // Refresh status to show updated state
                lastCheckedNodeId = null;
                await checkAdminStatus(nodeId);
                showAlert('success', `Node ${data.hex_id} is administrable!`);
            } else {
                // Show failure in banner
                banner.classList.remove('status-warning');
                banner.classList.add('status-danger');
                document.getElementById('adminStatusIcon').className = 'status-icon bi bi-x-circle-fill text-danger';
                messageEl.textContent = 'Admin test failed';
                detailsEl.innerHTML = `<span class="text-danger">${escapeHtml(data.error || 'No response from node')}</span>`;
                suggestionsEl.innerHTML = `
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        Ensure the node has this server's public key configured
                    </div>
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        Check that the node is within radio range of the gateway
                    </div>
                `;
            }
        } catch (error) {
            showAdminStatusError(error.message);
        }
    }

    // ============================================================================
    // Node Autocomplete
    // ============================================================================

    async function searchNodes(query, resultsContainerId) {
        const resultsDiv = document.getElementById(resultsContainerId);

        if (!query || query.length < 1) {
            hideAutocomplete(resultsContainerId);
            return;
        }

        // Use cached nodes if available, otherwise fetch
        if (!cachedNodes) {
            try {
                const response = await fetch('/api/nodes?limit=500');
                const data = await response.json();
                cachedNodes = data.nodes || [];
            } catch (error) {
                console.error('Failed to fetch nodes:', error);
                cachedNodes = [];
            }
        }

        // Filter nodes based on query
        const lowerQuery = query.toLowerCase();
        const matches = cachedNodes.filter(node => {
            const longName = (node.long_name || '').toLowerCase();
            const shortName = (node.short_name || '').toLowerCase();
            const hexId = node.hex_id ? node.hex_id.toLowerCase() : '';
            const nodeId = node.node_id ? node.node_id.toString() : '';

            return longName.includes(lowerQuery) ||
                   shortName.includes(lowerQuery) ||
                   hexId.includes(lowerQuery) ||
                   nodeId.includes(lowerQuery);
        }).slice(0, 10); // Limit to 10 results

        if (matches.length === 0) {
            hideAutocomplete(resultsContainerId);
            return;
        }

        // Build results HTML
        let html = '';
        for (const node of matches) {
            const displayName = node.long_name || node.short_name || 'Unknown';
            const hexId = node.hex_id || `!${(node.node_id >>> 0).toString(16).padStart(8, '0')}`;
            html += `
                <div class="node-autocomplete-item"
                     onclick="selectAutocompleteNode('${hexId}', '${resultsContainerId}')">
                    <div class="node-name">${escapeHtml(displayName)}</div>
                    <div class="node-id">${hexId}</div>
                </div>
            `;
        }

        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
    }

    function selectAutocompleteNode(nodeId, resultsContainerId) {
        // Find the input associated with this results container
        const resultsDiv = document.getElementById(resultsContainerId);
        const inputId = resultsContainerId === 'testNodeResults' ? 'testNodeInput' : 'targetNodeInput';
        const input = document.getElementById(inputId);

        input.value = nodeId;
        hideAutocomplete(resultsContainerId);

        // If it's the target node input, also store the selected node and check admin status
        if (inputId === 'targetNodeInput') {
            selectedNodeId = nodeId;
            checkAdminStatus(nodeId);
        }
    }

    function hideAutocomplete(resultsContainerId) {
        const resultsDiv = document.getElementById(resultsContainerId);
        if (resultsDiv) {
            resultsDiv.style.display = 'none';
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Refresh cached nodes
    function refreshNodeCache() {
        cachedNodes = null;
    }

    // ============================================================================
    // Connection Management
    // ============================================================================

    // Local storage keys for persisting settings
    const STORAGE_KEYS = {
        connectionType: 'malla_admin_connection_type',
        tcpHost: 'malla_admin_tcp_host',
        tcpPort: 'malla_admin_tcp_port',
        gatewayNode: 'malla_admin_gateway_node'
    };

    // Save setting to localStorage
    function saveSetting(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            console.warn('Failed to save setting to localStorage:', e);
        }
    }

    // Load setting from localStorage
    function loadSetting(key, defaultValue = '') {
        try {
            return localStorage.getItem(key) || defaultValue;
        } catch (e) {
            console.warn('Failed to load setting from localStorage:', e);
            return defaultValue;
        }
    }

    // Change connection type
    async function changeConnectionType() {
        const connType = document.getElementById('connectionTypeSelect').value;

        // Save to localStorage
        saveSetting(STORAGE_KEYS.connectionType, connType);

        // Show/hide appropriate settings
        document.getElementById('mqttSettings').classList.toggle('d-none', connType !== 'mqtt');
        document.getElementById('tcpSettings').classList.toggle('d-none', connType !== 'tcp');
        document.getElementById('serialSettings').classList.toggle('d-none', connType !== 'serial');

        // Auto-discover serial ports when switching to serial
        if (connType === 'serial') {
            discoverSerialPorts();
        }

        try {
            const response = await fetch('/api/admin/connection-type', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ connection_type: connType })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Connection type changed to ${connType.toUpperCase()}`);
                updateConnectionStatus();
            } else {
                showAlert('danger', data.error || 'Failed to change connection type');
            }
        } catch (error) {
            showAlert('danger', 'Error: ' + error.message);
        }
    }

    // TCP Connect
    async function tcpConnect() {
        const host = document.getElementById('tcpHostInput').value.trim();
        const port = parseInt(document.getElementById('tcpPortInput').value) || 4403;

        // Save TCP settings to localStorage (before connect attempt)
        saveSetting(STORAGE_KEYS.tcpHost, host);
        saveSetting(STORAGE_KEYS.tcpPort, port.toString());

        const btn = document.getElementById('tcpConnectBtn');
        const disconnectBtn = document.getElementById('tcpDisconnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');

        btn.disabled = true;
        disconnectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        // Allow auto-reconnect since user is initiating connection
        if (typeof NodeConnectionManager !== 'undefined') {
            NodeConnectionManager.allowAutoReconnect();
        }

        try {
            // Use NodeConnectionManager if available
            let success = false;
            let data = {};

            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.connectTcp(host, port);
                if (success) {
                    const state = NodeConnectionManager.getState();
                    data = {
                        success: true,
                        host: state.tcpHost,
                        port: state.tcpPort,
                        local_node_hex: state.localNodeHex
                    };
                }
            } else {
                // Fallback to direct API call
                const response = await fetch('/api/admin/tcp/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ host: host, port: port })
                });
                data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                let nodeInfo = data.local_node_hex || '';
                if (data.local_node_name) {
                    nodeInfo = `${data.local_node_name} (${data.local_node_hex})`;
                }
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Connected to ${data.host}:${data.port}` +
                    (nodeInfo ? ` - ${nodeInfo}` : '');
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Failed to connect'}`;
                // Re-enable connect button on failure
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            // Re-enable connect button on error
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
        }

        // Restore button text (state will be set by updateConnectionStatus)
        btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
    }

    // TCP Disconnect
    async function tcpDisconnect() {
        const btn = document.getElementById('tcpDisconnectBtn');
        const connectBtn = document.getElementById('tcpConnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');

        btn.disabled = true;
        connectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Disconnecting...';

        try {
            let success = false;

            // Use NodeConnectionManager if available (this marks as user-disconnected)
            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.disconnect();
            } else {
                const response = await fetch('/api/admin/tcp/disconnect', {
                    method: 'POST'
                });
                const data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = '<i class="bi bi-check-circle"></i> Disconnected';
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Failed to disconnect`;
                // Re-enable disconnect button on failure
                btn.disabled = false;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            // Re-enable disconnect button on error
            btn.disabled = false;
        }

        // Restore button text (state will be set by updateConnectionStatus)
        btn.innerHTML = '<i class="bi bi-x-circle"></i> Disconnect';
    }

    // TCP Reconnect - force reconnection for stale connections
    async function tcpReconnect() {
        const reconnectBtn = document.getElementById('tcpReconnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');
        const healthWarning = document.getElementById('tcpHealthWarning');

        if (reconnectBtn) {
            reconnectBtn.disabled = true;
            reconnectBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Reconnecting...';
        }

        try {
            const response = await fetch('/api/admin/tcp/reconnect', {
                method: 'POST'
            });
            const data = await response.json();

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');
            healthWarning.classList.add('d-none');

            if (data.success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Reconnected to ${data.host}:${data.port}`;
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Reconnection failed'}`;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
        } finally {
            if (reconnectBtn) {
                reconnectBtn.disabled = false;
                reconnectBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Reconnect';
            }
        }
    }

    // Check TCP connection health and show warning if stale
    async function checkTcpHealth() {
        try {
            const statusResponse = await fetch('/api/admin/status');
            const status = await statusResponse.json();

            // Only check health if we're using TCP and supposedly connected
            if (status.connection_type !== 'tcp' || !status.connected) {
                return;
            }

            const healthResponse = await fetch('/api/admin/tcp/health');
            const health = await healthResponse.json();

            const healthWarning = document.getElementById('tcpHealthWarning');
            const healthText = document.getElementById('tcpHealthWarningText');

            if (health.healthy === false && health.connected) {
                // Connection is stale
                healthWarning.classList.remove('d-none');
                healthText.textContent = health.reason || 'Connection may be stale.';
            } else {
                healthWarning.classList.add('d-none');
            }
        } catch (error) {
            console.debug('TCP health check failed:', error);
        }
    }

    // Serial Port Discovery
    async function discoverSerialPorts(probe = false) {
        const selectEl = document.getElementById('serialPortSelect');
        const infoDiv = document.getElementById('serialPortInfo');
        const discoverBtn = document.querySelector('#serialSettings button[onclick="discoverSerialPorts()"]');
        const probeBtn = document.getElementById('probeDevicesBtn');

        selectEl.disabled = true;

        // Disable both buttons during operation
        if (discoverBtn) {
            discoverBtn.disabled = true;
        }
        if (probeBtn) {
            probeBtn.disabled = true;
        }

        // Show appropriate loading state
        if (probe) {
            if (probeBtn) {
                probeBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Probing...';
            }
            selectEl.innerHTML = '<option value="">Probing devices (this may take a moment)...</option>';
        } else {
            if (discoverBtn) {
                discoverBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning...';
            }
            selectEl.innerHTML = '<option value="">Scanning ports...</option>';
        }
        infoDiv.classList.add('d-none');

        try {
            const url = probe ? '/api/admin/serial/ports?probe=true' : '/api/admin/serial/ports';
            const response = await fetch(url);
            const data = await response.json();

            // Store ports data for later reference
            window._serialPortsData = data.ports || [];

            selectEl.innerHTML = '';

            if (data.success && data.ports && data.ports.length > 0) {
                // Add placeholder
                const placeholderOpt = document.createElement('option');
                placeholderOpt.value = '';
                placeholderOpt.textContent = '-- Select a port --';
                selectEl.appendChild(placeholderOpt);

                // Add ports - confirmed/likely Meshtastic devices first
                const sortedPorts = [...data.ports].sort((a, b) => {
                    // Confirmed devices first
                    if (a.is_meshtastic_confirmed && !b.is_meshtastic_confirmed) return -1;
                    if (!a.is_meshtastic_confirmed && b.is_meshtastic_confirmed) return 1;
                    // Then likely devices
                    if (a.is_meshtastic_likely && !b.is_meshtastic_likely) return -1;
                    if (!a.is_meshtastic_likely && b.is_meshtastic_likely) return 1;
                    return 0;
                });

                for (const port of sortedPorts) {
                    const opt = document.createElement('option');
                    opt.value = port.device;

                    // Build label
                    let label = port.device;

                    // If we have device info from probing, show hardware model and name
                    if (port.device_info) {
                        const di = port.device_info;
                        if (di.hardware_model_name) {
                            label += ` - ${di.hardware_model_name}`;
                        }
                        if (di.short_name) {
                            label += ` (${di.short_name})`;
                        }
                        label += ' ✓';
                    } else if (port.chip_type) {
                        // Show chip type from VID:PID lookup
                        label += ` - ${port.chip_type}`;
                        if (port.is_meshtastic_likely) {
                            label += ' ⭐';
                        }
                    } else if (port.description && port.description !== 'n/a') {
                        label += ` - ${port.description}`;
                        if (port.is_meshtastic_likely) {
                            label += ' ⭐';
                        }
                    }

                    opt.textContent = label;
                    selectEl.appendChild(opt);
                }

                // Auto-select first confirmed/likely Meshtastic port
                const bestPort = data.ports.find(p => p.is_meshtastic_confirmed) ||
                                 data.ports.find(p => p.is_meshtastic_likely);
                if (bestPort) {
                    selectEl.value = bestPort.device;
                    showSerialPortInfo(bestPort);
                }

                // Add change handler to show port info
                selectEl.onchange = () => {
                    const selectedPort = window._serialPortsData.find(p => p.device === selectEl.value);
                    if (selectedPort) {
                        showSerialPortInfo(selectedPort);
                    } else {
                        infoDiv.classList.add('d-none');
                    }
                };
            } else {
                selectEl.innerHTML = '<option value="">No serial ports found</option>';
            }
        } catch (error) {
            selectEl.innerHTML = '<option value="">Error discovering ports</option>';
            console.error('Serial port discovery error:', error);
        }

        // Re-enable all controls
        selectEl.disabled = false;
        const discoverBtnFinal = document.querySelector('#serialSettings button[onclick="discoverSerialPorts()"]');
        const probeBtnFinal = document.getElementById('probeDevicesBtn');
        if (discoverBtnFinal) {
            discoverBtnFinal.disabled = false;
            discoverBtnFinal.innerHTML = '<i class="bi bi-search"></i> Discover';
        }
        if (probeBtnFinal) {
            probeBtnFinal.disabled = false;
            probeBtnFinal.innerHTML = '<i class="bi bi-cpu"></i> Identify';
        }
    }

    // Probe devices to identify Meshtastic hardware
    async function probeSerialDevices() {
        await discoverSerialPorts(true);
    }

    function showSerialPortInfo(port) {
        const infoDiv = document.getElementById('serialPortInfo');
        let html = `<strong>${port.device}</strong>`;

        // Show confirmed device info if available
        if (port.device_info) {
            const di = port.device_info;
            if (di.hardware_model_name) {
                html += `<br><span class="text-success"><i class="bi bi-check-circle-fill"></i> <strong>${di.hardware_model_name}</strong></span>`;
            }
            if (di.long_name) {
                html += `<br>Name: ${di.long_name}`;
            }
            if (di.short_name) {
                html += ` (${di.short_name})`;
            }
            if (di.node_hex) {
                html += `<br>Node ID: <code>${di.node_hex}</code>`;
            }
            if (di.firmware_version) {
                html += `<br>Firmware: ${di.firmware_version}`;
            }
        } else {
            // Fallback to basic info
            if (port.chip_type) {
                html += `<br>Chip: ${port.chip_type}`;
            } else if (port.description && port.description !== 'n/a') {
                html += `<br>Description: ${port.description}`;
            }
            if (port.manufacturer && port.manufacturer !== 'n/a') {
                html += `<br>Manufacturer: ${port.manufacturer}`;
            }
            if (port.vid && port.pid) {
                html += `<br>VID:PID: ${port.vid.toString(16).toUpperCase().padStart(4, '0')}:${port.pid.toString(16).toUpperCase().padStart(4, '0')}`;
            }
            if (port.is_meshtastic_likely) {
                html += `<br><span class="text-warning"><i class="bi bi-question-circle"></i> Likely Meshtastic - click "Identify Device" to confirm</span>`;
            }
        }

        infoDiv.querySelector('small').innerHTML = html;
        infoDiv.classList.remove('d-none');
    }

    // Serial Connect
    async function serialConnect() {
        const port = document.getElementById('serialPortSelect').value;

        if (!port) {
            showAlert('warning', 'Please select a serial port first');
            return;
        }

        // Save serial port to localStorage
        saveSetting('serialPort', port);

        const btn = document.getElementById('serialConnectBtn');
        const disconnectBtn = document.getElementById('serialDisconnectBtn');
        const resultDiv = document.getElementById('serialConnectResult');

        btn.disabled = true;
        disconnectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        // Allow auto-reconnect since user is initiating connection
        if (typeof NodeConnectionManager !== 'undefined') {
            NodeConnectionManager.allowAutoReconnect();
        }

        try {
            // Use NodeConnectionManager if available
            let success = false;
            let data = {};

            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.connectSerial(port);
                if (success) {
                    const state = NodeConnectionManager.getState();
                    data = {
                        success: true,
                        port: state.serialPort,
                        local_node_hex: state.localNodeHex
                    };
                }
            } else {
                // Fallback to direct API call
                const response = await fetch('/api/admin/serial/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ port: port })
                });
                data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                let nodeInfo = data.local_node_hex || '';
                if (data.local_node_name) {
                    nodeInfo = `${data.local_node_name} (${data.local_node_hex})`;
                }
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Connected to ${data.port}` +
                    (nodeInfo ? ` - ${nodeInfo}` : '');
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Failed to connect'}`;
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
        }

        btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
    }

    // Serial Disconnect
    async function serialDisconnect() {
        const btn = document.getElementById('serialDisconnectBtn');
        const connectBtn = document.getElementById('serialConnectBtn');
        const resultDiv = document.getElementById('serialConnectResult');

        btn.disabled = true;
        connectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Disconnecting...';

        try {
            let success = false;

            // Use NodeConnectionManager if available (this marks as user-disconnected)
            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.disconnect();
            } else {
                const response = await fetch('/api/admin/serial/disconnect', {
                    method: 'POST'
                });
                const data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = '<i class="bi bi-check-circle"></i> Disconnected';
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Failed to disconnect`;
                btn.disabled = false;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            btn.disabled = false;
        }

        btn.innerHTML = '<i class="bi bi-x-circle"></i> Disconnect';
    }

    // Update connection status display
    async function updateConnectionStatus() {
        try {
            const response = await fetch('/api/admin/status');
            const data = await response.json();

            const statusSpan = document.getElementById('connectionStatus');
            const tcpConnectBtn = document.getElementById('tcpConnectBtn');
            const tcpDisconnectBtn = document.getElementById('tcpDisconnectBtn');
            const serialConnectBtn = document.getElementById('serialConnectBtn');
            const serialDisconnectBtn = document.getElementById('serialDisconnectBtn');

            if (data.connected) {
                let statusText = 'Connected';
                if (data.local_node_hex) {
                    if (data.local_node_name) {
                        statusText = `Connected - ${data.local_node_name} (${data.local_node_hex})`;
                    } else {
                        statusText = `Connected (${data.local_node_hex})`;
                    }
                }
                statusSpan.innerHTML = `<span class="status-indicator status-connected"></span>${statusText}`;
                // Disable connect buttons, enable disconnect buttons
                if (tcpConnectBtn) {
                    tcpConnectBtn.disabled = true;
                    tcpConnectBtn.classList.remove('btn-success');
                    tcpConnectBtn.classList.add('btn-outline-secondary');
                }
                if (tcpDisconnectBtn) {
                    tcpDisconnectBtn.disabled = false;
                    tcpDisconnectBtn.classList.remove('btn-outline-secondary');
                    tcpDisconnectBtn.classList.add('btn-outline-danger');
                }
                if (serialConnectBtn) {
                    serialConnectBtn.disabled = true;
                    serialConnectBtn.classList.remove('btn-success');
                    serialConnectBtn.classList.add('btn-outline-secondary');
                }
                if (serialDisconnectBtn) {
                    serialDisconnectBtn.disabled = false;
                    serialDisconnectBtn.classList.remove('btn-outline-secondary');
                    serialDisconnectBtn.classList.add('btn-outline-danger');
                }
            } else {
                statusSpan.innerHTML = '<span class="status-indicator status-disconnected"></span>Disconnected';
                // Enable connect buttons, disable disconnect buttons
                if (tcpConnectBtn) {
                    tcpConnectBtn.disabled = false;
                    tcpConnectBtn.classList.remove('btn-outline-secondary');
                    tcpConnectBtn.classList.add('btn-success');
                }
                if (tcpDisconnectBtn) {
                    tcpDisconnectBtn.disabled = true;
                    tcpDisconnectBtn.classList.remove('btn-outline-danger');
                    tcpDisconnectBtn.classList.add('btn-outline-secondary');
                }
                if (serialConnectBtn) {
                    serialConnectBtn.disabled = false;
                    serialConnectBtn.classList.remove('btn-outline-secondary');
                    serialConnectBtn.classList.add('btn-success');
                }
                if (serialDisconnectBtn) {
                    serialDisconnectBtn.disabled = true;
                    serialDisconnectBtn.classList.remove('btn-outline-danger');
                    serialDisconnectBtn.classList.add('btn-outline-secondary');
                }
            }

            // Update gateway display if available
            if (data.gateway_node_hex) {
                document.getElementById('gatewayNodeDisplay').innerHTML = `<code>${data.gateway_node_hex}</code>`;
            }

            // Update the global header indicator
            if (typeof NodeConnectionManager !== 'undefined') {
                NodeConnectionManager.updateGlobalIndicator();
            }

            return data.connected;
        } catch (error) {
            console.error('Failed to update connection status:', error);
            return false;
        }
    }

    // Periodic connection status check
    let connectionCheckInterval = null;

    function startConnectionCheck() {
        // Clear any existing interval
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
        }

        // Check connection status every 10 seconds
        connectionCheckInterval = setInterval(async () => {
            await updateConnectionStatus();
            // Also check TCP health periodically
            await checkTcpHealth();
        }, 10000);
    }

    function stopConnectionCheck() {
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
            connectionCheckInterval = null;
        }
    }

    // Start connection check on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Initial status update
        updateConnectionStatus();
        // Start periodic check
        startConnectionCheck();

        // Handle tab navigation via URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const tabParam = urlParams.get('tab');
        if (tabParam) {
            const tabMap = {
                'nodes': 'nodes-tab',
                'commands': 'commands-tab',
                'templates': 'templates-tab',
                'backups': 'backups-tab',
                'jobs': 'jobs-tab',
                'log': 'log-tab'
            };
            const tabId = tabMap[tabParam];
            if (tabId) {
                const tabEl = document.getElementById(tabId);
                if (tabEl) {
                    const tab = new bootstrap.Tab(tabEl);
                    tab.show();
                }
            }
        }
    });

    // Set gateway node
    async function setGatewayNode() {
        const nodeId = document.getElementById('gatewayNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a node ID');
            return;
        }

        try {
            const response = await fetch('/api/admin/gateway', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ node_id: nodeId })
            });
            const data = await response.json();

            if (data.success) {
                // Save gateway node to localStorage
                saveSetting(STORAGE_KEYS.gatewayNode, data.gateway_node_hex || nodeId);

                document.getElementById('gatewayNodeDisplay').innerHTML =
                    `<code>${data.gateway_node_hex}</code>`;
                showAlert('success', 'Gateway node set successfully');
            } else {
                showAlert('danger', data.error || 'Failed to set gateway node');
            }
        } catch (error) {
            showAlert('danger', 'Error: ' + error.message);
        }
    }

    // Test node admin access
    async function testNodeAdmin() {
        const nodeId = document.getElementById('testNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a node ID');
            return;
        }

        const btn = document.getElementById('testNodeBtn');
        const resultDiv = document.getElementById('testNodeResult');

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Testing...';
        resultDiv.classList.add('d-none');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const data = await response.json();

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-warning', 'alert-danger');

            if (data.success && data.administrable) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> <strong>Success!</strong>
                    Node ${data.hex_id} is administrable and responded to the test request.
                    <button class="btn btn-sm btn-outline-success ms-2" onclick="location.reload()">
                        <i class="bi bi-arrow-clockwise"></i> Refresh Page
                    </button>`;
            } else {
                resultDiv.classList.add('alert-warning');
                resultDiv.innerHTML = `<i class="bi bi-exclamation-triangle"></i> <strong>Not Administrable</strong><br>
                    ${data.error || 'Node did not respond. It may not have this server\'s public key configured.'}`;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-lightning"></i> Test';
        }
    }

    // Select node for commands
    function selectNode(nodeId) {
        selectedNodeId = nodeId;
        document.getElementById('targetNodeInput').value = nodeId;

        // Switch to commands tab
        const commandsTab = document.getElementById('commands-tab');
        bootstrap.Tab.getOrCreateInstance(commandsTab).show();

        // Check admin status for the selected node
        checkAdminStatus(nodeId);

        showAlert('info', `Selected node ${nodeId} for commands`);
    }

    // Command log management (similar to reboot log)
    let commandLogLines = [];
    let commandSpinnerInterval = null;
    let commandSpinnerFrame = 0;
    const commandSpinnerFrames = ['/', '-', '\\', '|'];

    function initCommandLog() {
        commandLogLines = [];
        const container = document.getElementById('commandResponse');
        container.innerHTML = '<pre id="commandLogPre" style="margin: 0; font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></pre>';
        // Auto-switch to JSON/Log view when starting a command
        showJsonView();
    }

    function addCommandLog(message, isSpinnerLine = false) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logLine = `[${timestamp}] ${message}`;

        if (isSpinnerLine) {
            if (commandLogLines.length > 0 && commandLogLines[commandLogLines.length - 1].isSpinner) {
                commandLogLines[commandLogLines.length - 1] = { text: logLine, isSpinner: true };
            } else {
                commandLogLines.push({ text: logLine, isSpinner: true });
            }
        } else {
            commandLogLines.push({ text: logLine, isSpinner: false });
        }

        updateCommandLogDisplay();
    }

    function updateCommandLogDisplay() {
        const pre = document.getElementById('commandLogPre');
        if (!pre) return;

        const text = commandLogLines.map(line => line.text).join('\n');
        pre.textContent = text;
        pre.scrollTop = pre.scrollHeight;
    }

    function startCommandSpinner(baseMessage) {
        stopCommandSpinner();
        commandSpinnerFrame = 0;

        const updateSpinner = () => {
            const spinner = commandSpinnerFrames[commandSpinnerFrame % commandSpinnerFrames.length];
            addCommandLog(`${spinner} ${baseMessage}`, true);
            commandSpinnerFrame++;
        };

        updateSpinner();
        commandSpinnerInterval = setInterval(updateSpinner, 250);
    }

    function stopCommandSpinner() {
        if (commandSpinnerInterval) {
            clearInterval(commandSpinnerInterval);
            commandSpinnerInterval = null;
        }
    }

    function finalizeCommandLog(message, success = true) {
        stopCommandSpinner();
        if (commandLogLines.length > 0 && commandLogLines[commandLogLines.length - 1].isSpinner) {
            commandLogLines.pop();
        }
        const symbol = success ? '✓' : '✗';
        addCommandLog(`${symbol} ${message}`);
    }

    // Helper to highlight the active config button
    function highlightConfigButton(btn) {
        // Remove highlight from all config request buttons
        document.querySelectorAll('.config-req-btn').forEach(b => {
            b.classList.remove('btn-primary', 'btn-success', 'active');
            // Restore original outline style
            if (b.closest('#moduleConfigRequestBtns')) {
                b.classList.add('btn-outline-primary');
            } else if (b.closest('#channelRequestBtns')) {
                b.classList.add('btn-outline-info');
            } else {
                b.classList.add('btn-outline-secondary');
            }
        });

        // Highlight the clicked button
        if (btn) {
            btn.classList.remove('btn-outline-secondary', 'btn-outline-primary', 'btn-outline-info');
            btn.classList.add('btn-primary', 'active');
        }
    }

    // Get configuration with retry support
    async function getConfig(configType, btn = null) {
        highlightConfigButton(btn);

        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        // Get retry settings from UI if available
        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting ${configType} config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/config/${configType}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = configType;
                currentConfigData = data.config;
                currentConfigSchema = data.schema;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Config received successfully${attemptsMsg}`);

                // Render the form if we have schema
                if (data.schema && data.config) {
                    renderConfigForm(configType, data.config, data.schema);
                    showConfigForm();
                }

                // Also append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.config, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get config: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Get module configuration with retry support
    async function getModuleConfig(moduleType, btn = null) {
        highlightConfigButton(btn);

        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting ${moduleType} module config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/moduleconfig/${moduleType}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = moduleType;
                currentConfigData = data.config;
                currentConfigSchema = data.schema;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Module config received successfully${attemptsMsg}`);

                // Render the form if we have schema
                if (data.schema && data.config) {
                    renderConfigForm(moduleType, data.config, data.schema);
                    showConfigForm();
                }

                // Also append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.config, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get module config: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Render editable config form
    function renderConfigForm(configType, config, schema) {
        const container = document.getElementById('configFields');
        const configValues = config[configType] || config;

        let html = `<h6 class="mb-3"><i class="bi bi-gear"></i> ${configType.charAt(0).toUpperCase() + configType.slice(1)} Configuration</h6>`;

        for (const field of schema) {
            const value = configValues[field.name];
            const fieldId = `config_${field.name}`;

            html += `<div class="config-field">`;
            html += `<label for="${fieldId}" class="form-label">${field.label}</label>`;

            if (field.type === 'boolean') {
                html += `
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="${fieldId}"
                               name="${field.name}" ${value ? 'checked' : ''}>
                    </div>
                `;
            } else if (field.type === 'enum' && field.enum) {
                html += `<select class="form-select form-select-sm" id="${fieldId}" name="${field.name}">`;
                for (const [enumVal, enumLabel] of Object.entries(field.enum)) {
                    const selected = parseInt(enumVal) === value ? 'selected' : '';
                    html += `<option value="${enumVal}" ${selected}>${enumLabel} (${enumVal})</option>`;
                }
                html += `</select>`;
            } else if (field.type === 'number') {
                const min = field.min !== null ? `min="${field.min}"` : '';
                const max = field.max !== null ? `max="${field.max}"` : '';
                html += `
                    <div class="input-group input-group-sm">
                        <input type="number" class="form-control" id="${fieldId}"
                               name="${field.name}" value="${value !== undefined ? value : ''}"
                               ${min} ${max}>
                        ${field.unit ? `<span class="input-group-text config-field-unit">${field.unit}</span>` : ''}
                    </div>
                `;
            } else if (field.type === 'password') {
                html += `
                    <input type="text" class="form-control form-control-sm font-monospace" id="${fieldId}"
                           name="${field.name}" value="${value || ''}" placeholder="Hex key">
                `;
            } else if (field.readonly) {
                html += `
                    <input type="text" class="form-control form-control-sm" id="${fieldId}"
                           name="${field.name}" value="${value !== undefined ? value : ''}" readonly disabled>
                `;
            } else {
                html += `
                    <input type="text" class="form-control form-control-sm" id="${fieldId}"
                           name="${field.name}" value="${value !== undefined ? value : ''}">
                `;
            }

            if (field.description) {
                html += `<div class="form-text">${field.description}</div>`;
            }

            html += `</div>`;
        }

        container.innerHTML = html;
        document.getElementById('configFormActions').style.display = 'flex';
    }

    // Show/hide form vs JSON view
    function showConfigForm() {
        document.getElementById('responseViewToggle').style.display = 'block';
        document.getElementById('commandResponseForm').style.display = 'block';
        document.getElementById('commandResponse').style.display = 'none';
        updateViewToggle(true);
    }

    function hideConfigForm() {
        document.getElementById('responseViewToggle').style.display = 'none';
        document.getElementById('commandResponseForm').style.display = 'none';
        document.getElementById('commandResponse').style.display = 'block';
    }

    function showFormView() {
        document.getElementById('commandResponseForm').style.display = 'block';
        document.getElementById('commandResponse').style.display = 'none';
        updateViewToggle(true);
    }

    function showJsonView() {
        document.getElementById('commandResponseForm').style.display = 'none';
        document.getElementById('commandResponse').style.display = 'block';
        updateViewToggle(false);
    }

    function updateViewToggle(formActive) {
        const buttons = document.querySelectorAll('#responseViewToggle .btn');
        buttons[0].classList.toggle('active', formActive);
        buttons[1].classList.toggle('active', !formActive);
    }

    // Save config changes
    async function saveConfig() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId || !currentConfigType || !currentConfigSchema) {
            alert('No configuration loaded to save');
            return;
        }

        // Collect form values
        const formData = {};
        for (const field of currentConfigSchema) {
            const element = document.getElementById(`config_${field.name}`);
            if (!element || field.readonly) continue;

            if (field.type === 'boolean') {
                formData[field.name] = element.checked;
            } else if (field.type === 'enum' || field.type === 'number') {
                formData[field.name] = parseInt(element.value);
            } else {
                formData[field.name] = element.value;
            }
        }

        showAlert('info', 'Saving configuration...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/config/${currentConfigType}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `${currentConfigType} configuration saved successfully!`);
                showCommandResponse(JSON.stringify({saved: formData, message: data.message}, null, 2));
            } else {
                showAlert('danger', `Failed to save: ${data.error}`);
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Refresh current config
    async function refreshConfig() {
        if (currentConfigType) {
            await getConfig(currentConfigType);
        }
    }

    // Get channel with retry support
    async function getChannel(channelIndex, btn = null) {
        highlightConfigButton(btn);

        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting channel ${channelIndex} config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/channel/${channelIndex}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = 'channel';
                currentConfigData = data.channel;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Channel received successfully${attemptsMsg}`);

                // Render channel form
                renderChannelForm(channelIndex, data.channel);
                showConfigForm();

                // Append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.channel, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get channel: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Render channel edit form
    function renderChannelForm(channelIndex, channel) {
        const container = document.getElementById('configFields');

        const roleOptions = {
            0: 'DISABLED',
            1: 'PRIMARY',
            2: 'SECONDARY'
        };

        const settings = channel.settings || {};
        const moduleSettings = settings.module_settings || {};

        let html = `
            <h6 class="mb-3"><i class="bi bi-broadcast"></i> Channel ${channelIndex} Configuration</h6>
            <input type="hidden" id="channel_index" value="${channelIndex}">

            <div class="config-field">
                <label class="form-label">Channel Role</label>
                <select class="form-select form-select-sm" id="channel_role" name="role">
                    ${Object.entries(roleOptions).map(([val, label]) =>
                        `<option value="${val}" ${parseInt(val) === channel.role ? 'selected' : ''}>${label}</option>`
                    ).join('')}
                </select>
            </div>

            <div class="config-field">
                <label class="form-label">Channel Name</label>
                <input type="text" class="form-control form-control-sm" id="channel_name"
                       name="name" value="${settings.name || ''}">
                <div class="form-text">Display name for this channel</div>
            </div>

            <div class="config-field">
                <label class="form-label">Pre-Shared Key (PSK)</label>
                <input type="text" class="form-control form-control-sm font-monospace" id="channel_psk"
                       name="psk" value="${settings.psk || ''}" placeholder="Hex encoded key">
                <div class="form-text">Encryption key in hexadecimal format</div>
            </div>

            <div class="config-field">
                <label class="form-label">Position Precision</label>
                <input type="number" class="form-control form-control-sm" id="channel_position_precision"
                       name="position_precision" value="${moduleSettings.position_precision || 0}"
                       min="0" max="32">
                <div class="form-text">Bits of precision (0=full, 32=no location)</div>
            </div>
        `;

        container.innerHTML = html;

        // Override save button for channels
        document.getElementById('configFormActions').style.display = 'flex';
        currentConfigSchema = [{name: 'role'}, {name: 'name'}, {name: 'psk'}, {name: 'position_precision'}];
    }

    // Override saveConfig for channels
    const originalSaveConfig = saveConfig;
    saveConfig = async function() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId || !currentConfigType) {
            alert('No configuration loaded to save');
            return;
        }

        if (currentConfigType === 'channel') {
            await saveChannel();
        } else {
            // Collect form values
            const formData = {};
            for (const field of currentConfigSchema) {
                const element = document.getElementById(`config_${field.name}`);
                if (!element || field.readonly) continue;

                if (field.type === 'boolean') {
                    formData[field.name] = element.checked;
                } else if (field.type === 'enum' || field.type === 'number') {
                    formData[field.name] = parseInt(element.value);
                } else {
                    formData[field.name] = element.value;
                }
            }

            showAlert('info', 'Saving configuration...');

            try {
                const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/config/${currentConfigType}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                const data = await response.json();

                if (data.success) {
                    showAlert('success', `${currentConfigType} configuration saved successfully!`);
                    showCommandResponse(JSON.stringify({saved: formData, message: data.message}, null, 2));
                } else {
                    showAlert('danger', `Failed to save: ${data.error}`);
                }
            } catch (error) {
                showAlert('danger', `Error: ${error.message}`);
            }
        }
    };

    // Save channel
    async function saveChannel() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        const channelIndex = parseInt(document.getElementById('channel_index').value);

        const channelData = {
            role: parseInt(document.getElementById('channel_role').value),
            name: document.getElementById('channel_name').value,
            psk: document.getElementById('channel_psk').value,
            position_precision: parseInt(document.getElementById('channel_position_precision').value) || 0
        };

        showAlert('info', 'Saving channel configuration...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/channel/${channelIndex}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(channelData)
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Channel ${channelIndex} saved successfully!`);
                showCommandResponse(JSON.stringify({saved: channelData, message: data.message}, null, 2));
            } else {
                showAlert('danger', `Failed to save channel: ${data.error}`);
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Get node config shortcut from nodes table
    async function getNodeConfig(nodeId, configType) {
        document.getElementById('targetNodeInput').value = nodeId;

        // Switch to commands tab
        const commandsTab = document.getElementById('commands-tab');
        bootstrap.Tab.getOrCreateInstance(commandsTab).show();

        await getConfig(configType);
    }

    // Format uptime seconds to human readable string
    function formatUptimeSeconds(seconds) {
        if (!seconds || seconds <= 0) return '—';

        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);

        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0 || parts.length === 0) parts.push(`${minutes}m`);

        return parts.join(' ');
    }

    // Format datetime for admin confirmed time (respects timezone preference)
    function formatAdminDateTime(date) {
        if (!date) date = new Date();

        // Use formatTimestamp if available (from timezone-utils.js)
        if (typeof formatTimestamp === 'function') {
            const timestamp = Math.floor(date.getTime() / 1000);
            return formatTimestamp(timestamp, 'datetime');
        }

        // Fallback: format as YYYY-MM-DD HH:MM:SS (matching the database format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // Refresh node admin info - tests admin access and fetches metadata + telemetry
    async function refreshNodeAdminInfo(nodeId) {
        const refreshBtn = document.getElementById(`admin-node-refresh-btn-${nodeId}`);
        const statusCell = document.getElementById(`admin-node-status-${nodeId}`);
        const fwCell = document.getElementById(`admin-node-fw-${nodeId}`);
        const hwCell = document.getElementById(`admin-node-hw-${nodeId}`);
        const capsCell = document.getElementById(`admin-node-caps-${nodeId}`);
        const uptimeCell = document.getElementById(`admin-node-uptime-${nodeId}`);
        const confirmedCell = document.getElementById(`admin-node-confirmed-${nodeId}`);

        // Show loading state
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
        }
        if (statusCell) {
            statusCell.innerHTML = '<span class="badge bg-warning text-dark"><i class="bi bi-hourglass-split"></i> Testing...</span>';
        }

        try {
            // Fetch telemetry data in parallel with admin test
            const [adminResponse, telemetryResponse] = await Promise.all([
                fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, { method: 'POST' }),
                fetch(`/api/node/${encodeURIComponent(nodeId)}/telemetry`)
            ]);

            const data = await adminResponse.json();
            const telemetryData = await telemetryResponse.json();

            // Update uptime from telemetry if available
            if (uptimeCell && telemetryData.telemetry) {
                const dm = telemetryData.telemetry.device_metrics;
                if (dm && dm.uptime_seconds) {
                    uptimeCell.innerHTML = `<span class="text-muted small" title="${dm.uptime_seconds} seconds">${formatUptimeSeconds(dm.uptime_seconds)}</span>`;
                } else {
                    uptimeCell.innerHTML = '<span class="text-muted small">—</span>';
                }
            }

            if (data.success && data.administrable) {
                // Success - update the row with new info
                if (statusCell) {
                    statusCell.innerHTML = '<span class="badge bg-success"><i class="bi bi-check-circle"></i> Online</span>';
                }

                // Update firmware version if returned
                if (data.response && data.response.firmware_version && fwCell) {
                    fwCell.textContent = data.response.firmware_version;
                }

                // Update hardware model if returned
                if (data.response && data.response.hw_model && hwCell) {
                    hwCell.textContent = data.response.hw_model;
                }

                // Update capabilities icons
                if (capsCell && data.response) {
                    const caps = [];
                    if (data.response.has_wifi) {
                        caps.push('<i class="bi bi-wifi" title="WiFi"></i>');
                    }
                    if (data.response.has_bluetooth) {
                        caps.push('<i class="bi bi-bluetooth" title="Bluetooth"></i>');
                    }
                    if (data.response.can_shutdown) {
                        caps.push('<i class="bi bi-power" title="Can Shutdown"></i>');
                    }
                    if (data.response.role !== undefined && data.response.role !== null) {
                        const roleNames = {
                            0: 'Client', 1: 'Client Mute', 2: 'Router',
                            3: 'Router Client', 4: 'Repeater', 5: 'Tracker', 6: 'Sensor'
                        };
                        const roleName = roleNames[data.response.role] || `Role ${data.response.role}`;
                        caps.push(`<span class="badge bg-info text-dark" title="Device Role">${roleName}</span>`);
                    }
                    capsCell.innerHTML = caps.length > 0 ? caps.join(' ') : '<span class="text-muted small">—</span>';
                }

                // Update last confirmed time
                if (confirmedCell) {
                    const now = new Date();
                    confirmedCell.innerHTML = `<span class="text-muted small">${formatAdminDateTime(now)}</span>`;
                }

                showAlert('success', `Node ${data.hex_id} is online and administrable`);
            } else {
                // Failed to get response
                if (statusCell) {
                    statusCell.innerHTML = '<span class="badge bg-danger"><i class="bi bi-x-circle"></i> No Response</span>';
                }
                showAlert('warning', data.error || 'Node did not respond to admin request');
            }
        } catch (error) {
            // Error occurred
            if (statusCell) {
                statusCell.innerHTML = '<span class="badge bg-danger"><i class="bi bi-exclamation-triangle"></i> Error</span>';
            }
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            // Restore button
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i>';
            }
        }
    }

    // Refresh all administrable nodes
    async function refreshAllNodes() {
        const tbody = document.getElementById('administrableNodesBody');
        if (!tbody) return;

        const rows = tbody.querySelectorAll('tr[id^="admin-node-row-"]');
        for (const row of rows) {
            const nodeId = row.id.replace('admin-node-row-', '');
            await refreshNodeAdminInfo(parseInt(nodeId));
            // Small delay between requests to avoid overwhelming the mesh
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }

    // Confirm reboot from nodes table
    function confirmReboot(nodeId) {
        showConfirmModal(
            'Confirm Reboot',
            `Are you sure you want to reboot node ${nodeId}?<br><br>
            <span class="text-muted">The node will restart in 5 seconds after the command is sent.</span>`,
            async () => {
                await sendReboot(nodeId);
            }
        );
    }

    // Confirm reboot target node
    function confirmRebootTarget() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }
        confirmReboot(nodeId);
    }

    // Confirm shutdown target node
    function confirmShutdownTarget() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }
        showConfirmModal(
            'Confirm Shutdown',
            `<strong class="text-danger">Warning!</strong> Are you sure you want to shut down node ${nodeId}?<br><br>
            <span class="text-muted">The node will power off and will need to be manually restarted.</span>`,
            async () => {
                await sendShutdown(nodeId);
            }
        );
    }

    // Quick check if node is responding (lighter than full test)
    async function isNodeResponding(nodeId, timeoutMs = 5000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            const data = await response.json();
            return data.success && data.administrable;
        } catch (error) {
            clearTimeout(timeoutId);
            return false;
        }
    }

    // Reboot log management
    let rebootLogLines = [];
    let spinnerInterval = null;
    let spinnerFrame = 0;
    const spinnerFrames = ['/', '-', '\\', '|'];

    function initRebootLog() {
        rebootLogLines = [];
        const container = document.getElementById('commandResponse');
        container.innerHTML = '<pre id="rebootLogPre" style="margin: 0; font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></pre>';
    }

    function addRebootLog(message, isSpinnerLine = false) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logLine = `[${timestamp}] ${message}`;

        if (isSpinnerLine) {
            // Replace last line if it was a spinner line
            if (rebootLogLines.length > 0 && rebootLogLines[rebootLogLines.length - 1].isSpinner) {
                rebootLogLines[rebootLogLines.length - 1] = { text: logLine, isSpinner: true };
            } else {
                rebootLogLines.push({ text: logLine, isSpinner: true });
            }
        } else {
            rebootLogLines.push({ text: logLine, isSpinner: false });
        }

        updateRebootLogDisplay();
    }

    function updateRebootLogDisplay() {
        const pre = document.getElementById('rebootLogPre');
        if (!pre) return;

        const text = rebootLogLines.map(line => line.text).join('\n');
        pre.textContent = text;
        pre.scrollTop = pre.scrollHeight;
    }

    function startSpinner(baseMessage) {
        stopSpinner();
        spinnerFrame = 0;

        const updateSpinner = () => {
            const spinner = spinnerFrames[spinnerFrame % spinnerFrames.length];
            addRebootLog(`${spinner} ${baseMessage}`, true);
            spinnerFrame++;
        };

        updateSpinner();
        spinnerInterval = setInterval(updateSpinner, 250);
    }

    function stopSpinner() {
        if (spinnerInterval) {
            clearInterval(spinnerInterval);
            spinnerInterval = null;
        }
    }

    function finalizeRebootLog(message, success = true) {
        stopSpinner();
        // Remove the last spinner line if present
        if (rebootLogLines.length > 0 && rebootLogLines[rebootLogLines.length - 1].isSpinner) {
            rebootLogLines.pop();
        }
        const symbol = success ? '✓' : '✗';
        addRebootLog(`${symbol} ${message}`);
    }

    // Update reboot progress UI
    function updateRebootProgress(phase, progress, message, details) {
        const banner = document.getElementById('adminStatusBanner');
        if (!banner) return;

        // Create or get progress container
        let progressContainer = document.getElementById('rebootProgressContainer');
        if (!progressContainer) {
            progressContainer = document.createElement('div');
            progressContainer.id = 'rebootProgressContainer';
            progressContainer.className = 'mt-3';
            banner.querySelector('.status-details')?.appendChild(progressContainer);
        }

        // Phase icons and colors
        const phases = {
            'sending': { icon: 'bi-send', color: 'warning' },
            'waiting-shutdown': { icon: 'bi-hourglass-split', color: 'warning' },
            'offline': { icon: 'bi-power', color: 'secondary' },
            'waiting-online': { icon: 'bi-arrow-repeat', color: 'info' },
            'reconnecting': { icon: 'bi-plug', color: 'primary' },
            'complete': { icon: 'bi-check-circle', color: 'success' },
            'error': { icon: 'bi-x-circle', color: 'danger' }
        };

        const phaseInfo = phases[phase] || phases['sending'];

        progressContainer.innerHTML = `
            <div class="d-flex align-items-center mb-2">
                <i class="bi ${phaseInfo.icon} text-${phaseInfo.color} me-2" style="font-size: 1.2rem;"></i>
                <strong>${message}</strong>
            </div>
            <div class="progress" style="height: 8px;">
                <div class="progress-bar bg-${phaseInfo.color} ${phase === 'offline' || phase === 'waiting-online' ? 'progress-bar-striped progress-bar-animated' : ''}"
                     role="progressbar"
                     style="width: ${progress}%;"
                     aria-valuenow="${progress}"
                     aria-valuemin="0"
                     aria-valuemax="100">
                </div>
            </div>
            <small class="text-muted mt-1 d-block">${details || ''}</small>
        `;

        // Update banner styling
        updateAdminStatusBanner(phaseInfo.color === 'success' ? 'success' : 'warning',
            phase === 'complete' ? 'Reboot Complete' : 'Rebooting Node...', '');
    }

    // Monitor reboot process with real-time updates
    async function monitorReboot(nodeId) {
        const POLL_INTERVAL = 3000;  // Check every 3 seconds
        const SHUTDOWN_TIMEOUT = 15000;  // Max time to wait for shutdown (15s)
        const ONLINE_TIMEOUT = 120000;  // Max time to wait for online (2 min)

        let phase = 'waiting-shutdown';
        let startTime = Date.now();
        let offlineDetectedTime = null;
        const nodeHex = `!${nodeId.toString(16).padStart(8, '0')}`;

        // Initialize log
        initRebootLog();
        addRebootLog(`Reboot command sent to ${nodeHex}`);
        addRebootLog('Node will restart in 5 seconds...');

        updateRebootProgress('waiting-shutdown', 10, 'Waiting for node to shut down...',
            'The node will restart in a few seconds');

        // Phase 1: Wait for node to go offline
        addRebootLog('Phase 1: Waiting for node to go offline');
        startSpinner('Polling node status...');

        while (Date.now() - startTime < SHUTDOWN_TIMEOUT) {
            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));

            const responding = await isNodeResponding(nodeId, 4000);
            const elapsed = Math.round((Date.now() - startTime) / 1000);

            if (!responding) {
                // Node is offline!
                stopSpinner();
                offlineDetectedTime = Date.now();
                phase = 'offline';
                finalizeRebootLog(`Node offline detected after ${elapsed}s`);
                updateRebootProgress('offline', 30, 'Node is offline',
                    `Shutdown detected after ${elapsed}s. Waiting for restart...`);
                break;
            } else {
                // Still online, update progress
                const progress = 10 + (elapsed / (SHUTDOWN_TIMEOUT / 1000)) * 20;
                updateRebootProgress('waiting-shutdown', Math.min(progress, 29),
                    'Waiting for node to shut down...',
                    `Still responding after ${elapsed}s...`);
                startSpinner(`Polling node status... (${elapsed}s elapsed, still online)`);
            }
        }

        // If we didn't detect offline, assume it went offline and we missed it
        if (!offlineDetectedTime) {
            stopSpinner();
            offlineDetectedTime = Date.now();
            phase = 'offline';
            addRebootLog('! Node shutdown not detected, assuming offline');
            updateRebootProgress('offline', 30, 'Node appears offline',
                'Shutdown assumed. Waiting for restart...');
        }

        // Phase 2: Wait for node to come back online
        phase = 'waiting-online';
        let pollCount = 0;
        const maxPolls = Math.ceil(ONLINE_TIMEOUT / POLL_INTERVAL);

        addRebootLog('Phase 2: Waiting for node to come back online');
        startSpinner('Waiting for node to boot...');

        while (Date.now() - offlineDetectedTime < ONLINE_TIMEOUT) {
            pollCount++;
            const progress = 30 + (pollCount / maxPolls) * 50;
            const waitTime = Math.round((Date.now() - offlineDetectedTime) / 1000);

            updateRebootProgress('waiting-online', Math.min(progress, 79),
                'Waiting for node to come back online...',
                `Polling... (${waitTime}s since shutdown)`);
            startSpinner(`Polling node... (${waitTime}s since shutdown, attempt ${pollCount})`);

            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));

            const responding = await isNodeResponding(nodeId, 4000);

            if (responding) {
                // Node is back online!
                stopSpinner();
                finalizeRebootLog(`Node responded after ${waitTime}s`);

                phase = 'reconnecting';
                updateRebootProgress('reconnecting', 85, 'Node is back online!',
                    'Re-establishing admin session...');
                addRebootLog('Phase 3: Re-establishing admin session');
                startSpinner('Negotiating session key...');

                // Refresh admin info
                await refreshNodeAdminInfo(nodeId);
                stopSpinner();
                finalizeRebootLog('Admin session established');

                // Update admin status for selected node
                const targetNodeInput = document.getElementById('targetNodeInput');
                if (targetNodeInput && targetNodeInput.value.trim() == nodeId) {
                    lastCheckedNodeId = null;
                    await checkAdminStatus(nodeId);
                }

                // Complete!
                const totalTime = Math.round((Date.now() - startTime) / 1000);
                updateRebootProgress('complete', 100, 'Reboot complete!',
                    `Node rebooted successfully in ${totalTime}s`);
                addRebootLog('─'.repeat(40));
                addRebootLog(`✓ REBOOT COMPLETE - Total time: ${totalTime}s`);
                addRebootLog('─'.repeat(40));
                showAlert('success', 'Node rebooted successfully');

                // Clear progress after a few seconds
                setTimeout(() => {
                    const progressContainer = document.getElementById('rebootProgressContainer');
                    if (progressContainer) {
                        progressContainer.remove();
                    }
                }, 5000);

                return true;
            }
        }

        // Timeout - node didn't come back
        stopSpinner();
        const totalWait = Math.round((Date.now() - offlineDetectedTime) / 1000);
        finalizeRebootLog(`Timeout after ${totalWait}s waiting for node`, false);
        addRebootLog('─'.repeat(40));
        addRebootLog('✗ REBOOT TIMEOUT - Node did not respond');
        addRebootLog('─'.repeat(40));

        updateRebootProgress('error', 100, 'Timeout waiting for node',
            'Node did not respond within expected time. It may still be booting or have issues.');
        showAlert('warning', 'Node reboot timeout - please check the device');

        return false;
    }

    // Send reboot command
    async function sendReboot(nodeId) {
        updateRebootProgress('sending', 5, 'Sending reboot command...', '');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/reboot`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ delay_seconds: 5 })
            });
            const data = await response.json();

            if (data.success) {
                showCommandResponse(data.message);
                showAlert('success', data.message);

                // Start real-time reboot monitoring
                await monitorReboot(nodeId);
            } else {
                showCommandResponse(`Error: ${data.error}`, true);
                updateRebootProgress('error', 0, 'Failed to send reboot', data.error);
            }
        } catch (error) {
            showCommandResponse(`Error: ${error.message}`, true);
            updateRebootProgress('error', 0, 'Error sending reboot', error.message);
        }
    }

    // Send shutdown command
    async function sendShutdown(nodeId) {
        showCommandResponse('Sending shutdown command...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/shutdown`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ delay_seconds: 5 })
            });
            const data = await response.json();

            if (data.success) {
                showCommandResponse(data.message);
                showAlert('warning', data.message);

                // Update status to show shutting down
                updateAdminStatusBanner('warning', 'Node is shutting down...',
                    'The node will power off in a few seconds. It will not respond to commands until manually powered on.');
            } else {
                showCommandResponse(`Error: ${data.error}`, true);
            }
        } catch (error) {
            showCommandResponse(`Error: ${error.message}`, true);
        }
    }

    // Show command response
    function showCommandResponse(content, isError = false) {
        const container = document.getElementById('commandResponse');
        if (isError) {
            container.innerHTML = `<span class="text-danger">${content}</span>`;
        } else {
            container.textContent = content;
        }
    }

    // Refresh audit log
    async function refreshLog() {
        const container = document.getElementById('auditLogContainer');
        container.innerHTML = `
            <div class="text-center py-3">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        `;

        try {
            const response = await fetch('/api/admin/log?limit=50');
            const data = await response.json();

            if (data.log && data.log.length > 0) {
                let html = `
                    <div class="table-responsive">
                        <table class="table table-sm table-hover">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Target</th>
                                    <th>Command</th>
                                    <th>Status</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                for (const entry of data.log) {
                    const timestamp = formatAdminDateTime(new Date(entry.timestamp * 1000));
                    const statusClass = `log-status-${entry.status}`;
                    const entryId = `log-entry-${entry.id}`;

                    // Build popover content
                    const popoverContent = buildLogPopoverContent(entry);

                    html += `
                        <tr class="log-entry"
                            id="${entryId}"
                            data-bs-toggle="popover"
                            data-bs-trigger="click"
                            data-bs-placement="left"
                            data-bs-html="true"
                            data-bs-custom-class="log-details-popover"
                            data-bs-content="${escapeHtml(popoverContent)}"
                            title="Command Details">
                            <td class="log-timestamp">${timestamp}</td>
                            <td><code>${entry.target_node_hex || entry.target_node_id}</code></td>
                            <td>${entry.command_type}</td>
                            <td class="${statusClass}">
                                <i class="bi bi-${getStatusIcon(entry.status)}"></i>
                                ${entry.status}
                            </td>
                            <td>
                                <i class="bi bi-info-circle text-muted" title="Click for details"></i>
                            </td>
                        </tr>
                    `;
                }

                html += '</tbody></table></div>';
                container.innerHTML = html;

                // Initialize popovers for the log entries
                const popoverTriggerList = container.querySelectorAll('[data-bs-toggle="popover"]');
                const popovers = [];
                popoverTriggerList.forEach(el => {
                    const popover = new bootstrap.Popover(el, {
                        container: 'body',
                        sanitize: false
                    });
                    popovers.push(popover);
                });

                // Close popover when clicking outside
                document.addEventListener('click', function closePopover(e) {
                    // Check if click is outside any popover and its trigger
                    const isPopoverClick = e.target.closest('.popover') || e.target.closest('[data-bs-toggle="popover"]');
                    if (!isPopoverClick) {
                        popovers.forEach(p => p.hide());
                    }
                }, { once: false });
            } else {
                container.innerHTML = `
                    <div class="text-center py-5 text-muted">
                        <i class="bi bi-journal"></i> No admin commands logged yet
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    Error loading audit log: ${error.message}
                </div>
            `;
        }
    }

    // Build popover content for a log entry
    function buildLogPopoverContent(entry) {
        let content = '';

        // Command data section
        if (entry.command_data) {
            try {
                const cmdData = JSON.parse(entry.command_data);
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Command Sent</div>`;
                content += `<div class="log-details-content">${JSON.stringify(cmdData, null, 2)}</div>`;
                content += `</div>`;
            } catch (e) {
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Command Sent</div>`;
                content += `<div class="log-details-content">${entry.command_data}</div>`;
                content += `</div>`;
            }
        }

        // Response data section
        if (entry.response_data) {
            try {
                const respData = JSON.parse(entry.response_data);
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Response</div>`;
                content += `<div class="log-details-content log-success-content">${JSON.stringify(respData, null, 2)}</div>`;
                content += `</div>`;
            } catch (e) {
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Response</div>`;
                content += `<div class="log-details-content log-success-content">${entry.response_data}</div>`;
                content += `</div>`;
            }
        }

        // Error message section
        if (entry.error_message) {
            content += `<div class="log-details-section">`;
            content += `<div class="log-details-label">Error</div>`;
            content += `<div class="log-details-content log-error-content">${entry.error_message}</div>`;
            content += `</div>`;
        }

        // If no details available
        if (!content) {
            content = `<div class="text-muted">No additional details available</div>`;
        }

        // Add timing info if available
        if (entry.response_timestamp && entry.timestamp) {
            const durationMs = ((entry.response_timestamp - entry.timestamp) * 1000).toFixed(0);
            content += `<div class="log-details-section mt-2">`;
            content += `<small class="text-muted">Duration: ${durationMs}ms</small>`;
            content += `</div>`;
        }

        return content;
    }

    // Escape HTML for safe insertion into data attributes
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function getStatusIcon(status) {
        const icons = {
            'success': 'check-circle-fill',
            'failed': 'x-circle-fill',
            'pending': 'clock-fill',
            'timeout': 'exclamation-triangle-fill'
        };
        return icons[status] || 'question-circle';
    }

    // Show confirmation modal
    function showConfirmModal(title, body, onConfirm) {
        document.getElementById('confirmModalTitle').textContent = title;
        document.getElementById('confirmModalBody').innerHTML = body;

        const confirmBtn = document.getElementById('confirmModalBtn');
        confirmBtn.onclick = async () => {
            const modal = bootstrap.Modal.getInstance(document.getElementById('confirmModal'));
            modal.hide();
            await onConfirm();
        };

        const modal = new bootstrap.Modal(document.getElementById('confirmModal'));
        modal.show();
    }

    // Show toast alert
    function showAlert(type, message) {
        // Create a simple alert at the top of the page
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
        alertDiv.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px;';
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        document.body.appendChild(alertDiv);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }

    // Restore saved settings from localStorage
    function restoreSavedSettings() {
        // Restore connection type
        const savedConnType = loadSetting(STORAGE_KEYS.connectionType);
        if (savedConnType) {
            const connTypeSelect = document.getElementById('connectionTypeSelect');
            if (connTypeSelect && (savedConnType === 'mqtt' || savedConnType === 'tcp')) {
                connTypeSelect.value = savedConnType;
                // Update visibility of settings panels
                document.getElementById('mqttSettings').classList.toggle('d-none', savedConnType !== 'mqtt');
                document.getElementById('tcpSettings').classList.toggle('d-none', savedConnType !== 'tcp');
            }
        }

        // Restore TCP host
        const savedHost = loadSetting(STORAGE_KEYS.tcpHost);
        if (savedHost) {
            const hostInput = document.getElementById('tcpHostInput');
            if (hostInput) hostInput.value = savedHost;
        }

        // Restore TCP port
        const savedPort = loadSetting(STORAGE_KEYS.tcpPort);
        if (savedPort) {
            const portInput = document.getElementById('tcpPortInput');
            if (portInput) portInput.value = savedPort;
        }

        // Restore gateway node
        const savedGateway = loadSetting(STORAGE_KEYS.gatewayNode);
        if (savedGateway) {
            const gatewayInput = document.getElementById('gatewayNodeInput');
            if (gatewayInput && !gatewayInput.value) gatewayInput.value = savedGateway;
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        // Restore saved settings from localStorage
        restoreSavedSettings();

        // Load audit log when tab is shown
        document.getElementById('log-tab').addEventListener('shown.bs.tab', function() {
            refreshLog();
        });

        // Load templates when tab is shown
        document.getElementById('templates-tab').addEventListener('shown.bs.tab', function() {
            loadTemplates();
            loadDeploymentHistory();
            loadDeployNodesList();
        });

        // Check for node parameter in URL and pre-fill the target node
        const urlParams = new URLSearchParams(window.location.search);
        const nodeParam = urlParams.get('node');
        if (nodeParam) {
            document.getElementById('targetNodeInput').value = nodeParam;
            // Store the node ID for commands
            window.selectedTargetNode = nodeParam;
            // Switch to the Commands tab
            const commandsTab = document.getElementById('commands-tab');
            if (commandsTab) {
                const tab = new bootstrap.Tab(commandsTab);
                tab.show();
            }
        }
    });

    // ============================================================================
    // Configuration Templates
    // ============================================================================

    let currentTemplateId = null;

    async function loadTemplates() {
        const container = document.getElementById('templatesList');
        const typeFilter = document.getElementById('templateTypeFilter').value;

        container.innerHTML = '<div class="text-center py-3 text-muted"><i class="bi bi-arrow-clockwise spin"></i> Loading...</div>';

        try {
            const url = typeFilter ? `/api/admin/templates?type=${typeFilter}` : '/api/admin/templates';
            const response = await fetch(url);
            const data = await response.json();

            if (data.templates && data.templates.length > 0) {
                let html = '';
                for (const template of data.templates) {
                    const isActive = template.id === currentTemplateId ? 'active' : '';
                    const typeIcon = getTemplateTypeIcon(template.template_type);
                    html += `
                        <a href="#" class="list-group-item list-group-item-action ${isActive}"
                           onclick="selectTemplate(${template.id}); return false;">
                            <div class="d-flex justify-content-between align-items-start">
                                <div>
                                    <i class="bi ${typeIcon}"></i>
                                    <strong>${escapeHtml(template.name)}</strong>
                                    <br>
                                    <small class="text-muted">
                                        <span class="badge bg-secondary">${template.template_type}</span>
                                        ${template.description ? escapeHtml(template.description) : ''}
                                    </small>
                                </div>
                            </div>
                        </a>
                    `;
                }
                container.innerHTML = html;
            } else {
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-folder2-open"></i>
                        <p class="small mb-0">No templates found.<br>Click "New Template" to create one.</p>
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `<div class="text-danger p-3">Error loading templates: ${error.message}</div>`;
        }
    }

    function getTemplateTypeIcon(type) {
        const icons = {
            'device': 'bi-cpu',
            'lora': 'bi-broadcast',
            'channel': 'bi-hash',
            'position': 'bi-geo-alt',
            'power': 'bi-battery-charging',
            'network': 'bi-wifi',
            'display': 'bi-display',
            'bluetooth': 'bi-bluetooth',
        };
        return icons[type] || 'bi-file-earmark-code';
    }

    async function selectTemplate(templateId) {
        currentTemplateId = templateId;

        // Update active state in list
        document.querySelectorAll('#templatesList .list-group-item').forEach(el => {
            el.classList.remove('active');
        });

        try {
            const response = await fetch(`/api/admin/templates/${templateId}`);
            const template = await response.json();

            if (template.error) {
                showAlert('danger', template.error);
                return;
            }

            // Populate editor
            document.getElementById('templateName').value = template.name;
            document.getElementById('templateType').value = template.template_type;
            document.getElementById('templateDescription').value = template.description || '';

            const configData = typeof template.config_data === 'object'
                ? JSON.stringify(template.config_data, null, 2)
                : template.config_data;
            document.getElementById('templateConfigData').value = configData;

            // Show editor, hide placeholder
            document.getElementById('templateEditorSection').style.display = 'block';
            document.getElementById('templatePlaceholder').style.display = 'none';
            document.getElementById('templateEditorTitle').innerHTML = '<i class="bi bi-pencil"></i> Edit Template';
            document.getElementById('deleteTemplateBtn').style.display = 'inline-block';

            // Reload templates list to update active state
            loadTemplates();

        } catch (error) {
            showAlert('danger', `Error loading template: ${error.message}`);
        }
    }

    function showCreateTemplateModal() {
        currentTemplateId = null;

        // Clear editor
        document.getElementById('templateName').value = '';
        document.getElementById('templateType').value = 'lora';
        document.getElementById('templateDescription').value = '';
        document.getElementById('templateConfigData').value = '{\n  \n}';

        // Show editor
        document.getElementById('templateEditorSection').style.display = 'block';
        document.getElementById('templatePlaceholder').style.display = 'none';
        document.getElementById('templateEditorTitle').innerHTML = '<i class="bi bi-plus-lg"></i> Create New Template';
        document.getElementById('deleteTemplateBtn').style.display = 'none';

        // Focus on name field
        document.getElementById('templateName').focus();
    }

    async function saveTemplate() {
        const name = document.getElementById('templateName').value.trim();
        const templateType = document.getElementById('templateType').value;
        const description = document.getElementById('templateDescription').value.trim();
        const configDataStr = document.getElementById('templateConfigData').value.trim();

        if (!name) {
            showAlert('warning', 'Template name is required');
            return;
        }

        // Validate JSON
        let configData;
        try {
            configData = JSON.parse(configDataStr);
        } catch (e) {
            showAlert('danger', 'Invalid JSON in configuration data');
            return;
        }

        const saveBtn = document.getElementById('saveTemplateBtn');
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

        try {
            const url = currentTemplateId
                ? `/api/admin/templates/${currentTemplateId}`
                : '/api/admin/templates';
            const method = currentTemplateId ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    template_type: templateType,
                    description: description || null,
                    config_data: configData,
                }),
            });

            const result = await response.json();

            if (result.success || result.template_id) {
                showAlert('success', currentTemplateId ? 'Template updated!' : 'Template created!');
                if (result.template_id) {
                    currentTemplateId = result.template_id;
                }
                loadTemplates();
            } else {
                showAlert('danger', result.error || 'Failed to save template');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="bi bi-save"></i> Save';
        }
    }

    async function deleteTemplate() {
        if (!currentTemplateId) return;

        showConfirmModal(
            'Delete Template',
            'Are you sure you want to delete this template? This action cannot be undone.',
            async () => {
                try {
                    const response = await fetch(`/api/admin/templates/${currentTemplateId}`, {
                        method: 'DELETE',
                    });

                    const result = await response.json();

                    if (result.success) {
                        showAlert('success', 'Template deleted');
                        currentTemplateId = null;
                        document.getElementById('templateEditorSection').style.display = 'none';
                        document.getElementById('templatePlaceholder').style.display = 'block';
                        loadTemplates();
                    } else {
                        showAlert('danger', result.error || 'Failed to delete template');
                    }
                } catch (error) {
                    showAlert('danger', `Error: ${error.message}`);
                }
            }
        );
    }

    // ============================================================================
    // Template Deployment
    // ============================================================================

    async function loadDeployNodesList() {
        const container = document.getElementById('deployNodesList');

        try {
            const response = await fetch('/api/admin/nodes');
            const data = await response.json();

            if (data.nodes && data.nodes.length > 0) {
                let html = '';
                for (const node of data.nodes) {
                    const displayName = node.long_name || node.short_name || node.hex_id || `!${node.node_id.toString(16).padStart(8, '0')}`;
                    html += `
                        <div class="form-check">
                            <input class="form-check-input deploy-node-checkbox" type="checkbox"
                                   value="${node.node_id}" id="deployNode${node.node_id}">
                            <label class="form-check-label" for="deployNode${node.node_id}">
                                ${escapeHtml(displayName)}
                                <code class="text-muted small">${node.hex_id || ''}</code>
                            </label>
                        </div>
                    `;
                }
                container.innerHTML = html;
            } else {
                container.innerHTML = '<span class="text-muted small">No administrable nodes available</span>';
            }
        } catch (error) {
            container.innerHTML = `<span class="text-danger small">Error: ${error.message}</span>`;
        }
    }

    function selectAllDeployNodes() {
        document.querySelectorAll('.deploy-node-checkbox').forEach(cb => cb.checked = true);
    }

    function deselectAllDeployNodes() {
        document.querySelectorAll('.deploy-node-checkbox').forEach(cb => cb.checked = false);
    }

    // Deployment log lines for SSE streaming
    let deployLogLines = [];

    function initDeployLog() {
        deployLogLines = [];
    }

    function addDeployLog(message) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        deployLogLines.push(`[${timestamp}] ${message}`);
    }

    function renderDeployProgress(status, progress, logLines, nodeResults = []) {
        let html = `
            <div class="mb-2">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <span class="small fw-bold">${escapeHtml(status)}</span>
                    <span class="badge bg-primary">${progress}%</span>
                </div>
                <div class="progress" style="height: 8px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar"
                         style="width: ${progress}%;" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
            </div>
        `;

        // Show node results if any
        if (nodeResults.length > 0) {
            html += '<ul class="list-unstyled mb-2 small">';
            for (const r of nodeResults) {
                const icon = r.success ? 'check-circle text-success' : 'x-circle text-danger';
                const message = r.success ? 'Deployed successfully' : r.error;
                html += `
                    <li>
                        <i class="bi bi-${icon}"></i>
                        <code>${escapeHtml(r.node)}</code>: ${escapeHtml(message || 'Unknown')}
                    </li>
                `;
            }
            html += '</ul>';
        }

        // Show log console
        html += `
            <div class="bg-dark text-light rounded p-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                <pre id="deployLogPre" style="margin: 0; white-space: pre-wrap;">${escapeHtml(logLines.join('\n'))}</pre>
            </div>
        `;

        return html;
    }

    async function deployTemplate(forceDeployment = false, acknowledgedWarnings = false) {
        if (!currentTemplateId) {
            showAlert('warning', 'Please save the template first');
            return;
        }

        const selectedNodes = [];
        document.querySelectorAll('.deploy-node-checkbox:checked').forEach(cb => {
            selectedNodes.push(parseInt(cb.value));
        });

        if (selectedNodes.length === 0) {
            showAlert('warning', 'Please select at least one node');
            return;
        }

        const deployBtn = document.getElementById('deployTemplateBtn');
        deployBtn.disabled = true;
        deployBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Deploying...';

        const resultsDiv = document.getElementById('deploymentResults');
        resultsDiv.style.display = 'block';

        // Initialize deployment log
        initDeployLog();
        addDeployLog(`Starting deployment to ${selectedNodes.length} node(s)`);
        addDeployLog(`Template ID: ${currentTemplateId}`);
        addDeployLog(`Force: ${forceDeployment}, Acknowledged: ${acknowledgedWarnings}`);

        resultsDiv.innerHTML = renderDeployProgress('Connecting to server...', 0, deployLogLines);

        // Track node results for display
        const nodeResults = [];

        try {
            // Build SSE URL with query parameters
            const params = new URLSearchParams({
                node_ids: selectedNodes.join(','),
                force: forceDeployment.toString(),
                acknowledged_warnings: acknowledgedWarnings.toString(),
            });
            const url = `/api/admin/templates/${currentTemplateId}/deploy/stream?${params}`;

            addDeployLog(`Connecting to: ${url}`);
            resultsDiv.innerHTML = renderDeployProgress('Connecting...', 0, deployLogLines);

            const eventSource = new EventSource(url);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);

                // Check for completion
                if (data.complete) {
                    eventSource.close();

                    if (data.requires_force || data.requires_acknowledgment) {
                        // Handle warnings/blocking issues - show confirmation UI
                        let html = '';

                        // Show log first
                        addDeployLog('Validation issues detected');
                        html += `
                            <div class="bg-dark text-light rounded p-2 mb-2" style="max-height: 100px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                                <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                            </div>
                        `;

                        // Show blocking issues (critical)
                        if (data.blocking_issues && data.blocking_issues.length > 0) {
                            html += `
                                <div class="alert alert-danger py-2 mb-2">
                                    <strong><i class="bi bi-exclamation-octagon"></i> Critical Issues:</strong>
                                    <ul class="mb-0 mt-1">
                            `;
                            for (const issue of data.blocking_issues) {
                                html += `<li>${escapeHtml(issue)}</li>`;
                            }
                            html += `</ul></div>`;
                        }

                        // Show warnings
                        if (data.warnings && data.warnings.length > 0) {
                            html += `
                                <div class="alert alert-warning py-2 mb-2">
                                    <strong><i class="bi bi-exclamation-triangle"></i> Warnings:</strong>
                                    <ul class="mb-0 mt-1">
                            `;
                            for (const warning of data.warnings) {
                                html += `<li>${escapeHtml(warning)}</li>`;
                            }
                            html += `</ul></div>`;
                        }

                        // Show action buttons
                        if (data.requires_force) {
                            html += `
                                <div class="d-flex gap-2">
                                    <button class="btn btn-outline-secondary btn-sm" onclick="cancelDeploy()">Cancel</button>
                                    <button class="btn btn-danger btn-sm" onclick="deployTemplate(true, true)">
                                        <i class="bi bi-exclamation-triangle"></i> Deploy Anyway (Dangerous)
                                    </button>
                                </div>
                                <p class="text-muted small mt-2 mb-0">
                                    <i class="bi bi-info-circle"></i>
                                    Deploying this configuration may make nodes unreachable for future remote administration.
                                </p>
                            `;
                        } else if (data.requires_acknowledgment) {
                            html += `
                                <div class="d-flex gap-2">
                                    <button class="btn btn-outline-secondary btn-sm" onclick="cancelDeploy()">Cancel</button>
                                    <button class="btn btn-warning btn-sm" onclick="deployTemplate(false, true)">
                                        <i class="bi bi-check-lg"></i> I Understand, Proceed
                                    </button>
                                </div>
                            `;
                        }

                        resultsDiv.innerHTML = html;
                        deployBtn.disabled = false;
                        deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
                        return;
                    }

                    // Normal completion
                    addDeployLog('─────────────────────');
                    if (data.success) {
                        addDeployLog(`✓ Deployment complete: ${data.summary.successful}/${data.summary.total} successful`);
                    } else {
                        addDeployLog(`✗ Deployment finished with errors: ${data.summary.failed} failed`);
                    }

                    // Build final summary
                    const alertClass = data.success ? 'alert-success' : 'alert-warning';
                    let html = `
                        <div class="alert ${alertClass} py-2 mb-2">
                            <strong><i class="bi bi-${data.success ? 'check-circle' : 'exclamation-triangle'}"></i>
                                Deployment Complete:</strong>
                            ${data.summary.successful}/${data.summary.total} successful
                        </div>
                    `;

                    // Show log console
                    html += `
                        <div class="bg-dark text-light rounded p-2 mb-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                            <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                        </div>
                    `;

                    // Show node results
                    if (data.results && data.results.length > 0) {
                        html += '<ul class="list-unstyled mb-0 small">';
                        for (const r of data.results) {
                            const icon = r.success ? 'check-circle text-success' : 'x-circle text-danger';
                            const message = r.success ? r.message : r.error;
                            html += `
                                <li>
                                    <i class="bi bi-${icon}"></i>
                                    <code>${r.hex_id}</code>: ${escapeHtml(message || 'Unknown')}
                                </li>
                            `;
                        }
                        html += '</ul>';
                    }

                    resultsDiv.innerHTML = html;
                    loadDeploymentHistory();
                    deployBtn.disabled = false;
                    deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
                    return;
                }

                // Progress update
                if (data.status) {
                    addDeployLog(data.status);
                }

                // Track node results
                if (data.node_result) {
                    nodeResults.push(data.node_result);
                }

                const progress = data.progress || 0;
                const status = data.status || 'Processing...';

                resultsDiv.innerHTML = renderDeployProgress(status, progress, deployLogLines, nodeResults);

                // Auto-scroll log
                const logPre = document.getElementById('deployLogPre');
                if (logPre) {
                    logPre.parentElement.scrollTop = logPre.parentElement.scrollHeight;
                }
            };

            eventSource.onerror = function(error) {
                eventSource.close();
                addDeployLog('✗ Connection error');
                resultsDiv.innerHTML = `
                    <div class="alert alert-danger py-2 mb-2">
                        <i class="bi bi-x-circle"></i> Connection error during deployment
                    </div>
                    <div class="bg-dark text-light rounded p-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                        <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                    </div>
                `;
                deployBtn.disabled = false;
                deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
            };

        } catch (error) {
            addDeployLog(`✗ Error: ${error.message}`);
            resultsDiv.innerHTML = `
                <div class="alert alert-danger py-2 mb-2">${escapeHtml(error.message)}</div>
                <div class="bg-dark text-light rounded p-2" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.75rem;">
                    <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(deployLogLines.join('\n'))}</pre>
                </div>
            `;
            deployBtn.disabled = false;
            deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
        }
    }

    function cancelDeploy() {
        const resultsDiv = document.getElementById('deploymentResults');
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
    }

    async function loadDeploymentHistory() {
        const tbody = document.getElementById('deploymentHistoryBody');

        try {
            const response = await fetch('/api/admin/deployments?limit=20');
            const data = await response.json();

            if (data.deployments && data.deployments.length > 0) {
                let html = '';
                for (const dep of data.deployments) {
                    const time = formatAdminDateTime(new Date(dep.deployed_at * 1000));
                    const statusClass = dep.status === 'success' ? 'text-success' : (dep.status === 'failed' ? 'text-danger' : 'text-warning');
                    const statusIcon = dep.status === 'success' ? 'check-circle' : (dep.status === 'failed' ? 'x-circle' : 'hourglass-split');
                    const nodeName = dep.node_name || dep.node_hex || `!${dep.node_id.toString(16).padStart(8, '0')}`;

                    html += `
                        <tr>
                            <td>
                                <span class="badge bg-secondary">${dep.template_type}</span>
                                ${escapeHtml(dep.template_name)}
                            </td>
                            <td><code>${escapeHtml(nodeName)}</code></td>
                            <td class="${statusClass}">
                                <i class="bi bi-${statusIcon}"></i> ${dep.status}
                            </td>
                            <td class="small text-muted">${time}</td>
                        </tr>
                    `;
                }
                tbody.innerHTML = html;
            } else {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No deployments yet</td></tr>';
            }
        } catch (error) {
            tbody.innerHTML = `<tr><td colspan="4" class="text-danger">Error: ${error.message}</td></tr>`;
        }
    }

    // ============================================================================
    // Create Template from Node
    // ============================================================================

    let extractedConfigType = null;
    let extractedConfig = null;

    function showCreateFromNodeModal() {
        resetExtractModal();

        // Populate node dropdown with administrable nodes
        const nodeSelect = document.getElementById('extractSourceNode');
        nodeSelect.innerHTML = '<option value="">Loading nodes...</option>';

        fetch('/api/admin/nodes')
            .then(r => r.json())
            .then(data => {
                if (data.nodes && data.nodes.length > 0) {
                    let html = '<option value="">Select an administrable node...</option>';
                    for (const node of data.nodes) {
                        const hexId = node.hex_id || `!${node.node_id.toString(16).padStart(8, '0')}`;
                        const displayName = node.long_name || node.short_name || hexId;
                        html += `<option value="${node.node_id}">${escapeHtml(displayName)} (${hexId})</option>`;
                    }
                    nodeSelect.innerHTML = html;
                } else {
                    nodeSelect.innerHTML = '<option value="">No administrable nodes found</option>';
                }
            })
            .catch(err => {
                nodeSelect.innerHTML = '<option value="">Error loading nodes</option>';
            });

        // Show/hide channel index based on config type
        document.getElementById('extractConfigType').addEventListener('change', function() {
            document.getElementById('channelIndexRow').style.display =
                this.value === 'channel' ? 'block' : 'none';
        });

        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('createFromNodeModal'));
        modal.show();
    }

    function resetExtractModal() {
        // Reset to step 1
        document.getElementById('extractStep1').style.display = 'block';
        document.getElementById('extractStep2').style.display = 'none';
        document.getElementById('extractBackBtn').style.display = 'none';
        document.getElementById('saveExtractedTemplateBtn').style.display = 'none';

        // Reset form
        document.getElementById('extractSourceNode').value = '';
        document.getElementById('extractConfigType').value = 'lora';
        document.getElementById('extractChannelIndex').value = '0';
        document.getElementById('channelIndexRow').style.display = 'none';
        document.getElementById('extractTemplateName').value = '';
        document.getElementById('extractTemplateDescription').value = '';
        document.getElementById('extractedConfigData').value = '';

        // Reset button state
        const btn = document.getElementById('extractConfigBtn');
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';

        extractedConfigType = null;
        extractedConfig = null;
    }

    async function extractConfigFromNode() {
        const nodeId = document.getElementById('extractSourceNode').value;
        const configType = document.getElementById('extractConfigType').value;
        const channelIndex = document.getElementById('extractChannelIndex').value;

        if (!nodeId) {
            showAlert('warning', 'Please select a source node');
            return;
        }

        const btn = document.getElementById('extractConfigBtn');
        const progressDiv = document.getElementById('extractionProgress');
        const statusEl = document.getElementById('extractionStatus');
        const progressBar = document.getElementById('extractionProgressBar');
        const detailsEl = document.getElementById('extractionDetails');

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Extracting...';
        progressDiv.style.display = 'block';
        statusEl.textContent = 'Connecting to node...';
        progressBar.style.width = '0%';
        detailsEl.textContent = '';

        // Build the SSE URL with query parameters
        const params = new URLSearchParams({
            node_id: nodeId,
            config_type: configType,
            channel_index: channelIndex
        });
        const sseUrl = `/api/admin/templates/extract-from-node/stream?${params.toString()}`;

        let eventSource = null;
        let lastData = null;

        try {
            eventSource = new EventSource(sseUrl);

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    lastData = data;

                    // Update progress display
                    if (data.status) {
                        statusEl.textContent = data.status;
                    }
                    if (data.progress !== undefined) {
                        progressBar.style.width = data.progress + '%';
                    }
                    if (data.details) {
                        detailsEl.textContent = data.details;
                    }

                    // Handle completion
                    if (data.complete) {
                        eventSource.close();
                        progressDiv.style.display = 'none';

                        if (data.success) {
                            // Store extracted data
                            extractedConfigType = configType;
                            extractedConfig = data.config_data;

                            // Show extracted node info
                            const nodeName = document.getElementById('extractSourceNode').selectedOptions[0].text;
                            document.getElementById('extractedFromNode').textContent = nodeName;

                            // Show excluded fields warning if any
                            if (data.excluded_fields && data.excluded_fields.length > 0) {
                                document.getElementById('excludedFieldsList').textContent = data.excluded_fields.join(', ');
                                document.getElementById('excludedFieldsWarning').style.display = 'block';
                            } else {
                                document.getElementById('excludedFieldsWarning').style.display = 'none';
                            }

                            // Populate config preview
                            document.getElementById('extractedConfigData').value = JSON.stringify(data.config_data, null, 2);

                            // Suggest a template name
                            const typeLabel = configType.charAt(0).toUpperCase() + configType.slice(1);
                            document.getElementById('extractTemplateName').value = `${typeLabel} Config from ${nodeName.split(' (')[0]}`;

                            // Switch to step 2
                            document.getElementById('extractStep1').style.display = 'none';
                            document.getElementById('extractStep2').style.display = 'block';
                            document.getElementById('extractBackBtn').style.display = 'inline-block';
                            document.getElementById('saveExtractedTemplateBtn').style.display = 'inline-block';
                        } else {
                            let errorMsg = data.error || 'Failed to extract configuration';
                            if (data.attempts) {
                                errorMsg += ` (after ${data.attempts} attempt(s))`;
                            }
                            showAlert('danger', errorMsg);
                        }

                        btn.disabled = false;
                        btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
                    }
                } catch (e) {
                    console.error('Error parsing SSE message:', e, event.data);
                }
            };

            eventSource.onerror = function(err) {
                console.error('SSE error:', err);
                eventSource.close();
                progressDiv.style.display = 'none';

                // If we got a final response before the error, it may have succeeded
                if (lastData && lastData.complete && lastData.success) {
                    return; // Already handled
                }

                showAlert('danger', 'Connection error while extracting configuration. Please try again.');
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
            };

        } catch (error) {
            progressDiv.style.display = 'none';
            showAlert('danger', `Error: ${error.message}`);
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
        }
    }

    async function saveExtractedTemplate() {
        const name = document.getElementById('extractTemplateName').value.trim();
        const description = document.getElementById('extractTemplateDescription').value.trim();

        if (!name) {
            showAlert('warning', 'Please enter a template name');
            return;
        }

        if (!extractedConfig) {
            showAlert('danger', 'No configuration data to save');
            return;
        }

        const btn = document.getElementById('saveExtractedTemplateBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

        try {
            const response = await fetch('/api/admin/templates', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    template_type: extractedConfigType,
                    description: description,
                    config_data: extractedConfig,
                }),
            });

            const data = await response.json();

            if (response.ok && data.success) {
                // Close modal
                bootstrap.Modal.getInstance(document.getElementById('createFromNodeModal')).hide();

                // Refresh templates list
                loadTemplates();

                // Select the new template
                setTimeout(() => {
                    selectTemplate(data.template_id);
                }, 500);

                showAlert('success', `Template "${name}" created successfully`);
            } else {
                showAlert('danger', data.error || 'Failed to create template');
            }

        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-save"></i> Create Template';
        }
    }

    // ============================================================================
    // Node Backup Functions
    // ============================================================================

    let currentBackupId = null;
    let currentBackupData = null;

    async function loadBackups() {
        const backupsList = document.getElementById('backupsList');
        const nodeFilter = document.getElementById('backupNodeFilter').value;

        backupsList.innerHTML = '<div class="text-center py-3 text-muted"><i class="bi bi-arrow-clockwise spin"></i> Loading backups...</div>';

        try {
            let url = '/api/admin/backups';
            if (nodeFilter) {
                url += `?node_id=${nodeFilter}`;
            }

            const response = await fetch(url);
            const data = await response.json();

            if (data.backups && data.backups.length > 0) {
                let html = '';
                for (const backup of data.backups) {
                    const created = formatAdminDateTime(new Date(backup.created_at * 1000));
                    const nodeName = backup.node_long_name || backup.node_short_name || backup.node_hex_id || `!${backup.node_id.toString(16).padStart(8, '0')}`;
                    const summary = backup.config_summary;
                    const configCount = (summary?.core_configs || 0) + (summary?.module_configs || 0) + (summary?.channels || 0);

                    html += `
                        <a href="#" class="list-group-item list-group-item-action ${backup.id === currentBackupId ? 'active' : ''}"
                           onclick="selectBackup(${backup.id}); return false;">
                            <div class="d-flex justify-content-between align-items-center">
                                <strong>${escapeHtml(backup.backup_name)}</strong>
                                <span class="badge bg-secondary">${configCount} configs</span>
                            </div>
                            <small class="text-muted d-block">
                                <i class="bi bi-router"></i> ${escapeHtml(nodeName)}
                            </small>
                            <small class="text-muted">
                                <i class="bi bi-clock"></i> ${created}
                            </small>
                        </a>
                    `;
                }
                backupsList.innerHTML = html;
            } else {
                backupsList.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-inbox" style="font-size: 2rem;"></i>
                        <p class="mt-2 mb-0">No backups found</p>
                    </div>
                `;
            }
        } catch (error) {
            backupsList.innerHTML = `<div class="alert alert-danger m-2">Error: ${error.message}</div>`;
        }
    }

    async function selectBackup(backupId) {
        currentBackupId = backupId;

        // Update list selection
        document.querySelectorAll('#backupsList .list-group-item').forEach(item => {
            item.classList.remove('active');
        });

        try {
            const response = await fetch(`/api/admin/backups/${backupId}`);
            const backup = await response.json();

            if (backup.error) {
                showAlert('danger', backup.error);
                return;
            }

            currentBackupData = backup;

            // Show viewer section
            document.getElementById('noBackupSelected').style.display = 'none';
            document.getElementById('backupViewerSection').style.display = 'block';

            // Populate metadata
            const nodeName = backup.node_long_name || backup.node_short_name || backup.node_hex_id || `!${backup.node_id.toString(16).padStart(8, '0')}`;
            document.getElementById('backupName').textContent = backup.backup_name;
            document.getElementById('backupNode').innerHTML = `<code>${escapeHtml(nodeName)}</code>`;
            document.getElementById('backupCreated').textContent = formatAdminDateTime(new Date(backup.created_at * 1000));
            document.getElementById('backupDescription').textContent = backup.description || 'No description';

            const data = backup.backup_data || {};

            // Core configs
            const coreConfigs = data.core_configs || {};
            document.getElementById('coreConfigsCount').textContent = Object.keys(coreConfigs).length;
            let coreHtml = '';
            for (const [key, value] of Object.entries(coreConfigs)) {
                coreHtml += `
                    <div class="mb-2">
                        <strong class="text-primary">${key.toUpperCase()}</strong>
                        <pre class="bg-light p-2 rounded small mb-0" style="max-height: 150px; overflow-y: auto;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>
                    </div>
                `;
            }
            document.getElementById('coreConfigsContent').innerHTML = coreHtml || '<p class="text-muted">No core configs in backup</p>';

            // Module configs
            const moduleConfigs = data.module_configs || {};
            document.getElementById('moduleConfigsCount').textContent = Object.keys(moduleConfigs).length;
            let moduleHtml = '';
            for (const [key, value] of Object.entries(moduleConfigs)) {
                moduleHtml += `
                    <div class="mb-2">
                        <strong class="text-info">${key.toUpperCase()}</strong>
                        <pre class="bg-light p-2 rounded small mb-0" style="max-height: 150px; overflow-y: auto;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>
                    </div>
                `;
            }
            document.getElementById('moduleConfigsContent').innerHTML = moduleHtml || '<p class="text-muted">No module configs in backup</p>';

            // Channels
            const channels = data.channels || {};
            document.getElementById('channelsCount').textContent = Object.keys(channels).length;
            let channelHtml = '';
            for (const [idx, value] of Object.entries(channels)) {
                const chName = value.settings?.name || `Channel ${idx}`;
                channelHtml += `
                    <div class="mb-2">
                        <strong class="text-success">Channel ${idx}: ${escapeHtml(chName)}</strong>
                        <pre class="bg-light p-2 rounded small mb-0" style="max-height: 150px; overflow-y: auto;">${escapeHtml(JSON.stringify(value, null, 2))}</pre>
                    </div>
                `;
            }
            document.getElementById('channelsContent').innerHTML = channelHtml || '<p class="text-muted">No channels in backup</p>';

            // Enable restore button when target is selected
            const restoreSelect = document.getElementById('restoreTargetNode');
            restoreSelect.onchange = function() {
                document.getElementById('restoreBackupBtn').disabled = !this.value;
            };

            // Reload the backups list to update selection
            loadBackups();

        } catch (error) {
            showAlert('danger', `Error loading backup: ${error.message}`);
        }
    }

    function showCreateBackupModal() {
        // Reset form
        document.getElementById('backupSourceNode').value = '';
        document.getElementById('backupNameInput').value = '';
        document.getElementById('backupDescriptionInput').value = '';
        document.getElementById('backupProgressSection').style.display = 'none';
        const startBtn = document.getElementById('startBackupJobBtn');
        if (startBtn) {
            startBtn.disabled = false;
            startBtn.innerHTML = '<i class="bi bi-cloud-download"></i> Create Backup';
        }

        // Auto-generate backup name when node is selected
        document.getElementById('backupSourceNode').onchange = function() {
            const option = this.options[this.selectedIndex];
            if (option.value) {
                const nodeName = option.dataset.name || 'Node';
                const date = new Date().toISOString().split('T')[0];
                document.getElementById('backupNameInput').value = `${nodeName} - Backup ${date}`;
            }
        };

        const modal = new bootstrap.Modal(document.getElementById('createBackupModal'));
        modal.show();
    }

    let backupEventSource = null;

    // Clean up SSE on modal close (for any leftover connections)
    document.getElementById('createBackupModal')?.addEventListener('hidden.bs.modal', function() {
        if (backupEventSource) {
            backupEventSource.close();
            backupEventSource = null;
        }
    });

    async function deleteBackup() {
        if (!currentBackupId) return;

        const backup = currentBackupData;
        const confirmText = `Delete backup "${backup?.backup_name || 'this backup'}"? This action cannot be undone.`;

        if (!confirm(confirmText)) return;

        try {
            const response = await fetch(`/api/admin/backups/${currentBackupId}`, {
                method: 'DELETE'
            });

            const data = await response.json();

            if (data.success) {
                showAlert('success', 'Backup deleted');
                currentBackupId = null;
                currentBackupData = null;
                document.getElementById('backupViewerSection').style.display = 'none';
                document.getElementById('noBackupSelected').style.display = 'block';
                loadBackups();
            } else {
                showAlert('danger', data.error || 'Failed to delete backup');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    function downloadBackup() {
        if (!currentBackupData) return;

        const dataStr = JSON.stringify(currentBackupData.backup_data, null, 2);
        const blob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${currentBackupData.backup_name.replace(/[^a-zA-Z0-9-_]/g, '_')}_backup.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async function restoreBackup() {
        const targetNodeId = document.getElementById('restoreTargetNode').value;
        if (!targetNodeId || !currentBackupData) return;

        // Populate the restore modal with backup details
        const backup = currentBackupData;
        const backupData = backup.backup_data || {};

        document.getElementById('restoreBackupName').textContent = backup.backup_name || 'Unknown';
        document.getElementById('restoreOriginalNode').textContent =
            backup.node_long_name || backup.node_short_name || backup.node_hex_id || 'Unknown';
        document.getElementById('restoreBackupCreated').textContent =
            backup.created_at ? formatAdminDateTime(new Date(backup.created_at * 1000)) : 'Unknown';

        // Get items from backup
        const coreConfigs = Object.keys(backupData.core_configs || {});
        const moduleConfigs = Object.keys(backupData.module_configs || {});
        const channels = Object.keys(backupData.channels || {});

        // Update counts
        document.getElementById('restoreCoreCount').textContent = coreConfigs.length;
        document.getElementById('restoreModuleCount').textContent = moduleConfigs.length;
        document.getElementById('restoreChannelCount').textContent = channels.length;

        // Populate checkboxes for selective restore
        populateRestoreCheckboxes('core', coreConfigs, backupData.core_configs || {});
        populateRestoreCheckboxes('module', moduleConfigs, backupData.module_configs || {});
        populateRestoreChannelCheckboxes(channels, backupData.channels || {});

        // Select all items by default
        selectAllRestoreItems(true);
        updateRestoreSelectedCount();

        // Reset modal state
        document.getElementById('restoreConfigSection').style.display = 'block';
        document.getElementById('restoreProgressSection').style.display = 'none';
        document.getElementById('restoreCompleteSection').style.display = 'none';
        document.getElementById('startRestoreJobBtn').style.display = 'inline-block';
        document.getElementById('restoreDoneBtn').style.display = 'none';
        document.getElementById('restoreCancelBtn').style.display = 'inline-block';
        document.getElementById('restoreModalClose').disabled = false;

        // Store target node for startRestoreJob
        document.getElementById('startRestoreJobBtn').dataset.targetNodeId = targetNodeId;
        document.getElementById('startRestoreJobBtn').dataset.backupId = currentBackupId;

        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('restoreBackupModal'));
        modal.show();
    }

    // Friendly display names for config types
    const configDisplayNames = {
        // Core configs
        device: 'Device Settings',
        position: 'Position Settings',
        power: 'Power Settings',
        network: 'Network Settings',
        display: 'Display Settings',
        lora: 'LoRa Radio Settings',
        bluetooth: 'Bluetooth Settings',
        security: 'Security Settings',
        // Module configs
        mqtt: 'MQTT Module',
        serial: 'Serial Module',
        extnotif: 'External Notifications',
        storeforward: 'Store & Forward',
        rangetest: 'Range Test',
        telemetry: 'Telemetry Module',
        cannedmsg: 'Canned Messages',
        audio: 'Audio Module',
        remotehardware: 'Remote Hardware',
        neighborinfo: 'Neighbor Info',
        ambientlighting: 'Ambient Lighting',
        detectionsensor: 'Detection Sensor',
        paxcounter: 'PAX Counter'
    };

    function populateRestoreCheckboxes(category, items, configData) {
        const container = document.getElementById(`restore${category.charAt(0).toUpperCase() + category.slice(1)}ConfigsContainer`);
        if (!container) return;

        container.innerHTML = '';

        items.forEach(item => {
            const displayName = configDisplayNames[item.toLowerCase()] || item;
            const checkboxId = `restore_${category}_${item}`;

            const div = document.createElement('div');
            div.className = 'form-check mb-1';
            div.innerHTML = `
                <input class="form-check-input restore-item-checkbox" type="checkbox"
                       id="${checkboxId}"
                       data-category="${category}"
                       data-item="${item}"
                       onchange="updateRestoreCategoryCheckbox('${category}'); updateRestoreSelectedCount()">
                <label class="form-check-label small" for="${checkboxId}">
                    ${displayName}
                </label>
            `;
            container.appendChild(div);
        });
    }

    function populateRestoreChannelCheckboxes(channelKeys, channelsData) {
        const container = document.getElementById('restoreChannelsContainer');
        if (!container) return;

        container.innerHTML = '';

        // Sort channel keys numerically
        const sortedKeys = channelKeys.sort((a, b) => parseInt(a) - parseInt(b));

        sortedKeys.forEach(channelIdx => {
            const channelData = channelsData[channelIdx] || {};
            const channelName = channelData.settings?.name || `Channel ${channelIdx}`;
            const isPrimary = parseInt(channelIdx) === 0;
            const checkboxId = `restore_channel_${channelIdx}`;

            const div = document.createElement('div');
            div.className = 'form-check mb-1';
            div.innerHTML = `
                <input class="form-check-input restore-item-checkbox" type="checkbox"
                       id="${checkboxId}"
                       data-category="channel"
                       data-item="${channelIdx}"
                       onchange="updateRestoreCategoryCheckbox('channel'); updateRestoreSelectedCount()">
                <label class="form-check-label small" for="${checkboxId}">
                    ${isPrimary ? '<span class="badge bg-warning text-dark me-1">Primary</span>' : ''}
                    Channel ${channelIdx}${channelName ? `: ${channelName}` : ''}
                </label>
            `;
            container.appendChild(div);
        });
    }

    function toggleRestoreCategory(category, checked) {
        const checkboxes = document.querySelectorAll(`.restore-item-checkbox[data-category="${category}"]`);
        checkboxes.forEach(cb => cb.checked = checked);
        updateRestoreSelectedCount();
    }

    function updateRestoreCategoryCheckbox(category) {
        const categoryCheckbox = document.getElementById(`restoreSelectAll${category.charAt(0).toUpperCase() + category.slice(1)}${category === 'channel' ? 's' : 's'}`);
        const checkboxes = document.querySelectorAll(`.restore-item-checkbox[data-category="${category}"]`);

        if (!categoryCheckbox || checkboxes.length === 0) return;

        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        const someChecked = Array.from(checkboxes).some(cb => cb.checked);

        categoryCheckbox.checked = allChecked;
        categoryCheckbox.indeterminate = someChecked && !allChecked;
    }

    function selectAllRestoreItems(checked) {
        // Select/deselect all category checkboxes
        ['restoreSelectAllCore', 'restoreSelectAllModules', 'restoreSelectAllChannels'].forEach(id => {
            const cb = document.getElementById(id);
            if (cb) {
                cb.checked = checked;
                cb.indeterminate = false;
            }
        });

        // Select/deselect all individual checkboxes
        document.querySelectorAll('.restore-item-checkbox').forEach(cb => {
            cb.checked = checked;
        });

        updateRestoreSelectedCount();
    }

    function updateRestoreSelectedCount() {
        const count = document.querySelectorAll('.restore-item-checkbox:checked').length;
        const countEl = document.getElementById('restoreSelectedCount');
        if (countEl) countEl.textContent = count;
    }

    function getSelectedRestoreItems() {
        const selected = {
            coreConfigs: [],
            moduleConfigs: [],
            channels: []
        };

        document.querySelectorAll('.restore-item-checkbox:checked').forEach(cb => {
            const category = cb.dataset.category;
            const item = cb.dataset.item;

            if (category === 'core') {
                selected.coreConfigs.push(item);
            } else if (category === 'module') {
                selected.moduleConfigs.push(item);
            } else if (category === 'channel') {
                selected.channels.push(item);
            }
        });

        return selected;
    }

    // Load backups when tab is shown
    document.getElementById('backups-tab')?.addEventListener('shown.bs.tab', function() {
        loadBackups();
    });

    // ============================================================================
    // Background Jobs Management
    // ============================================================================

    // Initialize job manager when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initJobManager();
    });

    function initJobManager() {
        jobManager = new JobManager({
            pollInterval: 2000,
            onJobUpdate: handleJobUpdate,
            onJobComplete: handleJobComplete,
            onQueueUpdate: handleQueueUpdate
        });

        // Start polling for queue status
        jobManager.startQueuePolling(5000);

        // Resume polling for any active jobs
        jobManager.resumePolling();
    }

    function handleJobUpdate(job) {
        // Update job in the list if visible
        updateJobInList(job);

        // Update tab badge
        updateJobsTabBadge();
    }

    function handleJobComplete(job) {
        // Show notification
        const isSuccess = job.status === 'completed';
        const message = isSuccess
            ? `${job.job_name} completed successfully`
            : `${job.job_name} failed: ${job.error_message || 'Unknown error'}`;

        showAlert(isSuccess ? 'success' : 'danger', message);

        // Refresh backups list if a backup job completed
        if (job.job_type === 'backup' && isSuccess) {
            loadBackups();
        }

        // Refresh jobs list
        refreshJobsList();
    }

    function handleQueueUpdate(status) {
        // Update counts
        const runningEl = document.getElementById('runningJobsCount');
        const queuedEl = document.getElementById('queuedJobsCount');
        const tabBadge = document.getElementById('jobsTabBadge');

        if (runningEl) runningEl.textContent = status.running_jobs;
        if (queuedEl) queuedEl.textContent = status.queued_jobs;

        const total = status.running_jobs + status.queued_jobs;
        if (tabBadge) {
            tabBadge.textContent = total;
            tabBadge.className = `badge ${total > 0 ? 'bg-primary' : 'bg-secondary'}`;
        }
    }

    async function refreshJobsList() {
        const container = document.getElementById('jobsListContainer');
        if (!container) return;

        try {
            const response = await fetch('/api/jobs?limit=50');
            const data = await response.json();

            if (data.jobs && data.jobs.length > 0) {
                container.innerHTML = renderJobsList(data.jobs);
            } else {
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-inbox fs-1 d-block mb-2"></i>
                        No jobs found
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Error loading jobs: ${escapeHtml(error.message)}
                </div>
            `;
        }
    }

    function renderJobsList(jobs) {
        return `
            <div class="table-responsive">
                <table class="table table-sm table-hover">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Job</th>
                            <th>Progress</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${jobs.map(job => renderJobRow(job)).join('')}
                    </tbody>
                </table>
            </div>
        `;
    }

    function renderJobRow(job) {
        const statusBadge = getJobStatusBadge(job.status, job.cancel_requested, job.pause_requested);
        const created = job.created_at ? formatTimestamp(job.created_at) : 'Unknown';
        const progress = job.progress || 0;

        let progressBar = '';
        if (job.status === 'running') {
            // Check if the progress message indicates an error or timeout
            const progressMsg = job.progress_message || '';
            const isError = progressMsg.startsWith('✗') || progressMsg.includes('failed');
            const isTimeout = progressMsg.startsWith('⏱') || progressMsg.includes('timeout');
            let msgClass = 'text-muted';
            if (isError) msgClass = 'text-danger';
            else if (isTimeout) msgClass = 'text-warning';
            else if (progressMsg.startsWith('✓')) msgClass = 'text-success';

            progressBar = `
                <div class="progress" style="height: 6px; min-width: 100px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated"
                         style="width: ${progress}%"></div>
                </div>
                <small class="${msgClass}">${escapeHtml(progressMsg)}</small>
            `;
        } else if (job.status === 'queued' && job.queue_position) {
            progressBar = `<small class="text-muted">Position: ${job.queue_position}</small>`;
        } else if (job.status === 'paused') {
            progressBar = '<small class="text-warning"><i class="bi bi-pause-fill"></i> Paused</small>';
        } else if (job.status === 'completed') {
            progressBar = '<small class="text-success">Done</small>';
        } else if (job.status === 'failed') {
            progressBar = `<small class="text-danger">${escapeHtml(job.error_message || 'Failed')}</small>`;
        } else if (job.status === 'cancelled') {
            progressBar = '<small class="text-secondary"><i class="bi bi-slash-circle"></i> Cancelled</small>';
        }

        let actions = '';
        // Details button - always show for all jobs
        actions += `
            <button class="btn btn-sm btn-outline-secondary me-1" onclick="viewJobDetails(${job.id})" title="Details">
                <i class="bi bi-eye"></i>
            </button>
        `;

        if (job.status === 'queued') {
            actions += `
                <button class="btn btn-sm btn-outline-warning me-1" onclick="pauseJob(${job.id})" title="Pause">
                    <i class="bi bi-pause-fill"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="cancelJob(${job.id})" title="Cancel">
                    <i class="bi bi-x"></i>
                </button>
            `;
        } else if (job.status === 'paused') {
            actions += `
                <button class="btn btn-sm btn-outline-success me-1" onclick="resumeJob(${job.id})" title="Resume">
                    <i class="bi bi-play-fill"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger" onclick="cancelJob(${job.id})" title="Cancel">
                    <i class="bi bi-x"></i>
                </button>
            `;
        } else if (job.status === 'running') {
            // Running jobs can be paused or cancelled (request at next checkpoint)
            // Disable buttons if already requested
            const pauseDisabled = job.pause_requested || job.cancel_requested;
            const cancelDisabled = job.cancel_requested;

            if (job.pause_requested) {
                actions += `
                    <button class="btn btn-sm btn-warning me-1" disabled title="Pause pending...">
                        <i class="bi bi-hourglass-split"></i>
                    </button>
                `;
            } else if (job.cancel_requested) {
                actions += `
                    <button class="btn btn-sm btn-secondary me-1" disabled title="Cancelling...">
                        <i class="bi bi-pause-fill"></i>
                    </button>
                `;
            } else {
                actions += `
                    <button class="btn btn-sm btn-outline-warning me-1" onclick="pauseJob(${job.id})" title="Pause (will pause at next checkpoint)">
                        <i class="bi bi-pause-fill"></i>
                    </button>
                `;
            }

            if (job.cancel_requested) {
                actions += `
                    <button class="btn btn-sm btn-danger" disabled title="Cancel pending...">
                        <i class="bi bi-hourglass-split"></i>
                    </button>
                `;
            } else {
                actions += `
                    <button class="btn btn-sm btn-outline-danger" onclick="cancelJob(${job.id})" title="Cancel (will stop at next checkpoint)">
                        <i class="bi bi-stop-fill"></i>
                    </button>
                `;
            }
        }

        return `
            <tr id="job-row-${job.id}" class="job-row" style="cursor: pointer;" onclick="viewJobDetails(${job.id})">
                <td>${statusBadge}</td>
                <td>
                    <strong>${escapeHtml(job.job_name)}</strong>
                    <br>
                    <small class="text-muted">${escapeHtml(job.job_type)}</small>
                </td>
                <td>${progressBar}</td>
                <td><small>${created}</small></td>
                <td onclick="event.stopPropagation()">${actions}</td>
            </tr>
        `;
    }

    function updateJobInList(job) {
        const row = document.getElementById(`job-row-${job.id}`);
        if (row) {
            row.outerHTML = renderJobRow(job);
        }
    }

    function getJobStatusBadge(status, cancelRequested, pauseRequested) {
        // Show transitional states first
        if (status === 'running' && cancelRequested) {
            return '<span class="badge bg-danger"><i class="bi bi-hourglass-split spin"></i> Cancelling...</span>';
        }
        if (status === 'running' && pauseRequested) {
            return '<span class="badge bg-warning text-dark"><i class="bi bi-hourglass-split spin"></i> Pausing...</span>';
        }

        const badges = {
            'queued': '<span class="badge bg-secondary"><i class="bi bi-hourglass"></i> Queued</span>',
            'running': '<span class="badge bg-primary"><i class="bi bi-arrow-repeat spin"></i> Running</span>',
            'paused': '<span class="badge bg-warning text-dark"><i class="bi bi-pause-fill"></i> Paused</span>',
            'completed': '<span class="badge bg-success"><i class="bi bi-check-circle"></i> Completed</span>',
            'failed': '<span class="badge bg-danger"><i class="bi bi-x-circle"></i> Failed</span>',
            'cancelled': '<span class="badge bg-secondary"><i class="bi bi-slash-circle"></i> Cancelled</span>'
        };
        return badges[status] || `<span class="badge bg-secondary">${escapeHtml(status)}</span>`;
    }

    async function cancelJob(jobId) {
        if (!confirm('Cancel this job?')) return;

        try {
            const result = await jobManager.cancelJob(jobId);
            if (result.success) {
                showAlert('info', 'Job cancelled');
                refreshJobsList();
            } else {
                showAlert('warning', result.error || 'Could not cancel job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function pauseJob(jobId) {
        try {
            const result = await jobManager.pauseJob(jobId);
            if (result.success) {
                showAlert('info', 'Job paused');
                refreshJobsList();
            } else {
                showAlert('warning', result.error || 'Could not pause job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function resumeJob(jobId) {
        try {
            const result = await jobManager.resumeJob(jobId);
            if (result.success) {
                showAlert('success', 'Job resumed');
                refreshJobsList();
            } else {
                showAlert('warning', result.error || 'Could not resume job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    let currentJobDetailsId = null;
    let jobDetailsPollingInterval = null;

    async function viewJobDetails(jobId) {
        currentJobDetailsId = jobId;
        const modal = new bootstrap.Modal(document.getElementById('jobDetailsModal'));
        modal.show();

        // Start polling for updates if job is active
        await refreshJobDetails(jobId);
    }

    async function refreshJobDetails(jobId) {
        try {
            const job = await jobManager.getJob(jobId);
            renderJobDetailsModal(job);

            // Set up polling for active jobs
            if (job.status === 'running' || job.status === 'queued') {
                if (!jobDetailsPollingInterval) {
                    jobDetailsPollingInterval = setInterval(async () => {
                        if (currentJobDetailsId) {
                            try {
                                const updatedJob = await jobManager.getJob(currentJobDetailsId);
                                renderJobDetailsModal(updatedJob);
                                if (updatedJob.status !== 'running' && updatedJob.status !== 'queued') {
                                    clearJobDetailsPolling();
                                }
                            } catch (e) {
                                clearJobDetailsPolling();
                            }
                        }
                    }, 1500);
                }
            }
        } catch (error) {
            document.getElementById('jobDetailsBody').innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Error loading job details: ${escapeHtml(error.message)}
                </div>
            `;
        }
    }

    function clearJobDetailsPolling() {
        if (jobDetailsPollingInterval) {
            clearInterval(jobDetailsPollingInterval);
            jobDetailsPollingInterval = null;
        }
    }

    // Stop polling when modal is closed
    document.getElementById('jobDetailsModal')?.addEventListener('hidden.bs.modal', function() {
        clearJobDetailsPolling();
        currentJobDetailsId = null;
    });

    function renderJobDetailsModal(job) {
        const titleEl = document.getElementById('jobDetailsTitle');
        const bodyEl = document.getElementById('jobDetailsBody');
        const cancelBtn = document.getElementById('jobDetailsCancelBtn');
        const pauseBtn = document.getElementById('jobDetailsPauseBtn');
        const resumeBtn = document.getElementById('jobDetailsResumeBtn');
        const forceCancelBtn = document.getElementById('jobDetailsForceCancelBtn');

        titleEl.textContent = job.job_name || 'Job Details';

        // Show/hide action buttons based on status
        cancelBtn.classList.add('d-none');
        pauseBtn.classList.add('d-none');
        resumeBtn.classList.add('d-none');
        forceCancelBtn.classList.add('d-none');

        // Reset button states
        cancelBtn.disabled = false;
        pauseBtn.disabled = false;
        cancelBtn.innerHTML = '<i class="bi bi-x-circle me-1"></i> Cancel';
        pauseBtn.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pause';
        if (job.status === 'queued') {
            cancelBtn.classList.remove('d-none');
            pauseBtn.classList.remove('d-none');
        } else if (job.status === 'paused') {
            cancelBtn.classList.remove('d-none');
            resumeBtn.classList.remove('d-none');
        } else if (job.status === 'running') {
            // Running jobs can be paused or cancelled (request at next checkpoint)
            cancelBtn.classList.remove('d-none');
            cancelBtn.innerHTML = '<i class="bi bi-stop-fill me-1"></i> Stop Job';
            cancelBtn.title = 'Request cancellation - job will stop at next checkpoint';

            // Show pause button for running jobs
            pauseBtn.classList.remove('d-none');
            pauseBtn.title = 'Request pause - job will pause at next checkpoint';

            // Also show force cancel for running jobs (in case they're stuck/orphaned)
            forceCancelBtn.classList.remove('d-none');

            // Disable buttons if already requested
            if (job.cancel_requested) {
                cancelBtn.disabled = true;
                cancelBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i> Cancelling...';
                pauseBtn.disabled = true;
            } else if (job.pause_requested) {
                pauseBtn.disabled = true;
                pauseBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i> Pausing...';
            }

            // Check if this job might be stuck (not updated recently)
            if (job.updated_at) {
                const lastUpdate = new Date(job.updated_at * 1000);
                const now = new Date();
                const minutesSinceUpdate = (now - lastUpdate) / 1000 / 60;
                if (minutesSinceUpdate > 2) {
                    // Job hasn't been updated in 2+ minutes, highlight force cancel
                    forceCancelBtn.classList.add('animate__animated', 'animate__pulse');
                    forceCancelBtn.title = `Job may be stuck (last update ${Math.floor(minutesSinceUpdate)} min ago). Use force cancel to stop it.`;
                }
            }
        }

        const statusBadge = getJobStatusBadge(job.status, job.cancel_requested, job.pause_requested);
        const created = job.created_at ? formatTimestamp(job.created_at) : 'Unknown';
        const started = job.started_at ? formatTimestamp(job.started_at) : '-';
        const completed = job.completed_at ? formatTimestamp(job.completed_at) : '-';

        let progressSection = '';
        if (job.status === 'running') {
            const progress = job.progress || 0;
            // Check if the progress message indicates an error or timeout
            const progressMsg = job.progress_message || 'Processing...';
            const isError = progressMsg.startsWith('✗') || progressMsg.includes('failed');
            const isTimeout = progressMsg.startsWith('⏱') || progressMsg.includes('timeout');
            let msgClass = 'text-muted';
            if (isError) msgClass = 'text-danger fw-bold';
            else if (isTimeout) msgClass = 'text-warning fw-bold';
            else if (progressMsg.startsWith('✓')) msgClass = 'text-success';

            progressSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Progress</h6>
                    <div class="progress mb-2" style="height: 20px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated"
                             style="width: ${progress}%">
                            ${progress}%
                        </div>
                    </div>
                    <div class="${msgClass} small">${escapeHtml(progressMsg)}</div>
                </div>
            `;
        } else if (job.status === 'queued' && job.queue_position) {
            progressSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Queue Status</h6>
                    <div class="alert alert-info">
                        <i class="bi bi-hourglass me-2"></i>
                        Position in queue: <strong>${job.queue_position}</strong>
                    </div>
                </div>
            `;
        } else if (job.status === 'paused') {
            progressSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Status</h6>
                    <div class="alert alert-warning">
                        <i class="bi bi-pause-fill me-2"></i>
                        This job is paused. Click <strong>Resume</strong> to continue.
                    </div>
                </div>
            `;
        }

        let resultSection = '';
        if (job.status === 'completed' && job.result_data) {
            resultSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Result</h6>
                    <pre class="bg-light p-3 rounded" style="max-height: 200px; overflow-y: auto;"><code>${escapeHtml(JSON.stringify(job.result_data, null, 2))}</code></pre>
                </div>
            `;
        }

        let errorSection = '';
        if (job.status === 'failed' && job.error_message) {
            errorSection = `
                <div class="mb-4">
                    <h6 class="text-muted mb-2">Error</h6>
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        ${escapeHtml(job.error_message)}
                    </div>
                </div>
            `;
        }

        bodyEl.innerHTML = `
            <div class="row mb-3">
                <div class="col-md-6">
                    <table class="table table-sm table-borderless">
                        <tr>
                            <td class="text-muted" style="width: 100px;">Status:</td>
                            <td>${statusBadge}</td>
                        </tr>
                        <tr>
                            <td class="text-muted">Type:</td>
                            <td><code>${escapeHtml(job.job_type)}</code></td>
                        </tr>
                        <tr>
                            <td class="text-muted">Job ID:</td>
                            <td><code>${job.id}</code></td>
                        </tr>
                    </table>
                </div>
                <div class="col-md-6">
                    <table class="table table-sm table-borderless">
                        <tr>
                            <td class="text-muted" style="width: 100px;">Created:</td>
                            <td>${created}</td>
                        </tr>
                        <tr>
                            <td class="text-muted">Started:</td>
                            <td>${started}</td>
                        </tr>
                        <tr>
                            <td class="text-muted">Completed:</td>
                            <td>${completed}</td>
                        </tr>
                    </table>
                </div>
            </div>
            ${progressSection}
            ${resultSection}
            ${errorSection}
        `;
    }

    async function cancelJobFromModal() {
        if (!currentJobDetailsId) return;
        if (!confirm('Cancel this job?')) return;

        try {
            const result = await jobManager.cancelJob(currentJobDetailsId);
            if (result.success) {
                showAlert('info', 'Job cancelled');
                refreshJobsList();
                bootstrap.Modal.getInstance(document.getElementById('jobDetailsModal')).hide();
            } else {
                showAlert('warning', result.error || 'Could not cancel job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function forceCancelJobFromModal() {
        if (!currentJobDetailsId) return;
        if (!confirm('Force cancel this job? This is useful for stuck/orphaned jobs that are not responding to normal cancellation.')) return;

        try {
            const result = await jobManager.forceCancelJob(currentJobDetailsId);
            if (result.success) {
                showAlert('info', 'Job force cancelled');
                refreshJobsList();
                bootstrap.Modal.getInstance(document.getElementById('jobDetailsModal')).hide();
            } else {
                showAlert('warning', result.error || 'Could not force cancel job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function pauseJobFromModal() {
        if (!currentJobDetailsId) return;

        try {
            const result = await jobManager.pauseJob(currentJobDetailsId);
            if (result.success) {
                showAlert('info', 'Job paused');
                refreshJobsList();
                refreshJobDetails(currentJobDetailsId);
            } else {
                showAlert('warning', result.error || 'Could not pause job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    async function resumeJobFromModal() {
        if (!currentJobDetailsId) return;

        try {
            const result = await jobManager.resumeJob(currentJobDetailsId);
            if (result.success) {
                showAlert('success', 'Job resumed');
                refreshJobsList();
                refreshJobDetails(currentJobDetailsId);
            } else {
                showAlert('warning', result.error || 'Could not resume job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    function updateJobsTabBadge() {
        if (jobManager) {
            jobManager.getServiceStatus().then(handleQueueUpdate);
        }
    }

    // Load jobs when tab is shown
    document.getElementById('jobs-tab')?.addEventListener('shown.bs.tab', function() {
        refreshJobsList();
    });

    // ============================================================================
    // Background Job Backup/Restore Functions
    // ============================================================================

    // Toggle visibility of custom delay input
    function updateBackupDelayUI() {
        const mode = document.getElementById('backupDelayMode').value;
        const customGroup = document.getElementById('backupCustomDelayGroup');
        if (mode === 'custom') {
            customGroup.classList.remove('d-none');
        } else {
            customGroup.classList.add('d-none');
        }
    }

    // Get the configured delay value for backup
    function getBackupDelayValue() {
        const mode = document.getElementById('backupDelayMode')?.value || 'auto';
        switch (mode) {
            case 'auto':
                return null;  // Let server calculate
            case 'fast':
                return 0;
            case 'normal':
                return 1.5;
            case 'slow':
                return 3;
            case 'custom':
                return parseFloat(document.getElementById('backupCustomDelay')?.value) || 1.5;
            default:
                return null;
        }
    }

    // Queue backup as background job instead of SSE
    async function startBackupJob() {
        const nodeId = document.getElementById('backupSourceNode').value;
        const backupName = document.getElementById('backupNameInput').value.trim();
        const description = document.getElementById('backupDescriptionInput').value.trim();
        const interRequestDelay = getBackupDelayValue();

        if (!nodeId) {
            showAlert('warning', 'Please select a node to backup');
            return;
        }
        if (!backupName) {
            showAlert('warning', 'Please enter a backup name');
            return;
        }

        const btn = document.getElementById('startBackupJobBtn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Queueing...';
        }

        try {
            const result = await jobManager.queueBackup(nodeId, backupName, description, interRequestDelay);

            if (result.success) {
                showAlert('success', `Backup job queued (position: ${result.queue_position || 1}). You can close this and check the Jobs tab for progress.`);

                // Close the modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('createBackupModal'));
                if (modal) modal.hide();

                // Show jobs tab badge update
                updateJobsTabBadge();
            } else {
                showAlert('warning', result.error || 'Failed to queue backup job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-cloud-download"></i> Create Backup';
            }
        }
    }

    // Queue restore as background job
    async function startRestoreJob() {
        // Get backup ID and target node from the restore button's dataset
        const startBtn = document.getElementById('startRestoreJobBtn');
        const backupId = startBtn?.dataset.backupId;
        const targetNodeId = startBtn?.dataset.targetNodeId;

        if (!backupId) {
            showAlert('warning', 'No backup selected');
            return;
        }

        if (!targetNodeId) {
            showAlert('warning', 'Please select a target node');
            return;
        }

        // Get selected items for selective restore
        const selectedItems = getSelectedRestoreItems();

        if (selectedItems.coreConfigs.length === 0 &&
            selectedItems.moduleConfigs.length === 0 &&
            selectedItems.channels.length === 0) {
            showAlert('warning', 'Please select at least one item to restore');
            return;
        }

        // Get options from the restore modal (restoreBackupModal)
        const skipLora = document.getElementById('restoreSkipLora')?.checked === true;
        const skipSecurity = document.getElementById('restoreSkipSecurity')?.checked !== false;
        const rebootAfter = document.getElementById('restoreRebootAfter')?.checked === true;

        const btn = document.getElementById('startRestoreJobBtn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Queueing...';
        }

        try {
            const result = await jobManager.queueRestore(backupId, targetNodeId, {
                skipLora,
                skipSecurity,
                rebootAfter,
                selectedCoreConfigs: selectedItems.coreConfigs,
                selectedModuleConfigs: selectedItems.moduleConfigs,
                selectedChannels: selectedItems.channels
            });

            if (result.success) {
                showAlert('success', `Restore job queued (position: ${result.queue_position || 1}). You can close this and check the Jobs tab for progress.`);

                // Close the restore modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('restoreBackupModal'));
                if (modal) modal.hide();

                // Show jobs tab badge update
                updateJobsTabBadge();
            } else {
                showAlert('warning', result.error || 'Failed to queue restore job');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-arrow-counterclockwise"></i> Start Restore';
            }
        }
    }

    function formatTimestamp(ts) {
        if (!ts) return 'Unknown';
        const d = new Date(ts * 1000);
        return d.toLocaleString();
    }
</script>
{% endblock %}
