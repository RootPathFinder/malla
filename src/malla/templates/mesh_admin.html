{% extends "base.html" %}

{% block title %}Mesh Admin - {{ APP_NAME }}{% endblock %}

{% block extra_css %}
<style>
    .admin-card {
        transition: all 0.2s ease;
    }
    .admin-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .node-admin-badge {
        font-size: 0.7rem;
        padding: 2px 6px;
    }
    .command-btn {
        min-width: 120px;
    }
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
    }
    .status-connected {
        background-color: #198754;
        box-shadow: 0 0 8px rgba(25, 135, 84, 0.5);
    }
    .status-disconnected {
        background-color: #dc3545;
    }
    .log-entry {
        font-size: 0.875rem;
    }
    .log-timestamp {
        color: #6c757d;
        font-family: monospace;
    }
    .log-status-success {
        color: #198754;
    }
    .log-status-failed {
        color: #dc3545;
    }
    .log-status-pending {
        color: #ffc107;
    }
    .log-status-timeout {
        color: #fd7e14;
    }
    .log-entry {
        cursor: pointer;
    }
    .log-entry:hover {
        background-color: var(--bs-tertiary-bg);
    }
    .log-details-popover {
        max-width: 450px;
        font-size: 0.8rem;
    }
    .log-details-popover .popover-body {
        padding: 0.75rem;
    }
    .log-details-section {
        margin-bottom: 0.5rem;
    }
    .log-details-section:last-child {
        margin-bottom: 0;
    }
    .log-details-label {
        font-weight: 600;
        color: var(--bs-secondary-color);
        font-size: 0.7rem;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
    }
    .log-details-content {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.75rem;
        background: var(--bs-tertiary-bg);
        padding: 0.5rem;
        border-radius: 0.25rem;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 150px;
        overflow-y: auto;
    }
    [data-bs-theme="dark"] .log-details-content {
        background: #161b22;
    }
    .log-error-content {
        color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
    }
    .log-success-content {
        color: #198754;
    }
    /* Node autocomplete styles */
    .node-autocomplete-container {
        position: relative;
    }
    .node-autocomplete-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        z-index: 1000;
        max-height: 300px;
        overflow-y: auto;
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-top: none;
        border-radius: 0 0 0.375rem 0.375rem;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .node-autocomplete-item {
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        border-bottom: 1px solid var(--bs-border-color);
    }
    .node-autocomplete-item:last-child {
        border-bottom: none;
    }
    .node-autocomplete-item:hover,
    .node-autocomplete-item.active {
        background: var(--bs-primary);
        color: white;
    }
    .node-autocomplete-item .node-name {
        font-weight: 500;
    }
    .node-autocomplete-item .node-id {
        font-size: 0.8rem;
        font-family: monospace;
        opacity: 0.8;
    }
    .config-display {
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', monospace;
        font-size: 0.8rem;
        background: var(--bs-tertiary-bg);
        color: var(--bs-body-color);
        padding: 1rem;
        border-radius: 0.5rem;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--bs-border-color);
    }
    [data-bs-theme="dark"] .config-display {
        background: #161b22;
        border-color: #30363d;
    }
    .config-form {
        max-height: 500px;
        overflow-y: auto;
        padding: 1rem;
        background: var(--bs-tertiary-bg);
        border-radius: 0.5rem;
        border: 1px solid var(--bs-border-color);
    }
    [data-bs-theme="dark"] .config-form {
        background: #161b22;
        border-color: #30363d;
    }
    .config-form .form-control,
    .config-form .form-select {
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        border-color: var(--bs-border-color);
    }
    .config-form .form-control:focus,
    .config-form .form-select:focus {
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        border-color: var(--bs-primary);
    }
    [data-bs-theme="dark"] .config-form .form-control,
    [data-bs-theme="dark"] .config-form .form-select {
        background-color: #0d1117;
        color: #c9d1d9;
        border-color: #30363d;
    }
    [data-bs-theme="dark"] .config-form .form-control:focus,
    [data-bs-theme="dark"] .config-form .form-select:focus {
        background-color: #0d1117;
        border-color: var(--bs-primary);
    }
    [data-bs-theme="dark"] .config-form .form-control::placeholder {
        color: #6e7681;
    }
    .config-field {
        margin-bottom: 1rem;
    }
    .config-field label {
        font-weight: 500;
        color: var(--bs-body-color);
    }
    .config-field .form-text {
        font-size: 0.75rem;
        color: var(--bs-secondary-color);
    }
    .config-field-unit {
        font-size: 0.8rem;
        color: var(--bs-secondary-color);
    }
    [data-bs-theme="dark"] .config-field-unit {
        color: #8b949e;
    }
    .spinner-border-sm {
        width: 1rem;
        height: 1rem;
    }
    #nodeSearchResults {
        max-height: 300px;
        overflow-y: auto;
    }
    /* Admin status banner styles */
    .admin-status-banner {
        border-radius: 0.5rem;
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
        border: 1px solid;
    }
    .admin-status-banner.status-success {
        background-color: rgba(25, 135, 84, 0.1);
        border-color: rgba(25, 135, 84, 0.3);
    }
    .admin-status-banner.status-warning {
        background-color: rgba(255, 193, 7, 0.1);
        border-color: rgba(255, 193, 7, 0.3);
    }
    .admin-status-banner.status-danger {
        background-color: rgba(220, 53, 69, 0.1);
        border-color: rgba(220, 53, 69, 0.3);
    }
    .admin-status-banner .status-icon {
        font-size: 1.25rem;
        margin-right: 0.5rem;
    }
    .admin-status-banner .status-message {
        font-weight: 500;
    }
    .admin-status-banner .status-details {
        font-size: 0.85rem;
        margin-top: 0.5rem;
    }
    .admin-status-banner .check-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0;
    }
    .admin-status-banner .check-item i {
        font-size: 0.9rem;
    }
    .admin-status-banner .check-passed {
        color: #198754;
    }
    .admin-status-banner .check-failed {
        color: #dc3545;
    }
    .admin-status-banner .suggestions {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid var(--bs-border-color);
    }
    .admin-status-banner .suggestion-item {
        font-size: 0.85rem;
        color: var(--bs-secondary-color);
        margin-top: 0.25rem;
    }
    .admin-status-banner .suggestion-item i {
        color: var(--bs-info);
        margin-right: 0.25rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/">Home</a></li>
                    <li class="breadcrumb-item active">Mesh Admin</li>
                </ol>
            </nav>
            <h1>
                <i class="bi bi-gear-wide-connected"></i> Mesh Admin
                <small class="text-muted fs-5">Remote Node Administration</small>
            </h1>
        </div>
    </div>

    <!-- Connection Status Card -->
    <div class="row mb-4">
        <div class="col-lg-6">
            <div class="card admin-card">
                <div class="card-header">
                    <i class="bi bi-wifi"></i> Connection Status
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="connectionTypeSelect" class="form-label"><strong>Connection Type</strong></label>
                            <select class="form-select" id="connectionTypeSelect" onchange="changeConnectionType()">
                                <option value="mqtt" {{ 'selected' if connection_status.connection_type == 'mqtt' else '' }}>MQTT (via broker)</option>
                                <option value="tcp" {{ 'selected' if connection_status.connection_type == 'tcp' else '' }}>TCP (direct connection)</option>
                                <option value="serial" {{ 'selected' if connection_status.connection_type == 'serial' else '' }}>USB/Serial (local device)</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <p class="mb-2 mt-4">
                                <strong>Status:</strong>
                                <span id="connectionStatus">
                                    {% if connection_status.connected %}
                                        <span class="status-indicator status-connected"></span>Connected
                                    {% else %}
                                        <span class="status-indicator status-disconnected"></span>Disconnected
                                    {% endif %}
                                </span>
                            </p>
                        </div>
                    </div>

                    <!-- MQTT Settings -->
                    <div id="mqttSettings" class="{{ 'd-none' if connection_status.connection_type != 'mqtt' else '' }}">
                        <div class="row">
                            <div class="col-md-6">
                                <p class="mb-2">
                                    <strong>MQTT Connected:</strong>
                                    <span id="mqttStatus">
                                        {% if connection_status.mqtt_connected %}
                                            <span class="badge bg-success">Yes</span>
                                        {% else %}
                                            <span class="badge bg-secondary">No</span>
                                        {% endif %}
                                    </span>
                                </p>
                            </div>
                            <div class="col-md-6">
                                <p class="mb-2">
                                    <strong>Gateway Node:</strong>
                                    <span id="gatewayNodeDisplay">
                                        {% if connection_status.gateway_node_hex %}
                                            <code>{{ connection_status.gateway_node_hex }}</code>
                                        {% else %}
                                            <span class="text-warning">Not configured</span>
                                        {% endif %}
                                    </span>
                                </p>
                            </div>
                        </div>
                        <hr>
                        <div class="row">
                            <div class="col">
                                <label for="gatewayNodeInput" class="form-label">Set Gateway Node ID</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="gatewayNodeInput"
                                           placeholder="e.g., !abcd1234 or 2882400052"
                                           value="{{ connection_status.gateway_node_hex or '' }}">
                                    <button class="btn btn-primary" type="button" onclick="setGatewayNode()">
                                        <i class="bi bi-check-lg"></i> Set Gateway
                                    </button>
                                </div>
                                <div class="form-text">
                                    The gateway node is the Meshtastic device connected to the MQTT broker that will relay admin commands.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TCP Settings -->
                    <div id="tcpSettings" class="{{ 'd-none' if connection_status.connection_type != 'tcp' else '' }}">
                        <div class="row mb-3">
                            <div class="col-md-8">
                                <label for="tcpHostInput" class="form-label">Node IP Address</label>
                                <input type="text" class="form-control" id="tcpHostInput"
                                       placeholder="192.168.1.1"
                                       value="{{ connection_status.tcp_host or '192.168.1.1' }}">
                            </div>
                            <div class="col-md-4">
                                <label for="tcpPortInput" class="form-label">Port</label>
                                <input type="number" class="form-control" id="tcpPortInput"
                                       placeholder="4403"
                                       value="{{ connection_status.tcp_port or 4403 }}">
                            </div>
                        </div>
                        <div class="row mb-2">
                            <div class="col">
                                <button class="btn btn-success me-2" type="button" onclick="tcpConnect()" id="tcpConnectBtn">
                                    <i class="bi bi-plug"></i> Connect
                                </button>
                                <button class="btn btn-outline-danger" type="button" onclick="tcpDisconnect()" id="tcpDisconnectBtn">
                                    <i class="bi bi-x-circle"></i> Disconnect
                                </button>
                            </div>
                        </div>
                        <div id="tcpConnectResult" class="alert d-none mt-2" role="alert"></div>
                        <div class="form-text">
                            Connect directly to a Meshtastic node via TCP. The node must have WiFi enabled and be accessible on the network.
                        </div>
                    </div>

                    <!-- Serial/USB Settings -->
                    <div id="serialSettings" class="{{ 'd-none' if connection_status.connection_type != 'serial' else '' }}">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="serialPortSelect" class="form-label">Serial Port</label>
                                <select class="form-select" id="serialPortSelect">
                                    <option value="">-- Select USB/Serial to scan --</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">&nbsp;</label>
                                <button class="btn btn-outline-secondary d-block w-100" type="button" onclick="discoverSerialPorts()">
                                    <i class="bi bi-search"></i> Discover
                                </button>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">&nbsp;</label>
                                <button class="btn btn-outline-info d-block w-100" type="button" onclick="probeSerialDevices()" id="probeDevicesBtn">
                                    <i class="bi bi-cpu"></i> Identify
                                </button>
                            </div>
                        </div>
                        <div id="serialPortInfo" class="alert alert-info d-none mb-3" role="alert">
                            <small></small>
                        </div>
                        <div class="row mb-2">
                            <div class="col">
                                <button class="btn btn-success me-2" type="button" onclick="serialConnect()" id="serialConnectBtn">
                                    <i class="bi bi-usb-plug"></i> Connect
                                </button>
                                <button class="btn btn-outline-danger" type="button" onclick="serialDisconnect()" id="serialDisconnectBtn">
                                    <i class="bi bi-x-circle"></i> Disconnect
                                </button>
                            </div>
                        </div>
                        <div id="serialConnectResult" class="alert d-none mt-2" role="alert"></div>
                        <div class="form-text">
                            <strong>Discover</strong> scans for USB ports. <strong>Identify</strong> connects briefly to detect actual Meshtastic hardware (takes a few seconds per device).
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Test Node Card -->
        <div class="col-lg-6">
            <div class="card admin-card">
                <div class="card-header">
                    <i class="bi bi-search"></i> Test Node Admin Access
                </div>
                <div class="card-body">
                    <p class="text-muted mb-3">
                        Test if a node has this server's public key configured and can be remotely administered.
                    </p>
                    <div class="node-autocomplete-container mb-3">
                        <div class="input-group">
                            <input type="text" class="form-control" id="testNodeInput"
                                   placeholder="Start typing node name or ID..."
                                   autocomplete="off"
                                   oninput="searchNodes(this.value, 'testNodeResults')"
                                   onfocus="if(this.value.length >= 1) searchNodes(this.value, 'testNodeResults')"
                                   onblur="setTimeout(() => hideAutocomplete('testNodeResults'), 200)">
                            <button class="btn btn-outline-primary" type="button" onclick="testNodeAdmin()" id="testNodeBtn">
                                <i class="bi bi-lightning"></i> Test
                            </button>
                        </div>
                        <div id="testNodeResults" class="node-autocomplete-results" style="display:none;"></div>
                    </div>
                    <div id="testNodeResult" class="alert d-none" role="alert"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Tabs -->
    <div class="row">
        <div class="col">
            <ul class="nav nav-tabs" id="adminTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="nodes-tab" data-bs-toggle="tab"
                            data-bs-target="#nodes-pane" type="button" role="tab">
                        <i class="bi bi-router"></i> Administrable Nodes
                        <span class="badge bg-primary">{{ administrable_nodes|length }}</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="commands-tab" data-bs-toggle="tab"
                            data-bs-target="#commands-pane" type="button" role="tab">
                        <i class="bi bi-terminal"></i> Send Command
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="templates-tab" data-bs-toggle="tab"
                            data-bs-target="#templates-pane" type="button" role="tab">
                        <i class="bi bi-file-earmark-code"></i> Config Templates
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="log-tab" data-bs-toggle="tab"
                            data-bs-target="#log-pane" type="button" role="tab">
                        <i class="bi bi-journal-text"></i> Audit Log
                    </button>
                </li>
            </ul>

            <div class="tab-content border border-top-0 rounded-bottom p-3" id="adminTabContent">
                <!-- Administrable Nodes Tab -->
                <div class="tab-pane fade show active" id="nodes-pane" role="tabpanel">
                    {% if administrable_nodes %}
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Node</th>
                                        <th>Hardware</th>
                                        <th>Firmware</th>
                                        <th>Uptime</th>
                                        <th>Capabilities</th>
                                        <th>Status</th>
                                        <th>Last Confirmed</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="administrableNodesBody">
                                    {% for node in administrable_nodes %}
                                    <tr id="admin-node-row-{{ node.node_id }}">
                                        <td>
                                            <a href="/node/{{ node.node_id }}" class="text-decoration-none">
                                                <strong>{{ node.long_name or node.short_name or 'Unknown' }}</strong>
                                            </a>
                                            <br>
                                            <code class="text-muted small">{{ node.hex_id or ('!' + '%08x'|format(node.node_id)) }}</code>
                                        </td>
                                        <td id="admin-node-hw-{{ node.node_id }}">{{ node.hw_model or 'Unknown' }}</td>
                                        <td id="admin-node-fw-{{ node.node_id }}">{{ node.firmware_version or 'Unknown' }}</td>
                                        <td id="admin-node-uptime-{{ node.node_id }}">
                                            <span class="text-muted small">—</span>
                                        </td>
                                        <td id="admin-node-caps-{{ node.node_id }}">
                                            <span class="text-muted small">—</span>
                                        </td>
                                        <td id="admin-node-status-{{ node.node_id }}">
                                            {% if node.last_status_result == 'online' %}
                                                <span class="badge bg-success"><i class="bi bi-check-circle"></i> Online</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'timeout' %}
                                                <span class="badge bg-warning text-dark"><i class="bi bi-clock"></i> Timeout</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'error' %}
                                                <span class="badge bg-danger"><i class="bi bi-x-circle"></i> Error</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% elif node.last_status_result == 'offline' %}
                                                <span class="badge bg-danger"><i class="bi bi-x-circle"></i> Offline</span>
                                                {% if node.last_status_check %}
                                                <br><span class="text-muted small">{{ node.last_status_check | timestamp_to_datetime }}</span>
                                                {% endif %}
                                            {% else %}
                                                <span class="badge bg-secondary">Not checked</span>
                                            {% endif %}
                                        </td>
                                        <td id="admin-node-confirmed-{{ node.node_id }}">
                                            <span class="text-muted small">
                                                {{ node.last_confirmed | timestamp_to_datetime }}
                                            </span>
                                        </td>
                                        <td>
                                            <div class="btn-group btn-group-sm">
                                                <button class="btn btn-outline-success"
                                                        onclick="refreshNodeAdminInfo({{ node.node_id }})"
                                                        title="Refresh admin info"
                                                        id="admin-node-refresh-btn-{{ node.node_id }}">
                                                    <i class="bi bi-arrow-repeat"></i>
                                                </button>
                                                <button class="btn btn-outline-primary"
                                                        onclick="selectNode({{ node.node_id }})"
                                                        title="Select for commands">
                                                    <i class="bi bi-cursor"></i>
                                                </button>
                                                <button class="btn btn-outline-info"
                                                        onclick="getNodeConfig({{ node.node_id }}, 'device')"
                                                        title="Get device config">
                                                    <i class="bi bi-gear"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    {% else %}
                        <div class="text-center py-5">
                            <i class="bi bi-inbox text-muted" style="font-size: 4rem;"></i>
                            <h4 class="mt-3">No Administrable Nodes Found</h4>
                            <p class="text-muted">
                                Nodes will appear here once they respond to admin requests.<br>
                                Use the "Test Node Admin Access" feature above to check if a node is administrable.
                            </p>
                        </div>
                    {% endif %}
                </div>

                <!-- Send Command Tab -->
                <div class="tab-pane fade" id="commands-pane" role="tabpanel">
                    <div class="row">
                        <div class="col-lg-6">
                            <div class="mb-3 node-autocomplete-container">
                                <label for="targetNodeInput" class="form-label">Target Node</label>
                                <input type="text" class="form-control" id="targetNodeInput"
                                       placeholder="Start typing node name or ID..."
                                       autocomplete="off"
                                       oninput="searchNodes(this.value, 'targetNodeResults'); checkAdminStatusDebounced()"
                                       onfocus="if(this.value.length >= 1) searchNodes(this.value, 'targetNodeResults')"
                                       onblur="setTimeout(() => hideAutocomplete('targetNodeResults'), 200)">
                                <div id="targetNodeResults" class="node-autocomplete-results" style="display:none;"></div>
                            </div>

                            <!-- Admin Status Banner -->
                            <div id="adminStatusBanner" class="admin-status-banner d-none">
                                <div class="d-flex align-items-start">
                                    <i class="status-icon bi" id="adminStatusIcon"></i>
                                    <div class="flex-grow-1">
                                        <div class="status-message" id="adminStatusMessage"></div>
                                        <div class="status-details" id="adminStatusDetails"></div>
                                        <div class="suggestions" id="adminStatusSuggestions"></div>
                                    </div>
                                    <button type="button" class="btn btn-sm btn-outline-primary ms-2"
                                            onclick="refreshAdminStatus()" title="Refresh status">
                                        <i class="bi bi-arrow-clockwise"></i>
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Configuration Requests</label>
                                <div class="d-flex flex-wrap gap-2">
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('device')">
                                        <i class="bi bi-cpu"></i> Device
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('lora')">
                                        <i class="bi bi-broadcast"></i> LoRa
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('position')">
                                        <i class="bi bi-geo-alt"></i> Position
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('power')">
                                        <i class="bi bi-battery-charging"></i> Power
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('network')">
                                        <i class="bi bi-wifi"></i> Network
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('display')">
                                        <i class="bi bi-display"></i> Display
                                    </button>
                                    <button class="btn btn-outline-secondary command-btn"
                                            onclick="getConfig('bluetooth')">
                                        <i class="bi bi-bluetooth"></i> Bluetooth
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Channel Requests</label>
                                <div class="d-flex flex-wrap gap-2">
                                    {% for i in range(8) %}
                                    <button class="btn btn-outline-info btn-sm"
                                            onclick="getChannel({{ i }})">
                                        Ch {{ i }}
                                    </button>
                                    {% endfor %}
                                </div>
                            </div>

                            <hr>

                            <div class="mb-3">
                                <label class="form-label text-danger">Dangerous Commands</label>
                                <div class="d-flex flex-wrap gap-2">
                                    <button class="btn btn-warning command-btn" onclick="confirmRebootTarget()">
                                        <i class="bi bi-arrow-clockwise"></i> Reboot
                                    </button>
                                    <button class="btn btn-danger command-btn" onclick="confirmShutdownTarget()">
                                        <i class="bi bi-power"></i> Shutdown
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="col-lg-6">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Response</label>
                                <div class="btn-group btn-group-sm" id="responseViewToggle" style="display:none;">
                                    <button type="button" class="btn btn-outline-secondary active" onclick="showFormView()">
                                        <i class="bi bi-ui-checks"></i> Form
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" onclick="showJsonView()">
                                        <i class="bi bi-code-square"></i> JSON
                                    </button>
                                </div>
                            </div>
                            <div id="commandResponseForm" class="config-form" style="display:none;">
                                <form id="configEditForm">
                                    <div id="configFields">
                                        <!-- Dynamic config fields will be rendered here -->
                                    </div>
                                    <div class="d-flex gap-2 mt-3" id="configFormActions" style="display:none;">
                                        <button type="button" class="btn btn-primary" onclick="saveConfig()">
                                            <i class="bi bi-check-lg"></i> Save Changes
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary" onclick="refreshConfig()">
                                            <i class="bi bi-arrow-clockwise"></i> Refresh
                                        </button>
                                    </div>
                                </form>
                            </div>
                            <div id="commandResponse" class="config-display">
                                <span class="text-muted">Response will appear here...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Config Templates Tab -->
                <div class="tab-pane fade" id="templates-pane" role="tabpanel">
                    <div class="row">
                        <!-- Templates List -->
                        <div class="col-md-5">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0"><i class="bi bi-file-earmark-code"></i> Saved Templates</h6>
                                <div class="dropdown">
                                    <button class="btn btn-primary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                        <i class="bi bi-plus-lg"></i> New Template
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-end">
                                        <li><a class="dropdown-item" href="#" onclick="showCreateTemplateModal(); return false;">
                                            <i class="bi bi-pencil"></i> Create Empty Template
                                        </a></li>
                                        <li><a class="dropdown-item" href="#" onclick="showCreateFromNodeModal(); return false;">
                                            <i class="bi bi-download"></i> Create from Node
                                        </a></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="mb-2">
                                <select class="form-select form-select-sm" id="templateTypeFilter" onchange="loadTemplates()">
                                    <option value="">All Types</option>
                                    <option value="device">Device</option>
                                    <option value="lora">LoRa</option>
                                    <option value="channel">Channel (Single)</option>
                                    <option value="channels">Channels (Full Set)</option>
                                    <option value="position">Position</option>
                                    <option value="power">Power</option>
                                    <option value="network">Network</option>
                                    <option value="display">Display</option>
                                    <option value="bluetooth">Bluetooth</option>
                                    <option value="security">Security</option>
                                </select>
                            </div>
                            <div id="templatesList" class="list-group" style="max-height: 400px; overflow-y: auto;">
                                <div class="text-center py-3 text-muted">
                                    <i class="bi bi-arrow-clockwise spin"></i> Loading templates...
                                </div>
                            </div>
                        </div>

                        <!-- Template Editor / Deploy -->
                        <div class="col-md-7">
                            <div id="templateEditorSection" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0" id="templateEditorTitle">
                                        <i class="bi bi-pencil"></i> Edit Template
                                    </h6>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-success" onclick="saveTemplate()" id="saveTemplateBtn">
                                            <i class="bi bi-save"></i> Save
                                        </button>
                                        <button class="btn btn-outline-danger" onclick="deleteTemplate()" id="deleteTemplateBtn">
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Template Name</label>
                                    <input type="text" class="form-control" id="templateName" placeholder="e.g., Standard LoRa Settings">
                                </div>
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label class="form-label">Type</label>
                                        <select class="form-select" id="templateType">
                                            <option value="device">Device</option>
                                            <option value="lora">LoRa</option>
                                            <option value="channel">Channel (Single)</option>
                                            <option value="channels">Channels (Full Set)</option>
                                            <option value="position">Position</option>
                                            <option value="power">Power</option>
                                            <option value="network">Network</option>
                                            <option value="display">Display</option>
                                            <option value="bluetooth">Bluetooth</option>
                                            <option value="security">Security</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label">Description</label>
                                        <input type="text" class="form-control" id="templateDescription" placeholder="Optional description">
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Configuration (JSON)</label>
                                    <textarea class="form-control font-monospace" id="templateConfigData" rows="8"
                                              placeholder='{"region": "US", "modem_preset": "LONG_FAST"}'></textarea>
                                    <div class="form-text">
                                        Enter the configuration as JSON. See
                                        <a href="https://meshtastic.org/docs/configuration/" target="_blank">Meshtastic docs</a>
                                        for available settings.
                                    </div>
                                </div>

                                <!-- Deploy Section -->
                                <div class="card bg-light">
                                    <div class="card-header">
                                        <i class="bi bi-send"></i> Deploy Template
                                    </div>
                                    <div class="card-body">
                                        <div class="mb-3">
                                            <label class="form-label">Select Target Nodes</label>
                                            <div id="deployNodesList" class="border rounded p-2" style="max-height: 150px; overflow-y: auto;">
                                                <span class="text-muted small">Loading administrable nodes...</span>
                                            </div>
                                            <div class="form-text">
                                                <button class="btn btn-link btn-sm p-0" onclick="selectAllDeployNodes()">Select All</button>
                                                |
                                                <button class="btn btn-link btn-sm p-0" onclick="deselectAllDeployNodes()">Deselect All</button>
                                            </div>
                                        </div>
                                        <button class="btn btn-success" onclick="deployTemplate()" id="deployTemplateBtn">
                                            <i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes
                                        </button>
                                        <div id="deploymentResults" class="mt-3" style="display: none;"></div>
                                    </div>
                                </div>
                            </div>

                            <div id="templatePlaceholder">
                                <div class="text-center py-5 text-muted">
                                    <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                                    <p class="mt-3">Select a template from the list to edit or deploy,<br>or create a new template.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Deployment History -->
                    <div class="mt-4">
                        <h6><i class="bi bi-clock-history"></i> Recent Deployments</h6>
                        <div id="deploymentHistory" class="table-responsive" style="max-height: 200px; overflow-y: auto;">
                            <table class="table table-sm table-hover">
                                <thead class="table-light sticky-top">
                                    <tr>
                                        <th>Template</th>
                                        <th>Node</th>
                                        <th>Status</th>
                                        <th>Time</th>
                                    </tr>
                                </thead>
                                <tbody id="deploymentHistoryBody">
                                    <tr>
                                        <td colspan="4" class="text-center text-muted">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Audit Log Tab -->
                <div class="tab-pane fade" id="log-pane" role="tabpanel">
                    <div class="mb-3">
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshLog()">
                            <i class="bi bi-arrow-clockwise"></i> Refresh
                        </button>
                    </div>
                    <div id="auditLogContainer">
                        <div class="text-center py-3">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Confirmation Modal -->
<div class="modal fade" id="confirmModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="confirmModalTitle">Confirm Action</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="confirmModalBody">
                Are you sure?
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmModalBtn">Confirm</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Template from Node Modal -->
<div class="modal fade" id="createFromNodeModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-download"></i> Create Template from Node
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted mb-3">
                    Extract the current configuration from an existing node to use as a template.
                    Node-specific settings (like location, credentials, etc.) will be automatically removed.
                </p>

                <!-- Step 1: Select Node and Config Type -->
                <div id="extractStep1">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Source Node</label>
                            <select class="form-select" id="extractSourceNode">
                                <option value="">Select an administrable node...</option>
                            </select>
                            <div class="form-text">Select a node to extract config from</div>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Config Type</label>
                            <select class="form-select" id="extractConfigType">
                                <option value="device">Device</option>
                                <option value="lora" selected>LoRa</option>
                                <option value="position">Position</option>
                                <option value="power">Power</option>
                                <option value="network">Network</option>
                                <option value="display">Display</option>
                                <option value="bluetooth">Bluetooth</option>
                                <option value="security">Security</option>
                                <option value="channel">Channel (Single)</option>
                                <option value="channels">Channels (Full Set)</option>
                            </select>
                        </div>
                    </div>
                    <div class="mb-3" id="channelIndexRow" style="display: none;">
                        <label class="form-label">Channel Index</label>
                        <select class="form-select" id="extractChannelIndex">
                            <option value="0">Primary (0)</option>
                            <option value="1">Secondary (1)</option>
                            <option value="2">Channel 2</option>
                            <option value="3">Channel 3</option>
                            <option value="4">Channel 4</option>
                            <option value="5">Channel 5</option>
                            <option value="6">Channel 6</option>
                            <option value="7">Channel 7</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="extractConfigFromNode()" id="extractConfigBtn">
                        <i class="bi bi-cloud-download"></i> Extract Configuration
                    </button>

                    <!-- Real-time extraction progress -->
                    <div id="extractionProgress" class="mt-3" style="display: none;">
                        <div class="card bg-light">
                            <div class="card-body py-2">
                                <div class="d-flex align-items-center mb-2">
                                    <span class="spinner-border spinner-border-sm text-primary me-2"></span>
                                    <strong id="extractionStatus">Connecting to node...</strong>
                                </div>
                                <div class="progress" style="height: 8px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated"
                                         role="progressbar"
                                         id="extractionProgressBar"
                                         style="width: 0%"></div>
                                </div>
                                <small class="text-muted mt-1 d-block" id="extractionDetails"></small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Review and Name -->
                <div id="extractStep2" style="display: none;">
                    <div class="alert alert-success mb-3">
                        <i class="bi bi-check-circle"></i>
                        Configuration extracted successfully from node <strong id="extractedFromNode"></strong>
                    </div>

                    <div id="excludedFieldsWarning" class="alert alert-info mb-3" style="display: none;">
                        <i class="bi bi-info-circle"></i>
                        <strong>Note:</strong> The following node-specific fields were removed:
                        <code id="excludedFieldsList"></code>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Template Name</label>
                        <input type="text" class="form-control" id="extractTemplateName"
                               placeholder="e.g., Standard LoRa Settings">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Description (optional)</label>
                        <input type="text" class="form-control" id="extractTemplateDescription"
                               placeholder="Describe what this template is for">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Extracted Configuration</label>
                        <textarea class="form-control font-monospace" id="extractedConfigData" rows="10" readonly></textarea>
                        <div class="form-text">
                            You can edit this configuration after creating the template.
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-outline-secondary" id="extractBackBtn" style="display: none;"
                        onclick="resetExtractModal()">
                    <i class="bi bi-arrow-left"></i> Back
                </button>
                <button type="button" class="btn btn-success" id="saveExtractedTemplateBtn" style="display: none;"
                        onclick="saveExtractedTemplate()">
                    <i class="bi bi-save"></i> Create Template
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let selectedNodeId = null;
    let currentConfigType = null;
    let currentConfigData = null;
    let currentConfigSchema = null;
    let searchTimeout = null;
    let cachedNodes = null;
    let adminStatusTimeout = null;
    let lastCheckedNodeId = null;

    // ============================================================================
    // Admin Status Checking
    // ============================================================================

    // Debounced function to check admin status when typing
    function checkAdminStatusDebounced() {
        if (adminStatusTimeout) {
            clearTimeout(adminStatusTimeout);
        }
        adminStatusTimeout = setTimeout(() => {
            const nodeId = document.getElementById('targetNodeInput').value.trim();
            if (nodeId && nodeId.length >= 3) {
                checkAdminStatus(nodeId);
            } else {
                hideAdminStatusBanner();
            }
        }, 500);
    }

    // Check admin status for a node
    async function checkAdminStatus(nodeId) {
        // Don't re-check the same node
        if (nodeId === lastCheckedNodeId) {
            return;
        }
        lastCheckedNodeId = nodeId;

        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Show loading state
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');
        banner.classList.add('status-warning');
        iconEl.className = 'status-icon bi bi-hourglass-split text-warning';
        messageEl.textContent = 'Checking admin channel status...';
        detailsEl.innerHTML = '';
        suggestionsEl.innerHTML = '';

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/status`);
            const data = await response.json();

            if (data.error) {
                showAdminStatusError(data.error);
                return;
            }

            displayAdminStatus(data);
        } catch (error) {
            showAdminStatusError(error.message);
        }
    }

    // Refresh admin status for current node
    function refreshAdminStatus() {
        lastCheckedNodeId = null; // Force refresh
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (nodeId) {
            checkAdminStatus(nodeId);
        }
    }

    // Display admin status in the banner
    function displayAdminStatus(status) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Reset classes
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');

        // Set status level styling
        const level = status.status_level || 'warning';
        banner.classList.add(`status-${level}`);

        // Set icon
        if (level === 'success') {
            iconEl.className = 'status-icon bi bi-check-circle-fill text-success';
        } else if (level === 'warning') {
            iconEl.className = 'status-icon bi bi-exclamation-triangle-fill text-warning';
        } else {
            iconEl.className = 'status-icon bi bi-x-circle-fill text-danger';
        }

        // Set message
        messageEl.textContent = status.status_message || 'Unknown status';

        // Build checks display
        let checksHtml = '';
        if (status.checks && status.checks.length > 0) {
            for (const check of status.checks) {
                const checkClass = check.passed ? 'check-passed' : 'check-failed';
                const checkIcon = check.passed ? 'bi-check-circle-fill' : 'bi-x-circle-fill';
                checksHtml += `
                    <div class="check-item ${checkClass}">
                        <i class="bi ${checkIcon}"></i>
                        <span>${escapeHtml(check.message)}</span>
                    </div>
                `;
            }
        }
        detailsEl.innerHTML = checksHtml;

        // Build suggestions display
        let suggestionsHtml = '';
        if (status.suggestions && status.suggestions.length > 0) {
            for (const suggestion of status.suggestions) {
                suggestionsHtml += `
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        ${escapeHtml(suggestion)}
                    </div>
                `;
            }
        }

        // Add test button if node is not administrable
        const nodeAdminCheck = status.checks?.find(c => c.name === 'node_administrable');
        if (nodeAdminCheck && !nodeAdminCheck.passed) {
            suggestionsHtml += `
                <div class="mt-2">
                    <button class="btn btn-sm btn-outline-primary" onclick="testCurrentNode()">
                        <i class="bi bi-lightning"></i> Test Admin Access Now
                    </button>
                </div>
            `;
        }

        suggestionsEl.innerHTML = suggestionsHtml;
        if (!suggestionsHtml) {
            suggestionsEl.classList.add('d-none');
        } else {
            suggestionsEl.classList.remove('d-none');
        }
    }

    // Show error in admin status banner
    function showAdminStatusError(errorMessage) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        banner.classList.remove('d-none', 'status-success', 'status-warning');
        banner.classList.add('status-danger');
        iconEl.className = 'status-icon bi bi-exclamation-octagon-fill text-danger';
        messageEl.textContent = 'Error checking admin status';
        detailsEl.innerHTML = `<span class="text-danger">${escapeHtml(errorMessage)}</span>`;
        suggestionsEl.innerHTML = '';
    }

    // Update admin status banner with a simple message (for reboot/shutdown status)
    function updateAdminStatusBanner(level, message, details) {
        const banner = document.getElementById('adminStatusBanner');
        const iconEl = document.getElementById('adminStatusIcon');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        if (!banner) return;

        // Reset classes
        banner.classList.remove('d-none', 'status-success', 'status-warning', 'status-danger');
        banner.classList.add(`status-${level}`);

        // Set icon based on level
        if (level === 'success') {
            iconEl.className = 'status-icon bi bi-check-circle-fill text-success';
        } else if (level === 'warning') {
            iconEl.className = 'status-icon bi bi-hourglass-split text-warning';
        } else {
            iconEl.className = 'status-icon bi bi-x-circle-fill text-danger';
        }

        messageEl.textContent = message || '';
        detailsEl.innerHTML = details ? `<span class="text-muted">${escapeHtml(details)}</span>` : '';
        suggestionsEl.innerHTML = '';
        suggestionsEl.classList.add('d-none');
    }

    // Hide admin status banner
    function hideAdminStatusBanner() {
        const banner = document.getElementById('adminStatusBanner');
        banner.classList.add('d-none');
        lastCheckedNodeId = null;
    }

    // Test admin access for the current target node
    async function testCurrentNode() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const banner = document.getElementById('adminStatusBanner');
        const messageEl = document.getElementById('adminStatusMessage');
        const detailsEl = document.getElementById('adminStatusDetails');
        const suggestionsEl = document.getElementById('adminStatusSuggestions');

        // Show testing state
        banner.classList.remove('status-success', 'status-danger');
        banner.classList.add('status-warning');
        document.getElementById('adminStatusIcon').className = 'status-icon bi bi-hourglass-split text-warning';
        messageEl.textContent = 'Testing admin access...';
        detailsEl.innerHTML = '<div class="spinner-border spinner-border-sm text-primary" role="status"></div> Sending device metadata request...';
        suggestionsEl.innerHTML = '';

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const data = await response.json();

            if (data.success && data.administrable) {
                // Refresh status to show updated state
                lastCheckedNodeId = null;
                await checkAdminStatus(nodeId);
                showAlert('success', `Node ${data.hex_id} is administrable!`);
            } else {
                // Show failure in banner
                banner.classList.remove('status-warning');
                banner.classList.add('status-danger');
                document.getElementById('adminStatusIcon').className = 'status-icon bi bi-x-circle-fill text-danger';
                messageEl.textContent = 'Admin test failed';
                detailsEl.innerHTML = `<span class="text-danger">${escapeHtml(data.error || 'No response from node')}</span>`;
                suggestionsEl.innerHTML = `
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        Ensure the node has this server's public key configured
                    </div>
                    <div class="suggestion-item">
                        <i class="bi bi-lightbulb"></i>
                        Check that the node is within radio range of the gateway
                    </div>
                `;
            }
        } catch (error) {
            showAdminStatusError(error.message);
        }
    }

    // ============================================================================
    // Node Autocomplete
    // ============================================================================

    async function searchNodes(query, resultsContainerId) {
        const resultsDiv = document.getElementById(resultsContainerId);

        if (!query || query.length < 1) {
            hideAutocomplete(resultsContainerId);
            return;
        }

        // Use cached nodes if available, otherwise fetch
        if (!cachedNodes) {
            try {
                const response = await fetch('/api/nodes?limit=500');
                const data = await response.json();
                cachedNodes = data.nodes || [];
            } catch (error) {
                console.error('Failed to fetch nodes:', error);
                cachedNodes = [];
            }
        }

        // Filter nodes based on query
        const lowerQuery = query.toLowerCase();
        const matches = cachedNodes.filter(node => {
            const longName = (node.long_name || '').toLowerCase();
            const shortName = (node.short_name || '').toLowerCase();
            const hexId = node.hex_id ? node.hex_id.toLowerCase() : '';
            const nodeId = node.node_id ? node.node_id.toString() : '';

            return longName.includes(lowerQuery) ||
                   shortName.includes(lowerQuery) ||
                   hexId.includes(lowerQuery) ||
                   nodeId.includes(lowerQuery);
        }).slice(0, 10); // Limit to 10 results

        if (matches.length === 0) {
            hideAutocomplete(resultsContainerId);
            return;
        }

        // Build results HTML
        let html = '';
        for (const node of matches) {
            const displayName = node.long_name || node.short_name || 'Unknown';
            const hexId = node.hex_id || `!${(node.node_id >>> 0).toString(16).padStart(8, '0')}`;
            html += `
                <div class="node-autocomplete-item"
                     onclick="selectAutocompleteNode('${hexId}', '${resultsContainerId}')">
                    <div class="node-name">${escapeHtml(displayName)}</div>
                    <div class="node-id">${hexId}</div>
                </div>
            `;
        }

        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
    }

    function selectAutocompleteNode(nodeId, resultsContainerId) {
        // Find the input associated with this results container
        const resultsDiv = document.getElementById(resultsContainerId);
        const inputId = resultsContainerId === 'testNodeResults' ? 'testNodeInput' : 'targetNodeInput';
        const input = document.getElementById(inputId);

        input.value = nodeId;
        hideAutocomplete(resultsContainerId);

        // If it's the target node input, also store the selected node and check admin status
        if (inputId === 'targetNodeInput') {
            selectedNodeId = nodeId;
            checkAdminStatus(nodeId);
        }
    }

    function hideAutocomplete(resultsContainerId) {
        const resultsDiv = document.getElementById(resultsContainerId);
        if (resultsDiv) {
            resultsDiv.style.display = 'none';
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Refresh cached nodes
    function refreshNodeCache() {
        cachedNodes = null;
    }

    // ============================================================================
    // Connection Management
    // ============================================================================

    // Local storage keys for persisting settings
    const STORAGE_KEYS = {
        connectionType: 'malla_admin_connection_type',
        tcpHost: 'malla_admin_tcp_host',
        tcpPort: 'malla_admin_tcp_port',
        gatewayNode: 'malla_admin_gateway_node'
    };

    // Save setting to localStorage
    function saveSetting(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            console.warn('Failed to save setting to localStorage:', e);
        }
    }

    // Load setting from localStorage
    function loadSetting(key, defaultValue = '') {
        try {
            return localStorage.getItem(key) || defaultValue;
        } catch (e) {
            console.warn('Failed to load setting from localStorage:', e);
            return defaultValue;
        }
    }

    // Change connection type
    async function changeConnectionType() {
        const connType = document.getElementById('connectionTypeSelect').value;

        // Save to localStorage
        saveSetting(STORAGE_KEYS.connectionType, connType);

        // Show/hide appropriate settings
        document.getElementById('mqttSettings').classList.toggle('d-none', connType !== 'mqtt');
        document.getElementById('tcpSettings').classList.toggle('d-none', connType !== 'tcp');
        document.getElementById('serialSettings').classList.toggle('d-none', connType !== 'serial');

        // Auto-discover serial ports when switching to serial
        if (connType === 'serial') {
            discoverSerialPorts();
        }

        try {
            const response = await fetch('/api/admin/connection-type', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ connection_type: connType })
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Connection type changed to ${connType.toUpperCase()}`);
                updateConnectionStatus();
            } else {
                showAlert('danger', data.error || 'Failed to change connection type');
            }
        } catch (error) {
            showAlert('danger', 'Error: ' + error.message);
        }
    }

    // TCP Connect
    async function tcpConnect() {
        const host = document.getElementById('tcpHostInput').value.trim();
        const port = parseInt(document.getElementById('tcpPortInput').value) || 4403;

        // Save TCP settings to localStorage (before connect attempt)
        saveSetting(STORAGE_KEYS.tcpHost, host);
        saveSetting(STORAGE_KEYS.tcpPort, port.toString());

        const btn = document.getElementById('tcpConnectBtn');
        const disconnectBtn = document.getElementById('tcpDisconnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');

        btn.disabled = true;
        disconnectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        // Allow auto-reconnect since user is initiating connection
        if (typeof NodeConnectionManager !== 'undefined') {
            NodeConnectionManager.allowAutoReconnect();
        }

        try {
            // Use NodeConnectionManager if available
            let success = false;
            let data = {};

            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.connectTcp(host, port);
                if (success) {
                    const state = NodeConnectionManager.getState();
                    data = {
                        success: true,
                        host: state.tcpHost,
                        port: state.tcpPort,
                        local_node_hex: state.localNodeHex
                    };
                }
            } else {
                // Fallback to direct API call
                const response = await fetch('/api/admin/tcp/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ host: host, port: port })
                });
                data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                let nodeInfo = data.local_node_hex || '';
                if (data.local_node_name) {
                    nodeInfo = `${data.local_node_name} (${data.local_node_hex})`;
                }
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Connected to ${data.host}:${data.port}` +
                    (nodeInfo ? ` - ${nodeInfo}` : '');
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Failed to connect'}`;
                // Re-enable connect button on failure
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            // Re-enable connect button on error
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
        }

        // Restore button text (state will be set by updateConnectionStatus)
        btn.innerHTML = '<i class="bi bi-plug"></i> Connect';
    }

    // TCP Disconnect
    async function tcpDisconnect() {
        const btn = document.getElementById('tcpDisconnectBtn');
        const connectBtn = document.getElementById('tcpConnectBtn');
        const resultDiv = document.getElementById('tcpConnectResult');

        btn.disabled = true;
        connectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Disconnecting...';

        try {
            let success = false;

            // Use NodeConnectionManager if available (this marks as user-disconnected)
            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.disconnect();
            } else {
                const response = await fetch('/api/admin/tcp/disconnect', {
                    method: 'POST'
                });
                const data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = '<i class="bi bi-check-circle"></i> Disconnected';
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Failed to disconnect`;
                // Re-enable disconnect button on failure
                btn.disabled = false;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            // Re-enable disconnect button on error
            btn.disabled = false;
        }

        // Restore button text (state will be set by updateConnectionStatus)
        btn.innerHTML = '<i class="bi bi-x-circle"></i> Disconnect';
    }

    // Serial Port Discovery
    async function discoverSerialPorts(probe = false) {
        const selectEl = document.getElementById('serialPortSelect');
        const infoDiv = document.getElementById('serialPortInfo');
        const discoverBtn = document.querySelector('#serialSettings button[onclick="discoverSerialPorts()"]');
        const probeBtn = document.getElementById('probeDevicesBtn');

        selectEl.disabled = true;

        // Disable both buttons during operation
        if (discoverBtn) {
            discoverBtn.disabled = true;
        }
        if (probeBtn) {
            probeBtn.disabled = true;
        }

        // Show appropriate loading state
        if (probe) {
            if (probeBtn) {
                probeBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Probing...';
            }
            selectEl.innerHTML = '<option value="">Probing devices (this may take a moment)...</option>';
        } else {
            if (discoverBtn) {
                discoverBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning...';
            }
            selectEl.innerHTML = '<option value="">Scanning ports...</option>';
        }
        infoDiv.classList.add('d-none');

        try {
            const url = probe ? '/api/admin/serial/ports?probe=true' : '/api/admin/serial/ports';
            const response = await fetch(url);
            const data = await response.json();

            // Store ports data for later reference
            window._serialPortsData = data.ports || [];

            selectEl.innerHTML = '';

            if (data.success && data.ports && data.ports.length > 0) {
                // Add placeholder
                const placeholderOpt = document.createElement('option');
                placeholderOpt.value = '';
                placeholderOpt.textContent = '-- Select a port --';
                selectEl.appendChild(placeholderOpt);

                // Add ports - confirmed/likely Meshtastic devices first
                const sortedPorts = [...data.ports].sort((a, b) => {
                    // Confirmed devices first
                    if (a.is_meshtastic_confirmed && !b.is_meshtastic_confirmed) return -1;
                    if (!a.is_meshtastic_confirmed && b.is_meshtastic_confirmed) return 1;
                    // Then likely devices
                    if (a.is_meshtastic_likely && !b.is_meshtastic_likely) return -1;
                    if (!a.is_meshtastic_likely && b.is_meshtastic_likely) return 1;
                    return 0;
                });

                for (const port of sortedPorts) {
                    const opt = document.createElement('option');
                    opt.value = port.device;

                    // Build label
                    let label = port.device;

                    // If we have device info from probing, show hardware model and name
                    if (port.device_info) {
                        const di = port.device_info;
                        if (di.hardware_model_name) {
                            label += ` - ${di.hardware_model_name}`;
                        }
                        if (di.short_name) {
                            label += ` (${di.short_name})`;
                        }
                        label += ' ✓';
                    } else if (port.chip_type) {
                        // Show chip type from VID:PID lookup
                        label += ` - ${port.chip_type}`;
                        if (port.is_meshtastic_likely) {
                            label += ' ⭐';
                        }
                    } else if (port.description && port.description !== 'n/a') {
                        label += ` - ${port.description}`;
                        if (port.is_meshtastic_likely) {
                            label += ' ⭐';
                        }
                    }

                    opt.textContent = label;
                    selectEl.appendChild(opt);
                }

                // Auto-select first confirmed/likely Meshtastic port
                const bestPort = data.ports.find(p => p.is_meshtastic_confirmed) ||
                                 data.ports.find(p => p.is_meshtastic_likely);
                if (bestPort) {
                    selectEl.value = bestPort.device;
                    showSerialPortInfo(bestPort);
                }

                // Add change handler to show port info
                selectEl.onchange = () => {
                    const selectedPort = window._serialPortsData.find(p => p.device === selectEl.value);
                    if (selectedPort) {
                        showSerialPortInfo(selectedPort);
                    } else {
                        infoDiv.classList.add('d-none');
                    }
                };
            } else {
                selectEl.innerHTML = '<option value="">No serial ports found</option>';
            }
        } catch (error) {
            selectEl.innerHTML = '<option value="">Error discovering ports</option>';
            console.error('Serial port discovery error:', error);
        }

        // Re-enable all controls
        selectEl.disabled = false;
        const discoverBtnFinal = document.querySelector('#serialSettings button[onclick="discoverSerialPorts()"]');
        const probeBtnFinal = document.getElementById('probeDevicesBtn');
        if (discoverBtnFinal) {
            discoverBtnFinal.disabled = false;
            discoverBtnFinal.innerHTML = '<i class="bi bi-search"></i> Discover';
        }
        if (probeBtnFinal) {
            probeBtnFinal.disabled = false;
            probeBtnFinal.innerHTML = '<i class="bi bi-cpu"></i> Identify';
        }
    }

    // Probe devices to identify Meshtastic hardware
    async function probeSerialDevices() {
        await discoverSerialPorts(true);
    }

    function showSerialPortInfo(port) {
        const infoDiv = document.getElementById('serialPortInfo');
        let html = `<strong>${port.device}</strong>`;

        // Show confirmed device info if available
        if (port.device_info) {
            const di = port.device_info;
            if (di.hardware_model_name) {
                html += `<br><span class="text-success"><i class="bi bi-check-circle-fill"></i> <strong>${di.hardware_model_name}</strong></span>`;
            }
            if (di.long_name) {
                html += `<br>Name: ${di.long_name}`;
            }
            if (di.short_name) {
                html += ` (${di.short_name})`;
            }
            if (di.node_hex) {
                html += `<br>Node ID: <code>${di.node_hex}</code>`;
            }
            if (di.firmware_version) {
                html += `<br>Firmware: ${di.firmware_version}`;
            }
        } else {
            // Fallback to basic info
            if (port.chip_type) {
                html += `<br>Chip: ${port.chip_type}`;
            } else if (port.description && port.description !== 'n/a') {
                html += `<br>Description: ${port.description}`;
            }
            if (port.manufacturer && port.manufacturer !== 'n/a') {
                html += `<br>Manufacturer: ${port.manufacturer}`;
            }
            if (port.vid && port.pid) {
                html += `<br>VID:PID: ${port.vid.toString(16).toUpperCase().padStart(4, '0')}:${port.pid.toString(16).toUpperCase().padStart(4, '0')}`;
            }
            if (port.is_meshtastic_likely) {
                html += `<br><span class="text-warning"><i class="bi bi-question-circle"></i> Likely Meshtastic - click "Identify Device" to confirm</span>`;
            }
        }

        infoDiv.querySelector('small').innerHTML = html;
        infoDiv.classList.remove('d-none');
    }

    // Serial Connect
    async function serialConnect() {
        const port = document.getElementById('serialPortSelect').value;

        if (!port) {
            showAlert('warning', 'Please select a serial port first');
            return;
        }

        // Save serial port to localStorage
        saveSetting('serialPort', port);

        const btn = document.getElementById('serialConnectBtn');
        const disconnectBtn = document.getElementById('serialDisconnectBtn');
        const resultDiv = document.getElementById('serialConnectResult');

        btn.disabled = true;
        disconnectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        // Allow auto-reconnect since user is initiating connection
        if (typeof NodeConnectionManager !== 'undefined') {
            NodeConnectionManager.allowAutoReconnect();
        }

        try {
            // Use NodeConnectionManager if available
            let success = false;
            let data = {};

            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.connectSerial(port);
                if (success) {
                    const state = NodeConnectionManager.getState();
                    data = {
                        success: true,
                        port: state.serialPort,
                        local_node_hex: state.localNodeHex
                    };
                }
            } else {
                // Fallback to direct API call
                const response = await fetch('/api/admin/serial/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ port: port })
                });
                data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                let nodeInfo = data.local_node_hex || '';
                if (data.local_node_name) {
                    nodeInfo = `${data.local_node_name} (${data.local_node_hex})`;
                }
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> Connected to ${data.port}` +
                    (nodeInfo ? ` - ${nodeInfo}` : '');
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> ${data.error || 'Failed to connect'}`;
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
        }

        btn.innerHTML = '<i class="bi bi-usb-plug"></i> Connect';
    }

    // Serial Disconnect
    async function serialDisconnect() {
        const btn = document.getElementById('serialDisconnectBtn');
        const connectBtn = document.getElementById('serialConnectBtn');
        const resultDiv = document.getElementById('serialConnectResult');

        btn.disabled = true;
        connectBtn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Disconnecting...';

        try {
            let success = false;

            // Use NodeConnectionManager if available (this marks as user-disconnected)
            if (typeof NodeConnectionManager !== 'undefined') {
                success = await NodeConnectionManager.disconnect();
            } else {
                const response = await fetch('/api/admin/serial/disconnect', {
                    method: 'POST'
                });
                const data = await response.json();
                success = data.success;
            }

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-danger');

            if (success) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = '<i class="bi bi-check-circle"></i> Disconnected';
                await updateConnectionStatus();
            } else {
                resultDiv.classList.add('alert-danger');
                resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Failed to disconnect`;
                btn.disabled = false;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none', 'alert-success');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
            btn.disabled = false;
        }

        btn.innerHTML = '<i class="bi bi-x-circle"></i> Disconnect';
    }

    // Update connection status display
    async function updateConnectionStatus() {
        try {
            const response = await fetch('/api/admin/status');
            const data = await response.json();

            const statusSpan = document.getElementById('connectionStatus');
            const tcpConnectBtn = document.getElementById('tcpConnectBtn');
            const tcpDisconnectBtn = document.getElementById('tcpDisconnectBtn');
            const serialConnectBtn = document.getElementById('serialConnectBtn');
            const serialDisconnectBtn = document.getElementById('serialDisconnectBtn');

            if (data.connected) {
                let statusText = 'Connected';
                if (data.local_node_hex) {
                    if (data.local_node_name) {
                        statusText = `Connected - ${data.local_node_name} (${data.local_node_hex})`;
                    } else {
                        statusText = `Connected (${data.local_node_hex})`;
                    }
                }
                statusSpan.innerHTML = `<span class="status-indicator status-connected"></span>${statusText}`;
                // Disable connect buttons, enable disconnect buttons
                if (tcpConnectBtn) {
                    tcpConnectBtn.disabled = true;
                    tcpConnectBtn.classList.remove('btn-success');
                    tcpConnectBtn.classList.add('btn-outline-secondary');
                }
                if (tcpDisconnectBtn) {
                    tcpDisconnectBtn.disabled = false;
                    tcpDisconnectBtn.classList.remove('btn-outline-secondary');
                    tcpDisconnectBtn.classList.add('btn-outline-danger');
                }
                if (serialConnectBtn) {
                    serialConnectBtn.disabled = true;
                    serialConnectBtn.classList.remove('btn-success');
                    serialConnectBtn.classList.add('btn-outline-secondary');
                }
                if (serialDisconnectBtn) {
                    serialDisconnectBtn.disabled = false;
                    serialDisconnectBtn.classList.remove('btn-outline-secondary');
                    serialDisconnectBtn.classList.add('btn-outline-danger');
                }
            } else {
                statusSpan.innerHTML = '<span class="status-indicator status-disconnected"></span>Disconnected';
                // Enable connect buttons, disable disconnect buttons
                if (tcpConnectBtn) {
                    tcpConnectBtn.disabled = false;
                    tcpConnectBtn.classList.remove('btn-outline-secondary');
                    tcpConnectBtn.classList.add('btn-success');
                }
                if (tcpDisconnectBtn) {
                    tcpDisconnectBtn.disabled = true;
                    tcpDisconnectBtn.classList.remove('btn-outline-danger');
                    tcpDisconnectBtn.classList.add('btn-outline-secondary');
                }
                if (serialConnectBtn) {
                    serialConnectBtn.disabled = false;
                    serialConnectBtn.classList.remove('btn-outline-secondary');
                    serialConnectBtn.classList.add('btn-success');
                }
                if (serialDisconnectBtn) {
                    serialDisconnectBtn.disabled = true;
                    serialDisconnectBtn.classList.remove('btn-outline-danger');
                    serialDisconnectBtn.classList.add('btn-outline-secondary');
                }
            }

            // Update gateway display if available
            if (data.gateway_node_hex) {
                document.getElementById('gatewayNodeDisplay').innerHTML = `<code>${data.gateway_node_hex}</code>`;
            }

            // Update the global header indicator
            if (typeof NodeConnectionManager !== 'undefined') {
                NodeConnectionManager.updateGlobalIndicator();
            }

            return data.connected;
        } catch (error) {
            console.error('Failed to update connection status:', error);
            return false;
        }
    }

    // Periodic connection status check
    let connectionCheckInterval = null;

    function startConnectionCheck() {
        // Clear any existing interval
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
        }

        // Check connection status every 10 seconds
        connectionCheckInterval = setInterval(async () => {
            await updateConnectionStatus();
        }, 10000);
    }

    function stopConnectionCheck() {
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
            connectionCheckInterval = null;
        }
    }

    // Start connection check on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Initial status update
        updateConnectionStatus();
        // Start periodic check
        startConnectionCheck();
    });

    // Set gateway node
    async function setGatewayNode() {
        const nodeId = document.getElementById('gatewayNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a node ID');
            return;
        }

        try {
            const response = await fetch('/api/admin/gateway', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ node_id: nodeId })
            });
            const data = await response.json();

            if (data.success) {
                // Save gateway node to localStorage
                saveSetting(STORAGE_KEYS.gatewayNode, data.gateway_node_hex || nodeId);

                document.getElementById('gatewayNodeDisplay').innerHTML =
                    `<code>${data.gateway_node_hex}</code>`;
                showAlert('success', 'Gateway node set successfully');
            } else {
                showAlert('danger', data.error || 'Failed to set gateway node');
            }
        } catch (error) {
            showAlert('danger', 'Error: ' + error.message);
        }
    }

    // Test node admin access
    async function testNodeAdmin() {
        const nodeId = document.getElementById('testNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a node ID');
            return;
        }

        const btn = document.getElementById('testNodeBtn');
        const resultDiv = document.getElementById('testNodeResult');

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Testing...';
        resultDiv.classList.add('d-none');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST'
            });
            const data = await response.json();

            resultDiv.classList.remove('d-none', 'alert-success', 'alert-warning', 'alert-danger');

            if (data.success && data.administrable) {
                resultDiv.classList.add('alert-success');
                resultDiv.innerHTML = `<i class="bi bi-check-circle"></i> <strong>Success!</strong>
                    Node ${data.hex_id} is administrable and responded to the test request.
                    <button class="btn btn-sm btn-outline-success ms-2" onclick="location.reload()">
                        <i class="bi bi-arrow-clockwise"></i> Refresh Page
                    </button>`;
            } else {
                resultDiv.classList.add('alert-warning');
                resultDiv.innerHTML = `<i class="bi bi-exclamation-triangle"></i> <strong>Not Administrable</strong><br>
                    ${data.error || 'Node did not respond. It may not have this server\'s public key configured.'}`;
            }
        } catch (error) {
            resultDiv.classList.remove('d-none');
            resultDiv.classList.add('alert-danger');
            resultDiv.innerHTML = `<i class="bi bi-x-circle"></i> Error: ${error.message}`;
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-lightning"></i> Test';
        }
    }

    // Select node for commands
    function selectNode(nodeId) {
        selectedNodeId = nodeId;
        document.getElementById('targetNodeInput').value = nodeId;

        // Switch to commands tab
        const commandsTab = document.getElementById('commands-tab');
        bootstrap.Tab.getOrCreateInstance(commandsTab).show();

        // Check admin status for the selected node
        checkAdminStatus(nodeId);

        showAlert('info', `Selected node ${nodeId} for commands`);
    }

    // Command log management (similar to reboot log)
    let commandLogLines = [];
    let commandSpinnerInterval = null;
    let commandSpinnerFrame = 0;
    const commandSpinnerFrames = ['/', '-', '\\', '|'];

    function initCommandLog() {
        commandLogLines = [];
        const container = document.getElementById('commandResponse');
        container.innerHTML = '<pre id="commandLogPre" style="margin: 0; font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></pre>';
    }

    function addCommandLog(message, isSpinnerLine = false) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logLine = `[${timestamp}] ${message}`;

        if (isSpinnerLine) {
            if (commandLogLines.length > 0 && commandLogLines[commandLogLines.length - 1].isSpinner) {
                commandLogLines[commandLogLines.length - 1] = { text: logLine, isSpinner: true };
            } else {
                commandLogLines.push({ text: logLine, isSpinner: true });
            }
        } else {
            commandLogLines.push({ text: logLine, isSpinner: false });
        }

        updateCommandLogDisplay();
    }

    function updateCommandLogDisplay() {
        const pre = document.getElementById('commandLogPre');
        if (!pre) return;

        const text = commandLogLines.map(line => line.text).join('\n');
        pre.textContent = text;
        pre.scrollTop = pre.scrollHeight;
    }

    function startCommandSpinner(baseMessage) {
        stopCommandSpinner();
        commandSpinnerFrame = 0;

        const updateSpinner = () => {
            const spinner = commandSpinnerFrames[commandSpinnerFrame % commandSpinnerFrames.length];
            addCommandLog(`${spinner} ${baseMessage}`, true);
            commandSpinnerFrame++;
        };

        updateSpinner();
        commandSpinnerInterval = setInterval(updateSpinner, 250);
    }

    function stopCommandSpinner() {
        if (commandSpinnerInterval) {
            clearInterval(commandSpinnerInterval);
            commandSpinnerInterval = null;
        }
    }

    function finalizeCommandLog(message, success = true) {
        stopCommandSpinner();
        if (commandLogLines.length > 0 && commandLogLines[commandLogLines.length - 1].isSpinner) {
            commandLogLines.pop();
        }
        const symbol = success ? '✓' : '✗';
        addCommandLog(`${symbol} ${message}`);
    }

    // Get configuration with retry support
    async function getConfig(configType) {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        // Get retry settings from UI if available
        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting ${configType} config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/config/${configType}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = configType;
                currentConfigData = data.config;
                currentConfigSchema = data.schema;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Config received successfully${attemptsMsg}`);

                // Render the form if we have schema
                if (data.schema && data.config) {
                    renderConfigForm(configType, data.config, data.schema);
                    showConfigForm();
                }

                // Also append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.config, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get config: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Render editable config form
    function renderConfigForm(configType, config, schema) {
        const container = document.getElementById('configFields');
        const configValues = config[configType] || config;

        let html = `<h6 class="mb-3"><i class="bi bi-gear"></i> ${configType.charAt(0).toUpperCase() + configType.slice(1)} Configuration</h6>`;

        for (const field of schema) {
            const value = configValues[field.name];
            const fieldId = `config_${field.name}`;

            html += `<div class="config-field">`;
            html += `<label for="${fieldId}" class="form-label">${field.label}</label>`;

            if (field.type === 'boolean') {
                html += `
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="${fieldId}"
                               name="${field.name}" ${value ? 'checked' : ''}>
                    </div>
                `;
            } else if (field.type === 'enum' && field.enum) {
                html += `<select class="form-select form-select-sm" id="${fieldId}" name="${field.name}">`;
                for (const [enumVal, enumLabel] of Object.entries(field.enum)) {
                    const selected = parseInt(enumVal) === value ? 'selected' : '';
                    html += `<option value="${enumVal}" ${selected}>${enumLabel} (${enumVal})</option>`;
                }
                html += `</select>`;
            } else if (field.type === 'number') {
                const min = field.min !== null ? `min="${field.min}"` : '';
                const max = field.max !== null ? `max="${field.max}"` : '';
                html += `
                    <div class="input-group input-group-sm">
                        <input type="number" class="form-control" id="${fieldId}"
                               name="${field.name}" value="${value !== undefined ? value : ''}"
                               ${min} ${max}>
                        ${field.unit ? `<span class="input-group-text config-field-unit">${field.unit}</span>` : ''}
                    </div>
                `;
            } else if (field.type === 'password') {
                html += `
                    <input type="text" class="form-control form-control-sm font-monospace" id="${fieldId}"
                           name="${field.name}" value="${value || ''}" placeholder="Hex key">
                `;
            } else if (field.readonly) {
                html += `
                    <input type="text" class="form-control form-control-sm" id="${fieldId}"
                           name="${field.name}" value="${value !== undefined ? value : ''}" readonly disabled>
                `;
            } else {
                html += `
                    <input type="text" class="form-control form-control-sm" id="${fieldId}"
                           name="${field.name}" value="${value !== undefined ? value : ''}">
                `;
            }

            if (field.description) {
                html += `<div class="form-text">${field.description}</div>`;
            }

            html += `</div>`;
        }

        container.innerHTML = html;
        document.getElementById('configFormActions').style.display = 'flex';
    }

    // Show/hide form vs JSON view
    function showConfigForm() {
        document.getElementById('responseViewToggle').style.display = 'block';
        document.getElementById('commandResponseForm').style.display = 'block';
        document.getElementById('commandResponse').style.display = 'none';
        updateViewToggle(true);
    }

    function hideConfigForm() {
        document.getElementById('responseViewToggle').style.display = 'none';
        document.getElementById('commandResponseForm').style.display = 'none';
        document.getElementById('commandResponse').style.display = 'block';
    }

    function showFormView() {
        document.getElementById('commandResponseForm').style.display = 'block';
        document.getElementById('commandResponse').style.display = 'none';
        updateViewToggle(true);
    }

    function showJsonView() {
        document.getElementById('commandResponseForm').style.display = 'none';
        document.getElementById('commandResponse').style.display = 'block';
        updateViewToggle(false);
    }

    function updateViewToggle(formActive) {
        const buttons = document.querySelectorAll('#responseViewToggle .btn');
        buttons[0].classList.toggle('active', formActive);
        buttons[1].classList.toggle('active', !formActive);
    }

    // Save config changes
    async function saveConfig() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId || !currentConfigType || !currentConfigSchema) {
            alert('No configuration loaded to save');
            return;
        }

        // Collect form values
        const formData = {};
        for (const field of currentConfigSchema) {
            const element = document.getElementById(`config_${field.name}`);
            if (!element || field.readonly) continue;

            if (field.type === 'boolean') {
                formData[field.name] = element.checked;
            } else if (field.type === 'enum' || field.type === 'number') {
                formData[field.name] = parseInt(element.value);
            } else {
                formData[field.name] = element.value;
            }
        }

        showAlert('info', 'Saving configuration...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/config/${currentConfigType}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `${currentConfigType} configuration saved successfully!`);
                showCommandResponse(JSON.stringify({saved: formData, message: data.message}, null, 2));
            } else {
                showAlert('danger', `Failed to save: ${data.error}`);
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Refresh current config
    async function refreshConfig() {
        if (currentConfigType) {
            await getConfig(currentConfigType);
        }
    }

    // Get channel with retry support
    async function getChannel(channelIndex) {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }

        const maxRetries = 3;
        const retryDelay = 2.0;
        const timeout = 30.0;

        // Initialize command log
        initCommandLog();
        addCommandLog(`Requesting channel ${channelIndex} config from ${nodeId}`);
        addCommandLog(`Settings: max_retries=${maxRetries}, retry_delay=${retryDelay}s, timeout=${timeout}s`);
        hideConfigForm();

        startCommandSpinner(`Sending request (attempt 1/${maxRetries})...`);

        try {
            const url = `/api/admin/node/${encodeURIComponent(nodeId)}/channel/${channelIndex}?max_retries=${maxRetries}&retry_delay=${retryDelay}&timeout=${timeout}`;
            const response = await fetch(url);
            const data = await response.json();

            stopCommandSpinner();

            // Log retry information if available
            if (data.retry_info && data.retry_info.length > 0) {
                addCommandLog(`─── Attempt Summary ───`);
                for (const attempt of data.retry_info) {
                    const statusSymbol = attempt.status === 'success' ? '✓' : (attempt.status === 'timeout' ? '⏱' : '✗');
                    addCommandLog(`  ${statusSymbol} Attempt ${attempt.attempt}/${attempt.max_attempts}: ${attempt.status}${attempt.error ? ' - ' + attempt.error : ''}`);
                }
                addCommandLog(`─────────────────────`);
            }

            if (data.success) {
                currentConfigType = 'channel';
                currentConfigData = data.channel;

                const attemptsMsg = data.attempts > 1 ? ` (took ${data.attempts} attempts)` : '';
                finalizeCommandLog(`Channel received successfully${attemptsMsg}`);

                // Render channel form
                renderChannelForm(channelIndex, data.channel);
                showConfigForm();

                // Append raw JSON to log
                addCommandLog('');
                addCommandLog('─── Response Data ───');
                const jsonLines = JSON.stringify(data.channel, null, 2).split('\n');
                for (const line of jsonLines) {
                    addCommandLog(line);
                }
            } else {
                const attemptsMsg = data.attempts ? ` after ${data.attempts} attempts` : '';
                finalizeCommandLog(`Failed${attemptsMsg}: ${data.error}`, false);
                showAlert('danger', `Failed to get channel: ${data.error}`);
            }
        } catch (error) {
            stopCommandSpinner();
            finalizeCommandLog(`Error: ${error.message}`, false);
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Render channel edit form
    function renderChannelForm(channelIndex, channel) {
        const container = document.getElementById('configFields');

        const roleOptions = {
            0: 'DISABLED',
            1: 'PRIMARY',
            2: 'SECONDARY'
        };

        const settings = channel.settings || {};
        const moduleSettings = settings.module_settings || {};

        let html = `
            <h6 class="mb-3"><i class="bi bi-broadcast"></i> Channel ${channelIndex} Configuration</h6>
            <input type="hidden" id="channel_index" value="${channelIndex}">

            <div class="config-field">
                <label class="form-label">Channel Role</label>
                <select class="form-select form-select-sm" id="channel_role" name="role">
                    ${Object.entries(roleOptions).map(([val, label]) =>
                        `<option value="${val}" ${parseInt(val) === channel.role ? 'selected' : ''}>${label}</option>`
                    ).join('')}
                </select>
            </div>

            <div class="config-field">
                <label class="form-label">Channel Name</label>
                <input type="text" class="form-control form-control-sm" id="channel_name"
                       name="name" value="${settings.name || ''}">
                <div class="form-text">Display name for this channel</div>
            </div>

            <div class="config-field">
                <label class="form-label">Pre-Shared Key (PSK)</label>
                <input type="text" class="form-control form-control-sm font-monospace" id="channel_psk"
                       name="psk" value="${settings.psk || ''}" placeholder="Hex encoded key">
                <div class="form-text">Encryption key in hexadecimal format</div>
            </div>

            <div class="config-field">
                <label class="form-label">Position Precision</label>
                <input type="number" class="form-control form-control-sm" id="channel_position_precision"
                       name="position_precision" value="${moduleSettings.position_precision || 0}"
                       min="0" max="32">
                <div class="form-text">Bits of precision (0=full, 32=no location)</div>
            </div>
        `;

        container.innerHTML = html;

        // Override save button for channels
        document.getElementById('configFormActions').style.display = 'flex';
        currentConfigSchema = [{name: 'role'}, {name: 'name'}, {name: 'psk'}, {name: 'position_precision'}];
    }

    // Override saveConfig for channels
    const originalSaveConfig = saveConfig;
    saveConfig = async function() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId || !currentConfigType) {
            alert('No configuration loaded to save');
            return;
        }

        if (currentConfigType === 'channel') {
            await saveChannel();
        } else {
            // Collect form values
            const formData = {};
            for (const field of currentConfigSchema) {
                const element = document.getElementById(`config_${field.name}`);
                if (!element || field.readonly) continue;

                if (field.type === 'boolean') {
                    formData[field.name] = element.checked;
                } else if (field.type === 'enum' || field.type === 'number') {
                    formData[field.name] = parseInt(element.value);
                } else {
                    formData[field.name] = element.value;
                }
            }

            showAlert('info', 'Saving configuration...');

            try {
                const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/config/${currentConfigType}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                const data = await response.json();

                if (data.success) {
                    showAlert('success', `${currentConfigType} configuration saved successfully!`);
                    showCommandResponse(JSON.stringify({saved: formData, message: data.message}, null, 2));
                } else {
                    showAlert('danger', `Failed to save: ${data.error}`);
                }
            } catch (error) {
                showAlert('danger', `Error: ${error.message}`);
            }
        }
    };

    // Save channel
    async function saveChannel() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        const channelIndex = parseInt(document.getElementById('channel_index').value);

        const channelData = {
            role: parseInt(document.getElementById('channel_role').value),
            name: document.getElementById('channel_name').value,
            psk: document.getElementById('channel_psk').value,
            position_precision: parseInt(document.getElementById('channel_position_precision').value) || 0
        };

        showAlert('info', 'Saving channel configuration...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/channel/${channelIndex}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(channelData)
            });
            const data = await response.json();

            if (data.success) {
                showAlert('success', `Channel ${channelIndex} saved successfully!`);
                showCommandResponse(JSON.stringify({saved: channelData, message: data.message}, null, 2));
            } else {
                showAlert('danger', `Failed to save channel: ${data.error}`);
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        }
    }

    // Get node config shortcut from nodes table
    async function getNodeConfig(nodeId, configType) {
        document.getElementById('targetNodeInput').value = nodeId;

        // Switch to commands tab
        const commandsTab = document.getElementById('commands-tab');
        bootstrap.Tab.getOrCreateInstance(commandsTab).show();

        await getConfig(configType);
    }

    // Format uptime seconds to human readable string
    function formatUptimeSeconds(seconds) {
        if (!seconds || seconds <= 0) return '—';

        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);

        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0 || parts.length === 0) parts.push(`${minutes}m`);

        return parts.join(' ');
    }

    // Format datetime for admin confirmed time (respects timezone preference)
    function formatAdminDateTime(date) {
        if (!date) date = new Date();

        // Use formatTimestamp if available (from timezone-utils.js)
        if (typeof formatTimestamp === 'function') {
            const timestamp = Math.floor(date.getTime() / 1000);
            return formatTimestamp(timestamp, 'datetime');
        }

        // Fallback: format as YYYY-MM-DD HH:MM:SS (matching the database format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // Refresh node admin info - tests admin access and fetches metadata + telemetry
    async function refreshNodeAdminInfo(nodeId) {
        const refreshBtn = document.getElementById(`admin-node-refresh-btn-${nodeId}`);
        const statusCell = document.getElementById(`admin-node-status-${nodeId}`);
        const fwCell = document.getElementById(`admin-node-fw-${nodeId}`);
        const hwCell = document.getElementById(`admin-node-hw-${nodeId}`);
        const capsCell = document.getElementById(`admin-node-caps-${nodeId}`);
        const uptimeCell = document.getElementById(`admin-node-uptime-${nodeId}`);
        const confirmedCell = document.getElementById(`admin-node-confirmed-${nodeId}`);

        // Show loading state
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
        }
        if (statusCell) {
            statusCell.innerHTML = '<span class="badge bg-warning text-dark"><i class="bi bi-hourglass-split"></i> Testing...</span>';
        }

        try {
            // Fetch telemetry data in parallel with admin test
            const [adminResponse, telemetryResponse] = await Promise.all([
                fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, { method: 'POST' }),
                fetch(`/api/node/${encodeURIComponent(nodeId)}/telemetry`)
            ]);

            const data = await adminResponse.json();
            const telemetryData = await telemetryResponse.json();

            // Update uptime from telemetry if available
            if (uptimeCell && telemetryData.telemetry) {
                const dm = telemetryData.telemetry.device_metrics;
                if (dm && dm.uptime_seconds) {
                    uptimeCell.innerHTML = `<span class="text-muted small" title="${dm.uptime_seconds} seconds">${formatUptimeSeconds(dm.uptime_seconds)}</span>`;
                } else {
                    uptimeCell.innerHTML = '<span class="text-muted small">—</span>';
                }
            }

            if (data.success && data.administrable) {
                // Success - update the row with new info
                if (statusCell) {
                    statusCell.innerHTML = '<span class="badge bg-success"><i class="bi bi-check-circle"></i> Online</span>';
                }

                // Update firmware version if returned
                if (data.response && data.response.firmware_version && fwCell) {
                    fwCell.textContent = data.response.firmware_version;
                }

                // Update hardware model if returned
                if (data.response && data.response.hw_model && hwCell) {
                    hwCell.textContent = data.response.hw_model;
                }

                // Update capabilities icons
                if (capsCell && data.response) {
                    const caps = [];
                    if (data.response.has_wifi) {
                        caps.push('<i class="bi bi-wifi" title="WiFi"></i>');
                    }
                    if (data.response.has_bluetooth) {
                        caps.push('<i class="bi bi-bluetooth" title="Bluetooth"></i>');
                    }
                    if (data.response.can_shutdown) {
                        caps.push('<i class="bi bi-power" title="Can Shutdown"></i>');
                    }
                    if (data.response.role !== undefined && data.response.role !== null) {
                        const roleNames = {
                            0: 'Client', 1: 'Client Mute', 2: 'Router',
                            3: 'Router Client', 4: 'Repeater', 5: 'Tracker', 6: 'Sensor'
                        };
                        const roleName = roleNames[data.response.role] || `Role ${data.response.role}`;
                        caps.push(`<span class="badge bg-info text-dark" title="Device Role">${roleName}</span>`);
                    }
                    capsCell.innerHTML = caps.length > 0 ? caps.join(' ') : '<span class="text-muted small">—</span>';
                }

                // Update last confirmed time
                if (confirmedCell) {
                    const now = new Date();
                    confirmedCell.innerHTML = `<span class="text-muted small">${formatAdminDateTime(now)}</span>`;
                }

                showAlert('success', `Node ${data.hex_id} is online and administrable`);
            } else {
                // Failed to get response
                if (statusCell) {
                    statusCell.innerHTML = '<span class="badge bg-danger"><i class="bi bi-x-circle"></i> No Response</span>';
                }
                showAlert('warning', data.error || 'Node did not respond to admin request');
            }
        } catch (error) {
            // Error occurred
            if (statusCell) {
                statusCell.innerHTML = '<span class="badge bg-danger"><i class="bi bi-exclamation-triangle"></i> Error</span>';
            }
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            // Restore button
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i>';
            }
        }
    }

    // Refresh all administrable nodes
    async function refreshAllNodes() {
        const tbody = document.getElementById('administrableNodesBody');
        if (!tbody) return;

        const rows = tbody.querySelectorAll('tr[id^="admin-node-row-"]');
        for (const row of rows) {
            const nodeId = row.id.replace('admin-node-row-', '');
            await refreshNodeAdminInfo(parseInt(nodeId));
            // Small delay between requests to avoid overwhelming the mesh
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }

    // Confirm reboot from nodes table
    function confirmReboot(nodeId) {
        showConfirmModal(
            'Confirm Reboot',
            `Are you sure you want to reboot node ${nodeId}?<br><br>
            <span class="text-muted">The node will restart in 5 seconds after the command is sent.</span>`,
            async () => {
                await sendReboot(nodeId);
            }
        );
    }

    // Confirm reboot target node
    function confirmRebootTarget() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }
        confirmReboot(nodeId);
    }

    // Confirm shutdown target node
    function confirmShutdownTarget() {
        const nodeId = document.getElementById('targetNodeInput').value.trim();
        if (!nodeId) {
            alert('Please enter a target node ID');
            return;
        }
        showConfirmModal(
            'Confirm Shutdown',
            `<strong class="text-danger">Warning!</strong> Are you sure you want to shut down node ${nodeId}?<br><br>
            <span class="text-muted">The node will power off and will need to be manually restarted.</span>`,
            async () => {
                await sendShutdown(nodeId);
            }
        );
    }

    // Quick check if node is responding (lighter than full test)
    async function isNodeResponding(nodeId, timeoutMs = 5000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/test`, {
                method: 'POST',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            const data = await response.json();
            return data.success && data.administrable;
        } catch (error) {
            clearTimeout(timeoutId);
            return false;
        }
    }

    // Reboot log management
    let rebootLogLines = [];
    let spinnerInterval = null;
    let spinnerFrame = 0;
    const spinnerFrames = ['/', '-', '\\', '|'];

    function initRebootLog() {
        rebootLogLines = [];
        const container = document.getElementById('commandResponse');
        container.innerHTML = '<pre id="rebootLogPre" style="margin: 0; font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></pre>';
    }

    function addRebootLog(message, isSpinnerLine = false) {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const logLine = `[${timestamp}] ${message}`;

        if (isSpinnerLine) {
            // Replace last line if it was a spinner line
            if (rebootLogLines.length > 0 && rebootLogLines[rebootLogLines.length - 1].isSpinner) {
                rebootLogLines[rebootLogLines.length - 1] = { text: logLine, isSpinner: true };
            } else {
                rebootLogLines.push({ text: logLine, isSpinner: true });
            }
        } else {
            rebootLogLines.push({ text: logLine, isSpinner: false });
        }

        updateRebootLogDisplay();
    }

    function updateRebootLogDisplay() {
        const pre = document.getElementById('rebootLogPre');
        if (!pre) return;

        const text = rebootLogLines.map(line => line.text).join('\n');
        pre.textContent = text;
        pre.scrollTop = pre.scrollHeight;
    }

    function startSpinner(baseMessage) {
        stopSpinner();
        spinnerFrame = 0;

        const updateSpinner = () => {
            const spinner = spinnerFrames[spinnerFrame % spinnerFrames.length];
            addRebootLog(`${spinner} ${baseMessage}`, true);
            spinnerFrame++;
        };

        updateSpinner();
        spinnerInterval = setInterval(updateSpinner, 250);
    }

    function stopSpinner() {
        if (spinnerInterval) {
            clearInterval(spinnerInterval);
            spinnerInterval = null;
        }
    }

    function finalizeRebootLog(message, success = true) {
        stopSpinner();
        // Remove the last spinner line if present
        if (rebootLogLines.length > 0 && rebootLogLines[rebootLogLines.length - 1].isSpinner) {
            rebootLogLines.pop();
        }
        const symbol = success ? '✓' : '✗';
        addRebootLog(`${symbol} ${message}`);
    }

    // Update reboot progress UI
    function updateRebootProgress(phase, progress, message, details) {
        const banner = document.getElementById('adminStatusBanner');
        if (!banner) return;

        // Create or get progress container
        let progressContainer = document.getElementById('rebootProgressContainer');
        if (!progressContainer) {
            progressContainer = document.createElement('div');
            progressContainer.id = 'rebootProgressContainer';
            progressContainer.className = 'mt-3';
            banner.querySelector('.status-details')?.appendChild(progressContainer);
        }

        // Phase icons and colors
        const phases = {
            'sending': { icon: 'bi-send', color: 'warning' },
            'waiting-shutdown': { icon: 'bi-hourglass-split', color: 'warning' },
            'offline': { icon: 'bi-power', color: 'secondary' },
            'waiting-online': { icon: 'bi-arrow-repeat', color: 'info' },
            'reconnecting': { icon: 'bi-plug', color: 'primary' },
            'complete': { icon: 'bi-check-circle', color: 'success' },
            'error': { icon: 'bi-x-circle', color: 'danger' }
        };

        const phaseInfo = phases[phase] || phases['sending'];

        progressContainer.innerHTML = `
            <div class="d-flex align-items-center mb-2">
                <i class="bi ${phaseInfo.icon} text-${phaseInfo.color} me-2" style="font-size: 1.2rem;"></i>
                <strong>${message}</strong>
            </div>
            <div class="progress" style="height: 8px;">
                <div class="progress-bar bg-${phaseInfo.color} ${phase === 'offline' || phase === 'waiting-online' ? 'progress-bar-striped progress-bar-animated' : ''}"
                     role="progressbar"
                     style="width: ${progress}%;"
                     aria-valuenow="${progress}"
                     aria-valuemin="0"
                     aria-valuemax="100">
                </div>
            </div>
            <small class="text-muted mt-1 d-block">${details || ''}</small>
        `;

        // Update banner styling
        updateAdminStatusBanner(phaseInfo.color === 'success' ? 'success' : 'warning',
            phase === 'complete' ? 'Reboot Complete' : 'Rebooting Node...', '');
    }

    // Monitor reboot process with real-time updates
    async function monitorReboot(nodeId) {
        const POLL_INTERVAL = 3000;  // Check every 3 seconds
        const SHUTDOWN_TIMEOUT = 15000;  // Max time to wait for shutdown (15s)
        const ONLINE_TIMEOUT = 120000;  // Max time to wait for online (2 min)

        let phase = 'waiting-shutdown';
        let startTime = Date.now();
        let offlineDetectedTime = null;
        const nodeHex = `!${nodeId.toString(16).padStart(8, '0')}`;

        // Initialize log
        initRebootLog();
        addRebootLog(`Reboot command sent to ${nodeHex}`);
        addRebootLog('Node will restart in 5 seconds...');

        updateRebootProgress('waiting-shutdown', 10, 'Waiting for node to shut down...',
            'The node will restart in a few seconds');

        // Phase 1: Wait for node to go offline
        addRebootLog('Phase 1: Waiting for node to go offline');
        startSpinner('Polling node status...');

        while (Date.now() - startTime < SHUTDOWN_TIMEOUT) {
            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));

            const responding = await isNodeResponding(nodeId, 4000);
            const elapsed = Math.round((Date.now() - startTime) / 1000);

            if (!responding) {
                // Node is offline!
                stopSpinner();
                offlineDetectedTime = Date.now();
                phase = 'offline';
                finalizeRebootLog(`Node offline detected after ${elapsed}s`);
                updateRebootProgress('offline', 30, 'Node is offline',
                    `Shutdown detected after ${elapsed}s. Waiting for restart...`);
                break;
            } else {
                // Still online, update progress
                const progress = 10 + (elapsed / (SHUTDOWN_TIMEOUT / 1000)) * 20;
                updateRebootProgress('waiting-shutdown', Math.min(progress, 29),
                    'Waiting for node to shut down...',
                    `Still responding after ${elapsed}s...`);
                startSpinner(`Polling node status... (${elapsed}s elapsed, still online)`);
            }
        }

        // If we didn't detect offline, assume it went offline and we missed it
        if (!offlineDetectedTime) {
            stopSpinner();
            offlineDetectedTime = Date.now();
            phase = 'offline';
            addRebootLog('! Node shutdown not detected, assuming offline');
            updateRebootProgress('offline', 30, 'Node appears offline',
                'Shutdown assumed. Waiting for restart...');
        }

        // Phase 2: Wait for node to come back online
        phase = 'waiting-online';
        let pollCount = 0;
        const maxPolls = Math.ceil(ONLINE_TIMEOUT / POLL_INTERVAL);

        addRebootLog('Phase 2: Waiting for node to come back online');
        startSpinner('Waiting for node to boot...');

        while (Date.now() - offlineDetectedTime < ONLINE_TIMEOUT) {
            pollCount++;
            const progress = 30 + (pollCount / maxPolls) * 50;
            const waitTime = Math.round((Date.now() - offlineDetectedTime) / 1000);

            updateRebootProgress('waiting-online', Math.min(progress, 79),
                'Waiting for node to come back online...',
                `Polling... (${waitTime}s since shutdown)`);
            startSpinner(`Polling node... (${waitTime}s since shutdown, attempt ${pollCount})`);

            await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));

            const responding = await isNodeResponding(nodeId, 4000);

            if (responding) {
                // Node is back online!
                stopSpinner();
                finalizeRebootLog(`Node responded after ${waitTime}s`);

                phase = 'reconnecting';
                updateRebootProgress('reconnecting', 85, 'Node is back online!',
                    'Re-establishing admin session...');
                addRebootLog('Phase 3: Re-establishing admin session');
                startSpinner('Negotiating session key...');

                // Refresh admin info
                await refreshNodeAdminInfo(nodeId);
                stopSpinner();
                finalizeRebootLog('Admin session established');

                // Update admin status for selected node
                const targetNodeInput = document.getElementById('targetNodeInput');
                if (targetNodeInput && targetNodeInput.value.trim() == nodeId) {
                    lastCheckedNodeId = null;
                    await checkAdminStatus(nodeId);
                }

                // Complete!
                const totalTime = Math.round((Date.now() - startTime) / 1000);
                updateRebootProgress('complete', 100, 'Reboot complete!',
                    `Node rebooted successfully in ${totalTime}s`);
                addRebootLog('─'.repeat(40));
                addRebootLog(`✓ REBOOT COMPLETE - Total time: ${totalTime}s`);
                addRebootLog('─'.repeat(40));
                showAlert('success', 'Node rebooted successfully');

                // Clear progress after a few seconds
                setTimeout(() => {
                    const progressContainer = document.getElementById('rebootProgressContainer');
                    if (progressContainer) {
                        progressContainer.remove();
                    }
                }, 5000);

                return true;
            }
        }

        // Timeout - node didn't come back
        stopSpinner();
        const totalWait = Math.round((Date.now() - offlineDetectedTime) / 1000);
        finalizeRebootLog(`Timeout after ${totalWait}s waiting for node`, false);
        addRebootLog('─'.repeat(40));
        addRebootLog('✗ REBOOT TIMEOUT - Node did not respond');
        addRebootLog('─'.repeat(40));

        updateRebootProgress('error', 100, 'Timeout waiting for node',
            'Node did not respond within expected time. It may still be booting or have issues.');
        showAlert('warning', 'Node reboot timeout - please check the device');

        return false;
    }

    // Send reboot command
    async function sendReboot(nodeId) {
        updateRebootProgress('sending', 5, 'Sending reboot command...', '');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/reboot`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ delay_seconds: 5 })
            });
            const data = await response.json();

            if (data.success) {
                showCommandResponse(data.message);
                showAlert('success', data.message);

                // Start real-time reboot monitoring
                await monitorReboot(nodeId);
            } else {
                showCommandResponse(`Error: ${data.error}`, true);
                updateRebootProgress('error', 0, 'Failed to send reboot', data.error);
            }
        } catch (error) {
            showCommandResponse(`Error: ${error.message}`, true);
            updateRebootProgress('error', 0, 'Error sending reboot', error.message);
        }
    }

    // Send shutdown command
    async function sendShutdown(nodeId) {
        showCommandResponse('Sending shutdown command...');

        try {
            const response = await fetch(`/api/admin/node/${encodeURIComponent(nodeId)}/shutdown`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ delay_seconds: 5 })
            });
            const data = await response.json();

            if (data.success) {
                showCommandResponse(data.message);
                showAlert('warning', data.message);

                // Update status to show shutting down
                updateAdminStatusBanner('warning', 'Node is shutting down...',
                    'The node will power off in a few seconds. It will not respond to commands until manually powered on.');
            } else {
                showCommandResponse(`Error: ${data.error}`, true);
            }
        } catch (error) {
            showCommandResponse(`Error: ${error.message}`, true);
        }
    }

    // Show command response
    function showCommandResponse(content, isError = false) {
        const container = document.getElementById('commandResponse');
        if (isError) {
            container.innerHTML = `<span class="text-danger">${content}</span>`;
        } else {
            container.textContent = content;
        }
    }

    // Refresh audit log
    async function refreshLog() {
        const container = document.getElementById('auditLogContainer');
        container.innerHTML = `
            <div class="text-center py-3">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        `;

        try {
            const response = await fetch('/api/admin/log?limit=50');
            const data = await response.json();

            if (data.log && data.log.length > 0) {
                let html = `
                    <div class="table-responsive">
                        <table class="table table-sm table-hover">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Target</th>
                                    <th>Command</th>
                                    <th>Status</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                for (const entry of data.log) {
                    const timestamp = formatAdminDateTime(new Date(entry.timestamp * 1000));
                    const statusClass = `log-status-${entry.status}`;
                    const entryId = `log-entry-${entry.id}`;

                    // Build popover content
                    const popoverContent = buildLogPopoverContent(entry);

                    html += `
                        <tr class="log-entry"
                            id="${entryId}"
                            data-bs-toggle="popover"
                            data-bs-trigger="click"
                            data-bs-placement="left"
                            data-bs-html="true"
                            data-bs-custom-class="log-details-popover"
                            data-bs-content="${escapeHtml(popoverContent)}"
                            title="Command Details">
                            <td class="log-timestamp">${timestamp}</td>
                            <td><code>${entry.target_node_hex || entry.target_node_id}</code></td>
                            <td>${entry.command_type}</td>
                            <td class="${statusClass}">
                                <i class="bi bi-${getStatusIcon(entry.status)}"></i>
                                ${entry.status}
                            </td>
                            <td>
                                <i class="bi bi-info-circle text-muted" title="Click for details"></i>
                            </td>
                        </tr>
                    `;
                }

                html += '</tbody></table></div>';
                container.innerHTML = html;

                // Initialize popovers for the log entries
                const popoverTriggerList = container.querySelectorAll('[data-bs-toggle="popover"]');
                const popovers = [];
                popoverTriggerList.forEach(el => {
                    const popover = new bootstrap.Popover(el, {
                        container: 'body',
                        sanitize: false
                    });
                    popovers.push(popover);
                });

                // Close popover when clicking outside
                document.addEventListener('click', function closePopover(e) {
                    // Check if click is outside any popover and its trigger
                    const isPopoverClick = e.target.closest('.popover') || e.target.closest('[data-bs-toggle="popover"]');
                    if (!isPopoverClick) {
                        popovers.forEach(p => p.hide());
                    }
                }, { once: false });
            } else {
                container.innerHTML = `
                    <div class="text-center py-5 text-muted">
                        <i class="bi bi-journal"></i> No admin commands logged yet
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    Error loading audit log: ${error.message}
                </div>
            `;
        }
    }

    // Build popover content for a log entry
    function buildLogPopoverContent(entry) {
        let content = '';

        // Command data section
        if (entry.command_data) {
            try {
                const cmdData = JSON.parse(entry.command_data);
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Command Sent</div>`;
                content += `<div class="log-details-content">${JSON.stringify(cmdData, null, 2)}</div>`;
                content += `</div>`;
            } catch (e) {
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Command Sent</div>`;
                content += `<div class="log-details-content">${entry.command_data}</div>`;
                content += `</div>`;
            }
        }

        // Response data section
        if (entry.response_data) {
            try {
                const respData = JSON.parse(entry.response_data);
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Response</div>`;
                content += `<div class="log-details-content log-success-content">${JSON.stringify(respData, null, 2)}</div>`;
                content += `</div>`;
            } catch (e) {
                content += `<div class="log-details-section">`;
                content += `<div class="log-details-label">Response</div>`;
                content += `<div class="log-details-content log-success-content">${entry.response_data}</div>`;
                content += `</div>`;
            }
        }

        // Error message section
        if (entry.error_message) {
            content += `<div class="log-details-section">`;
            content += `<div class="log-details-label">Error</div>`;
            content += `<div class="log-details-content log-error-content">${entry.error_message}</div>`;
            content += `</div>`;
        }

        // If no details available
        if (!content) {
            content = `<div class="text-muted">No additional details available</div>`;
        }

        // Add timing info if available
        if (entry.response_timestamp && entry.timestamp) {
            const durationMs = ((entry.response_timestamp - entry.timestamp) * 1000).toFixed(0);
            content += `<div class="log-details-section mt-2">`;
            content += `<small class="text-muted">Duration: ${durationMs}ms</small>`;
            content += `</div>`;
        }

        return content;
    }

    // Escape HTML for safe insertion into data attributes
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function getStatusIcon(status) {
        const icons = {
            'success': 'check-circle-fill',
            'failed': 'x-circle-fill',
            'pending': 'clock-fill',
            'timeout': 'exclamation-triangle-fill'
        };
        return icons[status] || 'question-circle';
    }

    // Show confirmation modal
    function showConfirmModal(title, body, onConfirm) {
        document.getElementById('confirmModalTitle').textContent = title;
        document.getElementById('confirmModalBody').innerHTML = body;

        const confirmBtn = document.getElementById('confirmModalBtn');
        confirmBtn.onclick = async () => {
            const modal = bootstrap.Modal.getInstance(document.getElementById('confirmModal'));
            modal.hide();
            await onConfirm();
        };

        const modal = new bootstrap.Modal(document.getElementById('confirmModal'));
        modal.show();
    }

    // Show toast alert
    function showAlert(type, message) {
        // Create a simple alert at the top of the page
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
        alertDiv.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px;';
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        document.body.appendChild(alertDiv);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }

    // Restore saved settings from localStorage
    function restoreSavedSettings() {
        // Restore connection type
        const savedConnType = loadSetting(STORAGE_KEYS.connectionType);
        if (savedConnType) {
            const connTypeSelect = document.getElementById('connectionTypeSelect');
            if (connTypeSelect && (savedConnType === 'mqtt' || savedConnType === 'tcp')) {
                connTypeSelect.value = savedConnType;
                // Update visibility of settings panels
                document.getElementById('mqttSettings').classList.toggle('d-none', savedConnType !== 'mqtt');
                document.getElementById('tcpSettings').classList.toggle('d-none', savedConnType !== 'tcp');
            }
        }

        // Restore TCP host
        const savedHost = loadSetting(STORAGE_KEYS.tcpHost);
        if (savedHost) {
            const hostInput = document.getElementById('tcpHostInput');
            if (hostInput) hostInput.value = savedHost;
        }

        // Restore TCP port
        const savedPort = loadSetting(STORAGE_KEYS.tcpPort);
        if (savedPort) {
            const portInput = document.getElementById('tcpPortInput');
            if (portInput) portInput.value = savedPort;
        }

        // Restore gateway node
        const savedGateway = loadSetting(STORAGE_KEYS.gatewayNode);
        if (savedGateway) {
            const gatewayInput = document.getElementById('gatewayNodeInput');
            if (gatewayInput && !gatewayInput.value) gatewayInput.value = savedGateway;
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        // Restore saved settings from localStorage
        restoreSavedSettings();

        // Load audit log when tab is shown
        document.getElementById('log-tab').addEventListener('shown.bs.tab', function() {
            refreshLog();
        });

        // Load templates when tab is shown
        document.getElementById('templates-tab').addEventListener('shown.bs.tab', function() {
            loadTemplates();
            loadDeploymentHistory();
            loadDeployNodesList();
        });

        // Check for node parameter in URL and pre-fill the target node
        const urlParams = new URLSearchParams(window.location.search);
        const nodeParam = urlParams.get('node');
        if (nodeParam) {
            document.getElementById('targetNodeInput').value = nodeParam;
            // Store the node ID for commands
            window.selectedTargetNode = nodeParam;
            // Switch to the Commands tab
            const commandsTab = document.getElementById('commands-tab');
            if (commandsTab) {
                const tab = new bootstrap.Tab(commandsTab);
                tab.show();
            }
        }
    });

    // ============================================================================
    // Configuration Templates
    // ============================================================================

    let currentTemplateId = null;

    async function loadTemplates() {
        const container = document.getElementById('templatesList');
        const typeFilter = document.getElementById('templateTypeFilter').value;

        container.innerHTML = '<div class="text-center py-3 text-muted"><i class="bi bi-arrow-clockwise spin"></i> Loading...</div>';

        try {
            const url = typeFilter ? `/api/admin/templates?type=${typeFilter}` : '/api/admin/templates';
            const response = await fetch(url);
            const data = await response.json();

            if (data.templates && data.templates.length > 0) {
                let html = '';
                for (const template of data.templates) {
                    const isActive = template.id === currentTemplateId ? 'active' : '';
                    const typeIcon = getTemplateTypeIcon(template.template_type);
                    html += `
                        <a href="#" class="list-group-item list-group-item-action ${isActive}"
                           onclick="selectTemplate(${template.id}); return false;">
                            <div class="d-flex justify-content-between align-items-start">
                                <div>
                                    <i class="bi ${typeIcon}"></i>
                                    <strong>${escapeHtml(template.name)}</strong>
                                    <br>
                                    <small class="text-muted">
                                        <span class="badge bg-secondary">${template.template_type}</span>
                                        ${template.description ? escapeHtml(template.description) : ''}
                                    </small>
                                </div>
                            </div>
                        </a>
                    `;
                }
                container.innerHTML = html;
            } else {
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="bi bi-folder2-open"></i>
                        <p class="small mb-0">No templates found.<br>Click "New Template" to create one.</p>
                    </div>
                `;
            }
        } catch (error) {
            container.innerHTML = `<div class="text-danger p-3">Error loading templates: ${error.message}</div>`;
        }
    }

    function getTemplateTypeIcon(type) {
        const icons = {
            'device': 'bi-cpu',
            'lora': 'bi-broadcast',
            'channel': 'bi-hash',
            'position': 'bi-geo-alt',
            'power': 'bi-battery-charging',
            'network': 'bi-wifi',
            'display': 'bi-display',
            'bluetooth': 'bi-bluetooth',
        };
        return icons[type] || 'bi-file-earmark-code';
    }

    async function selectTemplate(templateId) {
        currentTemplateId = templateId;

        // Update active state in list
        document.querySelectorAll('#templatesList .list-group-item').forEach(el => {
            el.classList.remove('active');
        });

        try {
            const response = await fetch(`/api/admin/templates/${templateId}`);
            const template = await response.json();

            if (template.error) {
                showAlert('danger', template.error);
                return;
            }

            // Populate editor
            document.getElementById('templateName').value = template.name;
            document.getElementById('templateType').value = template.template_type;
            document.getElementById('templateDescription').value = template.description || '';

            const configData = typeof template.config_data === 'object'
                ? JSON.stringify(template.config_data, null, 2)
                : template.config_data;
            document.getElementById('templateConfigData').value = configData;

            // Show editor, hide placeholder
            document.getElementById('templateEditorSection').style.display = 'block';
            document.getElementById('templatePlaceholder').style.display = 'none';
            document.getElementById('templateEditorTitle').innerHTML = '<i class="bi bi-pencil"></i> Edit Template';
            document.getElementById('deleteTemplateBtn').style.display = 'inline-block';

            // Reload templates list to update active state
            loadTemplates();

        } catch (error) {
            showAlert('danger', `Error loading template: ${error.message}`);
        }
    }

    function showCreateTemplateModal() {
        currentTemplateId = null;

        // Clear editor
        document.getElementById('templateName').value = '';
        document.getElementById('templateType').value = 'lora';
        document.getElementById('templateDescription').value = '';
        document.getElementById('templateConfigData').value = '{\n  \n}';

        // Show editor
        document.getElementById('templateEditorSection').style.display = 'block';
        document.getElementById('templatePlaceholder').style.display = 'none';
        document.getElementById('templateEditorTitle').innerHTML = '<i class="bi bi-plus-lg"></i> Create New Template';
        document.getElementById('deleteTemplateBtn').style.display = 'none';

        // Focus on name field
        document.getElementById('templateName').focus();
    }

    async function saveTemplate() {
        const name = document.getElementById('templateName').value.trim();
        const templateType = document.getElementById('templateType').value;
        const description = document.getElementById('templateDescription').value.trim();
        const configDataStr = document.getElementById('templateConfigData').value.trim();

        if (!name) {
            showAlert('warning', 'Template name is required');
            return;
        }

        // Validate JSON
        let configData;
        try {
            configData = JSON.parse(configDataStr);
        } catch (e) {
            showAlert('danger', 'Invalid JSON in configuration data');
            return;
        }

        const saveBtn = document.getElementById('saveTemplateBtn');
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

        try {
            const url = currentTemplateId
                ? `/api/admin/templates/${currentTemplateId}`
                : '/api/admin/templates';
            const method = currentTemplateId ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    template_type: templateType,
                    description: description || null,
                    config_data: configData,
                }),
            });

            const result = await response.json();

            if (result.success || result.template_id) {
                showAlert('success', currentTemplateId ? 'Template updated!' : 'Template created!');
                if (result.template_id) {
                    currentTemplateId = result.template_id;
                }
                loadTemplates();
            } else {
                showAlert('danger', result.error || 'Failed to save template');
            }
        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="bi bi-save"></i> Save';
        }
    }

    async function deleteTemplate() {
        if (!currentTemplateId) return;

        showConfirmModal(
            'Delete Template',
            'Are you sure you want to delete this template? This action cannot be undone.',
            async () => {
                try {
                    const response = await fetch(`/api/admin/templates/${currentTemplateId}`, {
                        method: 'DELETE',
                    });

                    const result = await response.json();

                    if (result.success) {
                        showAlert('success', 'Template deleted');
                        currentTemplateId = null;
                        document.getElementById('templateEditorSection').style.display = 'none';
                        document.getElementById('templatePlaceholder').style.display = 'block';
                        loadTemplates();
                    } else {
                        showAlert('danger', result.error || 'Failed to delete template');
                    }
                } catch (error) {
                    showAlert('danger', `Error: ${error.message}`);
                }
            }
        );
    }

    // ============================================================================
    // Template Deployment
    // ============================================================================

    async function loadDeployNodesList() {
        const container = document.getElementById('deployNodesList');

        try {
            const response = await fetch('/api/admin/nodes');
            const data = await response.json();

            if (data.nodes && data.nodes.length > 0) {
                let html = '';
                for (const node of data.nodes) {
                    const displayName = node.long_name || node.short_name || node.hex_id || `!${node.node_id.toString(16).padStart(8, '0')}`;
                    html += `
                        <div class="form-check">
                            <input class="form-check-input deploy-node-checkbox" type="checkbox"
                                   value="${node.node_id}" id="deployNode${node.node_id}">
                            <label class="form-check-label" for="deployNode${node.node_id}">
                                ${escapeHtml(displayName)}
                                <code class="text-muted small">${node.hex_id || ''}</code>
                            </label>
                        </div>
                    `;
                }
                container.innerHTML = html;
            } else {
                container.innerHTML = '<span class="text-muted small">No administrable nodes available</span>';
            }
        } catch (error) {
            container.innerHTML = `<span class="text-danger small">Error: ${error.message}</span>`;
        }
    }

    function selectAllDeployNodes() {
        document.querySelectorAll('.deploy-node-checkbox').forEach(cb => cb.checked = true);
    }

    function deselectAllDeployNodes() {
        document.querySelectorAll('.deploy-node-checkbox').forEach(cb => cb.checked = false);
    }

    async function deployTemplate(forceDeployment = false, acknowledgedWarnings = false) {
        if (!currentTemplateId) {
            showAlert('warning', 'Please save the template first');
            return;
        }

        const selectedNodes = [];
        document.querySelectorAll('.deploy-node-checkbox:checked').forEach(cb => {
            selectedNodes.push(parseInt(cb.value));
        });

        if (selectedNodes.length === 0) {
            showAlert('warning', 'Please select at least one node');
            return;
        }

        const deployBtn = document.getElementById('deployTemplateBtn');
        deployBtn.disabled = true;
        deployBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Validating...';

        const resultsDiv = document.getElementById('deploymentResults');
        resultsDiv.style.display = 'block';
        resultsDiv.innerHTML = '<div class="text-muted"><i class="bi bi-shield-check"></i> Checking configuration safety...</div>';

        try {
            const response = await fetch(`/api/admin/templates/${currentTemplateId}/deploy`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    node_ids: selectedNodes,
                    force: forceDeployment,
                    acknowledged_warnings: acknowledgedWarnings,
                }),
            });

            const result = await response.json();

            // Check if we need to show warnings/blocking issues
            if (result.requires_force || result.requires_acknowledgment) {
                let html = '';

                // Show blocking issues (critical)
                if (result.blocking_issues && result.blocking_issues.length > 0) {
                    html += `
                        <div class="alert alert-danger py-2 mb-2">
                            <strong><i class="bi bi-exclamation-octagon"></i> Critical Issues:</strong>
                            <ul class="mb-0 mt-1">
                    `;
                    for (const issue of result.blocking_issues) {
                        html += `<li>${escapeHtml(issue)}</li>`;
                    }
                    html += `
                            </ul>
                        </div>
                    `;
                }

                // Show warnings
                if (result.warnings && result.warnings.length > 0) {
                    html += `
                        <div class="alert alert-warning py-2 mb-2">
                            <strong><i class="bi bi-exclamation-triangle"></i> Warnings:</strong>
                            <ul class="mb-0 mt-1">
                    `;
                    for (const warning of result.warnings) {
                        html += `<li>${escapeHtml(warning)}</li>`;
                    }
                    html += `
                            </ul>
                        </div>
                    `;
                }

                // Show action buttons
                if (result.requires_force) {
                    html += `
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-secondary btn-sm" onclick="cancelDeploy()">
                                Cancel
                            </button>
                            <button class="btn btn-danger btn-sm" onclick="deployTemplate(true, true)">
                                <i class="bi bi-exclamation-triangle"></i> Deploy Anyway (Dangerous)
                            </button>
                        </div>
                        <p class="text-muted small mt-2 mb-0">
                            <i class="bi bi-info-circle"></i>
                            Deploying this configuration may make nodes unreachable for future remote administration.
                        </p>
                    `;
                } else if (result.requires_acknowledgment) {
                    html += `
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-secondary btn-sm" onclick="cancelDeploy()">
                                Cancel
                            </button>
                            <button class="btn btn-warning btn-sm" onclick="deployTemplate(false, true)">
                                <i class="bi bi-check-lg"></i> I Understand, Proceed
                            </button>
                        </div>
                    `;
                }

                resultsDiv.innerHTML = html;
                deployBtn.disabled = false;
                deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
                return;
            }

            // Normal deployment success/failure handling
            deployBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Deploying...';
            resultsDiv.innerHTML = '<div class="text-muted"><i class="bi bi-hourglass-split"></i> Deploying to nodes...</div>';

            // Display results
            let html = '';
            if (result.summary) {
                const alertClass = result.summary.failed === 0 ? 'alert-success' : 'alert-warning';
                html += `
                    <div class="alert ${alertClass} py-2 mb-2">
                        <strong>Deployment Complete:</strong>
                        ${result.summary.successful}/${result.summary.total} successful
                    </div>
                `;
            }

            if (result.results && result.results.length > 0) {
                html += '<ul class="list-unstyled mb-0 small">';
                for (const r of result.results) {
                    const icon = r.success ? 'check-circle text-success' : 'x-circle text-danger';
                    const message = r.success ? r.message : r.error;
                    html += `
                        <li>
                            <i class="bi bi-${icon}"></i>
                            <code>${r.hex_id}</code>: ${escapeHtml(message || 'Unknown')}
                        </li>
                    `;
                }
                html += '</ul>';
            }

            resultsDiv.innerHTML = html;
            loadDeploymentHistory();

        } catch (error) {
            resultsDiv.innerHTML = `<div class="alert alert-danger py-2">${error.message}</div>`;
        } finally {
            deployBtn.disabled = false;
            deployBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Deploy to Selected Nodes';
        }
    }

    function cancelDeploy() {
        const resultsDiv = document.getElementById('deploymentResults');
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
    }

    async function loadDeploymentHistory() {
        const tbody = document.getElementById('deploymentHistoryBody');

        try {
            const response = await fetch('/api/admin/deployments?limit=20');
            const data = await response.json();

            if (data.deployments && data.deployments.length > 0) {
                let html = '';
                for (const dep of data.deployments) {
                    const time = formatAdminDateTime(new Date(dep.deployed_at * 1000));
                    const statusClass = dep.status === 'success' ? 'text-success' : (dep.status === 'failed' ? 'text-danger' : 'text-warning');
                    const statusIcon = dep.status === 'success' ? 'check-circle' : (dep.status === 'failed' ? 'x-circle' : 'hourglass-split');
                    const nodeName = dep.node_name || dep.node_hex || `!${dep.node_id.toString(16).padStart(8, '0')}`;

                    html += `
                        <tr>
                            <td>
                                <span class="badge bg-secondary">${dep.template_type}</span>
                                ${escapeHtml(dep.template_name)}
                            </td>
                            <td><code>${escapeHtml(nodeName)}</code></td>
                            <td class="${statusClass}">
                                <i class="bi bi-${statusIcon}"></i> ${dep.status}
                            </td>
                            <td class="small text-muted">${time}</td>
                        </tr>
                    `;
                }
                tbody.innerHTML = html;
            } else {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No deployments yet</td></tr>';
            }
        } catch (error) {
            tbody.innerHTML = `<tr><td colspan="4" class="text-danger">Error: ${error.message}</td></tr>`;
        }
    }

    // ============================================================================
    // Create Template from Node
    // ============================================================================

    let extractedConfigType = null;
    let extractedConfig = null;

    function showCreateFromNodeModal() {
        resetExtractModal();

        // Populate node dropdown with administrable nodes
        const nodeSelect = document.getElementById('extractSourceNode');
        nodeSelect.innerHTML = '<option value="">Loading nodes...</option>';

        fetch('/api/admin/nodes')
            .then(r => r.json())
            .then(data => {
                if (data.nodes && data.nodes.length > 0) {
                    let html = '<option value="">Select an administrable node...</option>';
                    for (const node of data.nodes) {
                        const hexId = node.hex_id || `!${node.node_id.toString(16).padStart(8, '0')}`;
                        const displayName = node.long_name || node.short_name || hexId;
                        html += `<option value="${node.node_id}">${escapeHtml(displayName)} (${hexId})</option>`;
                    }
                    nodeSelect.innerHTML = html;
                } else {
                    nodeSelect.innerHTML = '<option value="">No administrable nodes found</option>';
                }
            })
            .catch(err => {
                nodeSelect.innerHTML = '<option value="">Error loading nodes</option>';
            });

        // Show/hide channel index based on config type
        document.getElementById('extractConfigType').addEventListener('change', function() {
            document.getElementById('channelIndexRow').style.display =
                this.value === 'channel' ? 'block' : 'none';
        });

        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('createFromNodeModal'));
        modal.show();
    }

    function resetExtractModal() {
        // Reset to step 1
        document.getElementById('extractStep1').style.display = 'block';
        document.getElementById('extractStep2').style.display = 'none';
        document.getElementById('extractBackBtn').style.display = 'none';
        document.getElementById('saveExtractedTemplateBtn').style.display = 'none';

        // Reset form
        document.getElementById('extractSourceNode').value = '';
        document.getElementById('extractConfigType').value = 'lora';
        document.getElementById('extractChannelIndex').value = '0';
        document.getElementById('channelIndexRow').style.display = 'none';
        document.getElementById('extractTemplateName').value = '';
        document.getElementById('extractTemplateDescription').value = '';
        document.getElementById('extractedConfigData').value = '';

        // Reset button state
        const btn = document.getElementById('extractConfigBtn');
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';

        extractedConfigType = null;
        extractedConfig = null;
    }

    async function extractConfigFromNode() {
        const nodeId = document.getElementById('extractSourceNode').value;
        const configType = document.getElementById('extractConfigType').value;
        const channelIndex = document.getElementById('extractChannelIndex').value;

        if (!nodeId) {
            showAlert('warning', 'Please select a source node');
            return;
        }

        const btn = document.getElementById('extractConfigBtn');
        const progressDiv = document.getElementById('extractionProgress');
        const statusEl = document.getElementById('extractionStatus');
        const progressBar = document.getElementById('extractionProgressBar');
        const detailsEl = document.getElementById('extractionDetails');

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Extracting...';
        progressDiv.style.display = 'block';
        statusEl.textContent = 'Connecting to node...';
        progressBar.style.width = '0%';
        detailsEl.textContent = '';

        // Build the SSE URL with query parameters
        const params = new URLSearchParams({
            node_id: nodeId,
            config_type: configType,
            channel_index: channelIndex
        });
        const sseUrl = `/api/admin/templates/extract-from-node/stream?${params.toString()}`;

        let eventSource = null;
        let lastData = null;

        try {
            eventSource = new EventSource(sseUrl);

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    lastData = data;

                    // Update progress display
                    if (data.status) {
                        statusEl.textContent = data.status;
                    }
                    if (data.progress !== undefined) {
                        progressBar.style.width = data.progress + '%';
                    }
                    if (data.details) {
                        detailsEl.textContent = data.details;
                    }

                    // Handle completion
                    if (data.complete) {
                        eventSource.close();
                        progressDiv.style.display = 'none';

                        if (data.success) {
                            // Store extracted data
                            extractedConfigType = configType;
                            extractedConfig = data.config_data;

                            // Show extracted node info
                            const nodeName = document.getElementById('extractSourceNode').selectedOptions[0].text;
                            document.getElementById('extractedFromNode').textContent = nodeName;

                            // Show excluded fields warning if any
                            if (data.excluded_fields && data.excluded_fields.length > 0) {
                                document.getElementById('excludedFieldsList').textContent = data.excluded_fields.join(', ');
                                document.getElementById('excludedFieldsWarning').style.display = 'block';
                            } else {
                                document.getElementById('excludedFieldsWarning').style.display = 'none';
                            }

                            // Populate config preview
                            document.getElementById('extractedConfigData').value = JSON.stringify(data.config_data, null, 2);

                            // Suggest a template name
                            const typeLabel = configType.charAt(0).toUpperCase() + configType.slice(1);
                            document.getElementById('extractTemplateName').value = `${typeLabel} Config from ${nodeName.split(' (')[0]}`;

                            // Switch to step 2
                            document.getElementById('extractStep1').style.display = 'none';
                            document.getElementById('extractStep2').style.display = 'block';
                            document.getElementById('extractBackBtn').style.display = 'inline-block';
                            document.getElementById('saveExtractedTemplateBtn').style.display = 'inline-block';
                        } else {
                            let errorMsg = data.error || 'Failed to extract configuration';
                            if (data.attempts) {
                                errorMsg += ` (after ${data.attempts} attempt(s))`;
                            }
                            showAlert('danger', errorMsg);
                        }

                        btn.disabled = false;
                        btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
                    }
                } catch (e) {
                    console.error('Error parsing SSE message:', e, event.data);
                }
            };

            eventSource.onerror = function(err) {
                console.error('SSE error:', err);
                eventSource.close();
                progressDiv.style.display = 'none';

                // If we got a final response before the error, it may have succeeded
                if (lastData && lastData.complete && lastData.success) {
                    return; // Already handled
                }

                showAlert('danger', 'Connection error while extracting configuration. Please try again.');
                btn.disabled = false;
                btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
            };

        } catch (error) {
            progressDiv.style.display = 'none';
            showAlert('danger', `Error: ${error.message}`);
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-cloud-download"></i> Extract Configuration';
        }
    }

    async function saveExtractedTemplate() {
        const name = document.getElementById('extractTemplateName').value.trim();
        const description = document.getElementById('extractTemplateDescription').value.trim();

        if (!name) {
            showAlert('warning', 'Please enter a template name');
            return;
        }

        if (!extractedConfig) {
            showAlert('danger', 'No configuration data to save');
            return;
        }

        const btn = document.getElementById('saveExtractedTemplateBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

        try {
            const response = await fetch('/api/admin/templates', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name,
                    template_type: extractedConfigType,
                    description: description,
                    config_data: extractedConfig,
                }),
            });

            const data = await response.json();

            if (response.ok && data.success) {
                // Close modal
                bootstrap.Modal.getInstance(document.getElementById('createFromNodeModal')).hide();

                // Refresh templates list
                loadTemplates();

                // Select the new template
                setTimeout(() => {
                    selectTemplate(data.template_id);
                }, 500);

                showAlert('success', `Template "${name}" created successfully`);
            } else {
                showAlert('danger', data.error || 'Failed to create template');
            }

        } catch (error) {
            showAlert('danger', `Error: ${error.message}`);
        } finally {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-save"></i> Create Template';
        }
    }
</script>
{% endblock %}
