{% extends "base.html" %}
{% from "macros.html" import node_link, node_badge, gateway_link, protocol_badge, signal_indicator %}

{% block title %}{{ node.node_name }} - Node Details{% endblock %}

{% block head_libs %}
<!-- Plotly.js for telemetry charts -->
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js" integrity="sha384-H7GB7Kme/VbPI/0S4LNq7OixFNVRgRGE8kyqTntBuiXle1KBm8KWLQh/Ah6bXCYW" crossorigin="anonymous"></script>
<!-- Chart.js for additional visualizations -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" integrity="sha384-e6nUZLBkQ86NJ6TVVKAeSaK8jWa3NhkYWZFomE39AvDbQWeie9PlQqM3pmYW5d1g" crossorigin="anonymous"></script>
{% endblock head_libs %}

{% block extra_css %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    .card-metric {
        text-align: center;
    }
    .metric-value {
        font-size: 2rem;
        font-weight: bold;
    }
    .metric-label {
        color: #6c757d;
        font-size: 0.875rem;
    }
    .signal-indicator {
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: bold;
    }
    .protocol-badge {
        font-size: 0.75rem;
        padding: 4px 8px;
    }
    .neighbor-card {
        border-left: 4px solid #007bff;
        margin-bottom: 0.5rem;
    }
    .vertical-header {
        writing-mode: vertical-rl;
        transform: rotate(180deg);
        padding: 4px 2px;
        white-space: nowrap;
        text-align: left;
    }
    .matrix-table th, .matrix-table td {
        padding: 2px 4px;
        font-size: 0.75rem;
    }
    .matrix-table td { text-align: center; }
    .hw-thumbnail {
        max-height: 48px;
        max-width: 80px;
        margin-left: 12px;
        border-radius: 4px;
        vertical-align: middle;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .hw-model-container {
        display: flex;
        align-items: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/">Home</a></li>
                    <li class="breadcrumb-item"><a href="/nodes">Nodes</a></li>
                    <li class="breadcrumb-item active">{{ node.node_name }}</li>
                </ol>
            </nav>
            <h1>
                <i class="bi bi-router"></i> {{ node.node_name }}
                {% if node.last_seen_relative == "Just now" or "minute" in node.last_seen_relative %}
                    <span class="badge bg-success">Online</span>
                {% elif "hour" in node.last_seen_relative %}
                    <span class="badge bg-warning">Recent</span>
                {% else %}
                    <span class="badge bg-secondary">Offline</span>
                {% endif %}
                <span id="adminBadge" class="badge bg-info d-none" title="This node is remotely administrable">
                    <i class="bi bi-gear-wide-connected"></i> Administrable
                </span>
                <a id="adminButton" href="/admin?node={{ node.hex_id }}" class="btn btn-sm btn-outline-info d-none ms-2" title="Administer this node">
                    <i class="bi bi-sliders"></i> Admin
                </a>
                <button id="archiveButton" class="btn btn-sm btn-outline-warning ms-2" onclick="archiveNode({{ node.node_id }})" title="Archive this node">
                    <i class="bi bi-archive"></i> Archive
                </button>
            </h1>
            <p class="text-muted">
                Node ID: {{ node.hex_id }} ({{ node.node_id }})
                • Last seen: {{ node.last_seen_relative }}
            </p>
        </div>
    </div>

    <!-- Overview Cards -->
    <div class="row mb-4">
        <div class="col-md-3">
            <div class="card card-metric">
                <div class="card-body">
                    <div class="metric-value">{{ node.total_packets }}</div>
                    <div class="metric-label">Total Packets</div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card card-metric">
                <div class="card-body">
                    <div class="metric-value">{{ node.unique_destinations or 0 }}</div>
                    <div class="metric-label">Destinations</div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card card-metric">
                <div class="card-body">
                    <div class="metric-value">
                        {% if node.avg_rssi %}{{ node.avg_rssi|format_rssi }}{% else %}?{% endif %}
                    </div>
                    <div class="metric-label">Avg RSSI (dBm)</div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card card-metric">
                <div class="card-body">
                    <div class="metric-value">
                        {% if node.avg_hops %}{{ node.avg_hops }}{% else %}?{% endif %}
                    </div>
                    <div class="metric-label">Avg Hops</div>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- Node Information -->
        <div class="col-lg-8">
            <!-- Basic Information -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-info-circle"></i> Node Information</h5>
                    <span class="badge bg-light text-dark ms-2" id="timezone-label" style="font-size: 0.8em;">Time: <span id="timezone-label-value">Local</span></span>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <table class="table table-sm">
                                <tr>
                                    <th>Node Name:</th>
                                    <td><strong>{{ node.node_name }}</strong></td>
                                </tr>
                                <tr>
                                    <th>Node ID (Hex):</th>
                                    <td><code>{{ node.hex_id }}</code></td>
                                </tr>
                                <tr>
                                    <th>Node ID (Dec):</th>
                                    <td><code>{{ node.node_id }}</code></td>
                                </tr>
                                {% if node.hw_model %}
                                <tr>
                                    <th>Hardware Model:</th>
                                    <td>
                                        <div class="hw-model-container">
                                            <span>{{ node.hw_model }}</span>
                                            <img src="https://flasher.meshtastic.org/img/devices/{{ node.hw_model | replace('_', '-') | lower }}.svg"
                                                 alt="{{ node.hw_model }}"
                                                 class="hw-thumbnail"
                                                 onerror="this.src='https://flasher.meshtastic.org/img/devices/unknown.svg'"
                                                 loading="lazy">
                                        </div>
                                    </td>
                                </tr>
                                {% endif %}
                                {% if node.role %}
                                <tr>
                                    <th>Role:</th>
                                    <td>{{ node.role }}</td>
                                </tr>
                                {% endif %}
                                {% if node.primary_channel %}
                                <tr>
                                    <th>Primary Channel:</th>
                                    <td>{{ node.primary_channel }}</td>
                                </tr>
                                {% endif %}
                                {% if node.mac_address %}
                                <tr>
                                    <th>MAC Address:</th>
                                    <td><code>{{ node.mac_address }}</code></td>
                                </tr>
                                {% endif %}
                                <tr>
                                    <th>First Seen:</th>
                                    <td>{{ node.first_seen }}</td>
                                </tr>
                            </table>
                        </div>
                        <div class="col-md-6">
                            <table class="table table-sm">
                                <tr>
                                    <th>Last Seen:</th>
                                    <td class="timestamp-display" data-timestamp="{{ node.last_seen_timestamp }}">{{ node.last_seen }}</td>
                                </tr>
                                <tr>
                                    <th>Avg Signal:</th>
                                    <td>
                                        {% if node.avg_rssi %}
                                            {% if node.avg_rssi >= -60 %}
                                                <span class="signal-indicator signal-excellent">{{ node.avg_rssi|format_rssi }} dBm</span>
                                            {% elif node.avg_rssi >= -70 %}
                                                                                <span class="signal-indicator signal-good">{{ node.avg_rssi|format_rssi }} dBm</span>
                            {% elif node.avg_rssi >= -80 %}
                                <span class="signal-indicator signal-fair">{{ node.avg_rssi|format_rssi }} dBm</span>
                                            {% endif %}
                                        {% else %}
                                            <span class="text-muted">Unknown</span>
                                        {% endif %}
                                    </td>
                                </tr>
                                <tr>
                                    <th>Avg SNR:</th>
                                    <td>
                                        {% if node.avg_snr %}
                                            {% if node.avg_snr > 5 %}
                                                                                <span class="signal-indicator signal-excellent">{{ node.avg_snr|format_snr }} dB</span>
                            {% elif node.avg_snr > 0 %}
                                <span class="signal-indicator signal-good">{{ node.avg_snr|format_snr }} dB</span>
                            {% else %}
                                <span class="signal-indicator signal-poor">{{ node.avg_snr|format_snr }} dB</span>
                                            {% endif %}
                                        {% else %}
                                            <span class="text-muted">Unknown</span>
                                        {% endif %}
                                    </td>
                                </tr>
                                <tr>
                                    <th>Firmware Version:</th>
                                    <td>
                                        <span id="firmwareVersion" class="text-muted">Not available</span>
                                        <i id="firmwareInfoTooltip" class="bi bi-info-circle text-muted ms-1"
                                           data-bs-toggle="tooltip"
                                           data-bs-placement="top"
                                           title="Firmware version information requires admin access. If this node is administrable, it will be displayed automatically."></i>
                                    </td>
                                </tr>
                                <tr>
                                    <th>Unique Gateways:</th>
                                    <td>{{ node.unique_gateways }}</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Location Information -->
            {% if location %}
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-geo-alt"></i> Location Information</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <table class="table table-sm">
                                <tr>
                                    <th>Latitude:</th>
                                    <td>{{ "%.6f"|format(location.latitude) }}°</td>
                                </tr>
                                <tr>
                                    <th>Longitude:</th>
                                    <td>{{ "%.6f"|format(location.longitude) }}°</td>
                                </tr>
                                {% if location.altitude %}
                                <tr>
                                    <th>Altitude:</th>
                                    <td>{{ location.altitude }} m</td>
                                </tr>
                                {% endif %}
                            </table>
                        </div>
                        <div class="col-md-6">
                            <table class="table table-sm">
                                <tr>
                                    <th>Location Updated:</th>
                                    <td class="timestamp-display" data-timestamp="{{ location.timestamp_unix }}">{{ location.timestamp }}</td>
                                </tr>
                                <tr>
                                    <th>Time Ago:</th>
                                    <td>{{ location.timestamp_relative }}</td>
                                </tr>
                            </table>
                        </div>
                    </div>

                    <!-- Current Location Map -->
                    <div class="mt-3">
                        <div id="current-location-map" style="height: 300px; border: 1px solid #dee2e6; border-radius: 0.375rem; margin-bottom: 15px;"></div>
                        <a href="https://www.google.com/maps?q={{ location.latitude }},{{ location.longitude }}"
                           target="_blank" class="btn btn-sm btn-outline-primary">
                            <i class="bi bi-map"></i> View on Google Maps
                        </a>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Telemetry Information - Comprehensive -->
            <div class="card mb-4" id="telemetry-card" style="display: none;">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h5 class="mb-1"><i class="bi bi-activity"></i> Telemetry & Health</h5>
                            <small class="text-muted">Complete device status and environmental data</small>
                        </div>
                        <small class="text-muted" id="telemetry-timestamp" style="font-size: 0.8rem;"></small>
                    </div>
                </div>
                <div class="card-body" id="telemetry-content">
                    <div class="d-flex align-items-center justify-content-center" style="min-height: 200px;">
                        <div class="text-center">
                            <div class="spinner-border text-primary" role="status" style="width: 2rem; height: 2rem;">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="mt-3 text-muted">Loading telemetry data...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Telemetry Polling - Only shown when connected to a device -->
            {% if can_send_commands %}
            <div class="card mb-4" id="live-telemetry-card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                        <div>
                            <h5 class="mb-1">
                                <i class="bi bi-broadcast"></i> Live Telemetry
                                <i class="bi bi-info-circle text-muted ms-1" style="font-size: 0.8rem; cursor: help;"
                                   data-bs-toggle="tooltip" data-bs-placement="top"
                                   title="Requests real-time telemetry from the node. Not all nodes respond: Routers typically do, but Client/Tracker/Sensor roles or sleeping nodes may not."></i>
                            </h5>
                            <small class="text-muted" id="live-telemetry-interval-info">Adaptive polling (3-20s based on response time)</small>
                        </div>
                        <div class="d-flex align-items-center gap-2 flex-wrap">
                            <!-- Duration selector -->
                            <div class="btn-group btn-group-sm" role="group" id="live-duration-selector">
                                <button type="button" class="btn btn-outline-secondary active" data-duration="60">1m</button>
                                <button type="button" class="btn btn-outline-secondary" data-duration="300">5m</button>
                                <button type="button" class="btn btn-outline-secondary" data-duration="600">10m</button>
                            </div>
                            <span id="live-telemetry-timer" class="badge bg-secondary d-none">60s</span>
                            <button id="live-telemetry-btn" class="btn btn-sm btn-outline-primary" onclick="toggleLiveTelemetry()">
                                <i class="bi bi-play-fill"></i> Start Live
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body" id="live-telemetry-content">
                    <!-- Current values row -->
                    <div class="row g-3">
                        <div class="col-md-3 col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 mb-0" id="live-battery">--</div>
                                <small class="text-muted">Battery</small>
                            </div>
                        </div>
                        <div class="col-md-3 col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 mb-0" id="live-voltage">--</div>
                                <small class="text-muted">Voltage</small>
                            </div>
                        </div>
                        <div class="col-md-3 col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 mb-0" id="live-channel-util">--</div>
                                <small class="text-muted">Channel Util</small>
                            </div>
                        </div>
                        <div class="col-md-3 col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 mb-0" id="live-air-util">--</div>
                                <small class="text-muted">Air Util TX</small>
                            </div>
                        </div>
                    </div>
                    <div class="row g-3 mt-1">
                        <div class="col-md-4 col-6">
                            <div class="text-center p-2 bg-light rounded">
                                <div class="h5 mb-0" id="live-uptime">--</div>
                                <small class="text-muted">Uptime</small>
                            </div>
                        </div>
                        <div class="col-md-4 col-6">
                            <div class="text-center p-2 bg-light rounded">
                                <div class="h5 mb-0" id="live-temperature">--</div>
                                <small class="text-muted">Temperature</small>
                            </div>
                        </div>
                        <div class="col-md-4 col-12">
                            <div class="text-center p-2 bg-light rounded">
                                <div class="h5 mb-0" id="live-last-update">--</div>
                                <small class="text-muted">Last Update</small>
                            </div>
                        </div>
                    </div>

                    <!-- Polling Metrics Bar Graph (hidden until polling starts) -->
                    <div id="polling-metrics-container" class="mt-3" style="display: none;">
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <small class="text-muted"><i class="bi bi-clock-history"></i> Adaptive Polling</small>
                            <small class="text-muted" id="polling-metrics-label">--</small>
                        </div>
                        <div class="position-relative" style="height: 24px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                            <!-- Poll interval bar (gray background showing max range) -->
                            <div id="poll-interval-bar" style="position: absolute; height: 100%; background: linear-gradient(90deg, #6c757d 0%, #adb5bd 100%); width: 0%; transition: width 0.3s ease;"></div>
                            <!-- Response time bar (overlaid, shows actual response) -->
                            <div id="response-time-bar" style="position: absolute; height: 100%; background: linear-gradient(90deg, #198754 0%, #20c997 100%); width: 0%; transition: width 0.3s ease;"></div>
                            <!-- Labels inside the bar -->
                            <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: space-between; padding: 0 8px; font-size: 11px; font-weight: 500;">
                                <span id="response-label" style="color: white; text-shadow: 0 0 2px rgba(0,0,0,0.5);">--</span>
                                <span id="interval-label" style="color: #333;">--</span>
                            </div>
                        </div>
                        <div class="d-flex justify-content-between mt-1">
                            <small class="text-muted">0s</small>
                            <small class="text-muted">20s (max)</small>
                        </div>

                        <!-- Poll Results Timeline - Visual indicator of success/failure -->
                        <div class="mt-3">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <small class="text-muted"><i class="bi bi-reception-4"></i> Poll Results Timeline</small>
                                <small class="text-muted" id="poll-timeline-summary">--</small>
                            </div>
                            <div id="poll-timeline" class="d-flex align-items-center gap-1 flex-wrap p-2 rounded" style="background: var(--bs-tertiary-bg); min-height: 32px;">
                                <span class="text-muted small">Waiting for first poll...</span>
                            </div>
                            <div class="d-flex justify-content-between mt-1">
                                <small class="text-muted">
                                    <span style="display: inline-block; width: 10px; height: 10px; background: #198754; border-radius: 50%; margin-right: 3px;"></span>Success
                                    <span style="display: inline-block; width: 10px; height: 10px; background: #dc3545; border-radius: 50%; margin-left: 10px; margin-right: 3px;"></span>Failed
                                    <span style="display: inline-block; width: 10px; height: 10px; background: #ffc107; border-radius: 50%; margin-left: 10px; margin-right: 3px;"></span>Slow
                                </small>
                                <small class="text-muted" id="poll-timeline-oldest">← oldest</small>
                            </div>
                        </div>
                    </div>

                    <!-- Live Charts (hidden until polling starts) -->
                    <div id="live-charts-container" class="mt-4" style="display: none;">
                        <h6 class="mb-3"><i class="bi bi-graph-up"></i> Live Trends</h6>
                        <div class="row g-3">
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-body p-2">
                                        <div id="live-chart-battery" style="height: 150px;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-body p-2">
                                        <div id="live-chart-voltage" style="height: 150px;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-body p-2">
                                        <div id="live-chart-channel-util" style="height: 150px;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-body p-2">
                                        <div id="live-chart-air-util" style="height: 150px;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-3">
                        <small class="text-muted" id="live-telemetry-status">
                            <i class="bi bi-info-circle"></i> Select duration and click "Start Live" to begin polling.
                        </small>
                        <!-- Telemetry Stats Display -->
                        <div id="live-telemetry-stats" class="mt-2 d-none">
                            <small class="text-muted">
                                <span class="me-3">
                                    <i class="bi bi-arrow-repeat"></i> Requests: <span id="stats-requests">0</span>
                                </span>
                                <span class="me-3 text-success">
                                    <i class="bi bi-check-circle"></i> Success: <span id="stats-successes">0</span>
                                </span>
                                <span class="me-3 text-warning">
                                    <i class="bi bi-clock"></i> Timeouts: <span id="stats-timeouts">0</span>
                                </span>
                                <span class="badge" id="stats-success-rate-badge">
                                    <span id="stats-success-rate">0</span>% success
                                </span>
                            </small>
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- 7-Day Availability Visualization -->
            <div class="card mb-4">
                <div class="card-header py-2">
                    <h6 class="mb-0"><i class="bi bi-clock-history"></i> 7-Day Availability</h6>
                </div>
                <div class="card-body py-2">
                    {% set container_id = "node-uptime-viz-" ~ node.node_id %}
                    {% set node_id = node.node_id %}
                    {% set days = 7 %}
                    {% set show_labels = True %}
                    {% include "components/uptime_visualization.html" %}
                </div>
            </div>

            <!-- Location History Map -->
            <div class="card mb-4" id="location-history-card" style="display: none;">
                <div class="card-header">
                    <h5><i class="bi bi-map"></i> Location History Map</h5>
                    <small class="text-muted">Historical GPS coordinates sent by this node</small>
                </div>
                <div class="card-body">
                    <div id="location-history-map" style="height: 400px; border: 1px solid #dee2e6; border-radius: 0.375rem;">
                        <div class="d-flex align-items-center justify-content-center h-100">
                            <div class="text-center">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="mt-2 text-muted">Loading location history...</p>
                            </div>
                        </div>
                    </div>
                    <div class="mt-3">
                        <div class="row">
                            <div class="col-md-8">
                                <small class="text-muted">
                                    <i class="bi bi-info-circle"></i>
                                    Map shows historical GPS coordinates reported by this node.
                                    Recent locations are shown in <span class="text-success">green</span>,
                                    older locations in <span class="text-danger">red</span>.
                                    Click markers for details.
                                </small>
                            </div>
                            <div class="col-md-4 text-end">
                                <small class="text-muted" id="location-count">
                                    Loading location data...
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Direct Receptions Graph (Gateway only) -->
            {% include "components/direct_receptions.html" %}

            <!-- Relay Node Analysis (Gateway only) -->
            {% include "components/relay_node_analysis.html" %}

            <!-- Protocol Breakdown -->
            {% if protocols %}
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-graph-up"></i> Protocol Usage</h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-sm">
                            <thead>
                                <tr>
                                    <th>Protocol</th>
                                    <th>Count</th>
                                    <th>Percentage</th>
                                    <th>Avg RSSI</th>
                                    <th>Avg SNR</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for protocol in protocols %}
                                <tr>
                                    <td>
                                        <span class="badge bg-secondary protocol-badge">{{ protocol.protocol }}</span>
                                    </td>
                                    <td>{{ protocol.count }}</td>
                                    <td>
                                        {% set percentage = (protocol.count / node.total_packets * 100) %}
                                        {% set percentage_str = "%.1f"|format(percentage) %}
                                        {{ percentage_str }}%
                                        <div class="progress" style="height: 8px;">
                                            <div class="progress-bar" data-width="{{ percentage_str }}"></div>
                                        </div>
                                    </td>
                                    <td>
                                        {% if protocol.avg_rssi %}
                                            {{ protocol.avg_rssi|format_rssi }} dBm
                                        {% else %}
                                            -
                                        {% endif %}
                                    </td>
                                    <td>
                                        {% if protocol.avg_snr %}
                                            {{ protocol.avg_snr|format_snr }} dB
                                        {% else %}
                                            -
                                        {% endif %}
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Recent Packets (Sent / Reported) -->
            {% if recent_packets or recent_reported_packets %}
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-clock-history"></i> Recent Packets</h5>
                </div>
                <div class="card-body">
                    <!-- Tab selector -->
                    <ul class="nav nav-tabs" id="recentPacketsTab" role="tablist">
                        {% if recent_packets %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="sent-tab" data-bs-toggle="tab" data-bs-target="#sent-tab-pane" type="button" role="tab">Sent</button>
                        </li>
                        {% endif %}
                        {% if recent_reported_packets %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link {% if not recent_packets %}active{% endif %}" id="reported-tab" data-bs-toggle="tab" data-bs-target="#reported-tab-pane" type="button" role="tab">Reported</button>
                        </li>
                        {% endif %}
                        {% if matrix_gateways and recent_packets %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="matrix-tab" data-bs-toggle="tab" data-bs-target="#matrix-tab-pane" type="button" role="tab">Reception Matrix</button>
                        </li>
                        {% endif %}
                    </ul>

                    <div class="tab-content mt-3">
                        {% if recent_packets %}
                        <div class="tab-pane fade show active" id="sent-tab-pane" role="tabpanel" aria-labelledby="sent-tab">
                            <div class="table-responsive">
                                <table class="table table-sm">
                                    <thead>
                                        <tr>
                                            <th>Time</th>
                                            <th>Protocol</th>
                                            <th>To Node</th>
                                            <th>Gateway</th>
                                            <th>RSSI</th>
                                            <th>SNR</th>
                                            <th>Hops</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for packet in recent_packets %}
                                        <tr>
                                            <td><small>{{ packet.timestamp_relative }}</small></td>
                                            <td>{{ protocol_badge(packet.protocol) }}</td>
                                            <td>
                                                {% if packet.to_node_id %}
                                                    {{ node_link(packet.to_node_id, packet.to_node_name) }}
                                                {% else %}
                                                    {{ packet.to_node_name or "Unknown" }}
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.is_grouped %}
                                                    <span class="text-info">{{ packet.gateway_display }}</span>
                                                    {% if packet.gateway_list %}
                                                        <i class="bi bi-info-circle text-muted" data-bs-toggle="tooltip" title="Gateways: {{ packet.gateway_list|join(', ') }}"></i>
                                                    {% endif %}
                                                {% else %}
                                                    {% if packet.gateway_node_id %}
                                                        {{ node_link(packet.gateway_node_id, packet.gateway_name) }}
                                                    {% else %}
                                                        {{ packet.gateway_id or "Unknown" }}
                                                    {% endif %}
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.rssi %}
                                                    {% if packet.is_grouped %}
                                                        <span class="text-info">{{ packet.rssi }}</span>
                                                    {% else %}
                                                        {{ packet.rssi }} dBm
                                                    {% endif %}
                                                {% else %}
                                                    -
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.snr %}
                                                    {% if packet.is_grouped %}
                                                        <span class="text-info">{{ packet.snr }}</span>
                                                    {% else %}
                                                        {{ packet.snr }} dB
                                                    {% endif %}
                                                {% else %}
                                                    -
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.hop_count is not none %}
                                                    {{ packet.hop_count }}
                                                {% else %}
                                                    -
                                                {% endif %}
                                            </td>
                                            <td>
                                                <a href="/packet/{{ packet.id }}" class="btn btn-sm btn-outline-primary">View</a>
                                            </td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                            <div class="mt-3">
                                <a href="/packets?from_node={{ node.node_id }}" class="btn btn-outline-primary">
                                    <i class="bi bi-box"></i> View All Packets from This Node
                                </a>
                            </div>
                        </div>
                        {% endif %}

                        {% if recent_reported_packets %}
                        <div class="tab-pane fade {% if not recent_packets %}show active{% endif %}" id="reported-tab-pane" role="tabpanel" aria-labelledby="reported-tab">
                            <div class="table-responsive">
                                <table class="table table-sm">
                                    <thead>
                                        <tr>
                                            <th>Time</th>
                                            <th>Protocol</th>
                                            <th>From Node</th>
                                            <th>To Node</th>
                                            <th>RSSI</th>
                                            <th>SNR</th>
                                            <th>Hops</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for packet in recent_reported_packets %}
                                        <tr>
                                            <td><small>{{ packet.timestamp_relative }}</small></td>
                                            <td>{{ protocol_badge(packet.protocol) }}</td>
                                            <td>
                                                {% if packet.from_node_id %}
                                                    {{ node_link(packet.from_node_id, packet.from_node_name) }}
                                                {% else %}
                                                    {{ packet.from_node_name or "Unknown" }}
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.to_node_id %}
                                                    {{ node_link(packet.to_node_id, packet.to_node_name) }}
                                                {% else %}
                                                    {{ packet.to_node_name or "Unknown" }}
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.rssi is not none %}
                                                    {{ packet.rssi }} dBm
                                                {% else %}
                                                    -
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.snr is not none %}
                                                    {{ packet.snr }} dB
                                                {% else %}
                                                    -
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if packet.hop_count is not none %}
                                                    {{ packet.hop_count }}
                                                {% else %}
                                                    -
                                                {% endif %}
                                            </td>
                                            <td>
                                                <a href="/packet/{{ packet.id }}" class="btn btn-sm btn-outline-primary">View</a>
                                            </td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                            <div class="mt-3">
                                <a href="/packets?gateway_id={{ node.node_id }}&exclude_self=true" class="btn btn-outline-primary">
                                    <i class="bi bi-box"></i> View All Packets Reported by This Node
                                </a>
                            </div>
                        </div>
                        {% endif %}

                        {% if matrix_gateways and recent_packets %}
                        <div class="tab-pane fade" id="matrix-tab-pane" role="tabpanel" aria-labelledby="matrix-tab">
                            <div class="table-responsive">
                                <table class="table table-sm table-bordered table-hover matrix-table">
                                    <thead>
                                        <tr>
                                            <th>Packet</th>
                                            {% for gw in matrix_gateways %}
                                                <th class="vertical-header">
                                                    {{ node_link(gw.gateway_id, gw.display_name, display_text=gw.short_name, additional_classes="text-white text-decoration-none fw-bold") }}
                                                </th>
                                            {% endfor %}
                                            <th>Count</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for packet in recent_packets %}
                                        {% set received_ids = packet.gateways_detailed | map(attribute='gateway_id') | list %}
                                        {% set received_count = received_ids | length %}
                                        <tr>
                                            <td>
                                                <a href="/packet/{{ packet.id }}" data-bs-toggle="tooltip" title="Sent {{ packet.timestamp_relative }}">
                                                    <code>{% if packet.mesh_packet_id %}{{ "%08x"|format(packet.mesh_packet_id|int) }}{% else %}{{ "%08x"|format(packet.id|int) }}{% endif %}</code>
                                                </a>
                                            </td>
                                            {% for gw in matrix_gateways %}
                                                {% set gw_entry = (packet.gateways_detailed | selectattr('gateway_id', 'equalto', gw.gateway_id) | list | first) %}
                                                {% if gw_entry %}
                                                    {% if gw_entry.hop_count == 0 %}
                                                        <td class="text-center">
                                                            <span class="text-success fw-bold" data-bs-toggle="tooltip" title="{% if gw_entry.rssi is not none %}RSSI: {{ gw_entry.rssi }} dBm {% endif %}{% if gw_entry.snr is not none %}SNR: {{ gw_entry.snr }} dB{% endif %}">0</span>
                                                        </td>
                                                    {% else %}
                                                        <td class="text-center">{{ gw_entry.hop_count }}</td>
                                                    {% endif %}
                                                {% else %}
                                                    <td class="text-muted text-center">-</td>
                                                {% endif %}
                                            {% endfor %}
                                            <td>{{ received_count }}</td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        {% endif %}
                    </div>
                </div>
            </div>
            {% endif %}
        </div>

        <!-- Neighbors & Analytics -->
        <div class="col-lg-4">
            <!-- Received Gateways -->
            {% if received_gateways %}
            <div class="card mb-4">
                <div class="card-header">
                    <h5><i class="bi bi-broadcast"></i> Received Gateways</h5>
                    <small class="text-muted">Gateways that have received packets from this node</small>
                </div>
                <div class="card-body">
                    {% for gateway in received_gateways %}
                    <div class="neighbor-card card">
                        <div class="card-body p-2">
                            <h6 class="card-title mb-1">
                                {% if gateway.gateway_node_id %}
                                    {{ node_link(gateway.gateway_node_id, gateway.display_name) }}
                                {% else %}
                                    {{ gateway.display_name }}
                                {% endif %}
                                {% if gateway.is_direct %}
                                    <span class="badge bg-success ms-1" title="Direct connection (0 hops)">Direct</span>
                                {% endif %}
                            </h6>
                            <div class="row">
                                <div class="col-6">
                                    <small><strong>Packets:</strong> {{ gateway.packet_count }}</small>
                                </div>
                                <div class="col-6">
                                    <small><strong>Hops:</strong> {{ gateway.hop_display }}</small>
                                </div>
                            </div>
                            <div class="row mt-1">
                                <div class="col-6">
                                    <small><strong>Last:</strong> {{ gateway.last_received_relative }}</small>
                                </div>
                                <div class="col-6">
                                    {% if gateway.is_direct and gateway.direct_packet_count > 0 %}
                                        <small><strong>Direct:</strong> {{ gateway.direct_packet_count }} pkts</small>
                                    {% endif %}
                                </div>
                            </div>
                            {% if gateway.avg_rssi or gateway.avg_snr %}
                            <div class="row mt-1">
                                <div class="col-6">
                                    {% if gateway.avg_rssi %}
                                        <small><strong>RSSI:</strong> {{ gateway.avg_rssi }} dBm</small>
                                        {% if gateway.is_direct %}
                                            <i class="bi bi-info-circle text-muted"
                                               data-bs-toggle="tooltip"
                                               title="Signal strength for direct connections (0 hops)"></i>
                                        {% endif %}
                                    {% endif %}
                                </div>
                                <div class="col-6">
                                    {% if gateway.avg_snr %}
                                        <small><strong>SNR:</strong> {{ gateway.avg_snr }} dB</small>
                                        {% if gateway.is_direct %}
                                            <i class="bi bi-info-circle text-muted"
                                               data-bs-toggle="tooltip"
                                               title="Signal quality for direct connections (0 hops)"></i>
                                        {% endif %}
                                    {% endif %}
                                </div>
                            </div>
                            {% endif %}
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endif %}

            <!-- Quick Actions -->
            <div class="card">
                <div class="card-header">
                    <h5><i class="bi bi-lightning"></i> Quick Actions</h5>
                </div>
                <div class="card-body">
                    <div class="d-grid gap-2">
                        <a href="/packets?from_node={{ node.node_id }}" class="btn btn-outline-primary">
                            <i class="bi bi-box"></i> View All Packets
                        </a>
                        {% if location %}
                        <a href="/map?highlight={{ node.node_id }}" class="btn btn-outline-info">
                            <i class="bi bi-map"></i> View on Map
                        </a>
                        {% endif %}
                        <a href="/traceroute?from_node={{ node.node_id }}" class="btn btn-outline-warning">
                            <i class="bi bi-route"></i> View Traceroutes
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Direct Receptions Chart Component -->
<script src="{{ url_for('static', filename='js/direct_receptions.js') }}"></script>

<!-- Relay Node Analysis Component -->
<script src="{{ url_for('static', filename='js/relay_node_analysis.js') }}"></script>

<!-- Location data for JavaScript -->
{% if location %}
<script id="location-data" type="application/json">
{
    "latitude": {{ location.latitude }},
    "longitude": {{ location.longitude }},
    {% if location.altitude %}"altitude": {{ location.altitude }},{% endif %}
    "timestamp": "{{ location.timestamp }}",
    "timestamp_relative": "{{ location.timestamp_relative }}",
    "node_name": "{{ node.node_name }}"
}
</script>
{% endif %}

<script data-node-id="{{ node.node_id }}">
document.addEventListener('DOMContentLoaded', function() {
    // Set progress bar widths from data attributes
    document.querySelectorAll('.progress-bar[data-width]').forEach(function(bar) {
        const width = bar.getAttribute('data-width');
        bar.style.width = width + '%';
    });

    // Load current location map if location data exists
    loadCurrentLocationMap();

    // Load location history map
    loadLocationHistoryMap();

    // Check if node is administrable
    checkAdminStatus();
});

async function checkAdminStatus() {
    const nodeId = document.querySelector('script[data-node-id]').getAttribute('data-node-id');
    try {
        const response = await fetch(`/api/admin/node/${nodeId}/check`);
        const data = await response.json();
        if (data.administrable) {
            // Show the administrable badge
            const badge = document.getElementById('adminBadge');
            if (badge) {
                badge.classList.remove('d-none');
            }

            // Show the admin button
            const adminButton = document.getElementById('adminButton');
            if (adminButton) {
                adminButton.classList.remove('d-none');
            }

            // Display firmware version if available
            if (data.details && data.details.firmware_version) {
                const firmwareEl = document.getElementById('firmwareVersion');
                const tooltipEl = document.getElementById('firmwareInfoTooltip');
                if (firmwareEl) {
                    firmwareEl.textContent = data.details.firmware_version;
                    firmwareEl.classList.remove('text-muted');
                    firmwareEl.classList.add('text-success');
                }
                // Hide the info tooltip since we have the data
                if (tooltipEl) {
                    tooltipEl.classList.add('d-none');
                }
            }
        }
    } catch (error) {
        // Silently fail - admin feature may not be available
        console.debug('Admin check failed:', error);
    }
}

async function archiveNode(nodeId) {
    if (!confirm('Are you sure you want to archive this node? It will be hidden from normal views. If the node sends new packets, it will automatically be restored.')) {
        return;
    }

    try {
        const response = await fetch(`/alerts/api/archive-node/${nodeId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();

        if (data.success) {
            alert('Node archived successfully. Redirecting to nodes list...');
            window.location.href = '/nodes';
        } else {
            alert('Failed to archive node: ' + (data.message || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error archiving node:', error);
        alert('Error archiving node: ' + error.message);
    }
}

function loadCurrentLocationMap() {
    const currentLocationContainer = document.getElementById('current-location-map');
    if (!currentLocationContainer) {
        return; // No current location data available
    }

    // Get location data from the JSON script tag
    const locationDataScript = document.getElementById('location-data');
    if (!locationDataScript) {
        return; // No location data available
    }

    const currentLocation = JSON.parse(locationDataScript.textContent);

    // Initialize map centered on current location
    const currentMap = L.map('current-location-map').setView([
        currentLocation.latitude,
        currentLocation.longitude
    ], 15);

    // Add OpenStreetMap tiles
    // Add theme-appropriate tile layer
    const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
    const tileUrl = isDark
        ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
        : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';

    L.tileLayer(tileUrl, {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
    }).addTo(currentMap);

    // Add marker for current location
    const marker = L.marker([currentLocation.latitude, currentLocation.longitude]).addTo(currentMap);

    // Create popup content
    const popupContent = `
        <div>
            <strong>${currentLocation.node_name}</strong><br>
            <strong>Current Location</strong><br>
            <strong>Coordinates:</strong> ${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}<br>
            ${currentLocation.altitude ? `<strong>Altitude:</strong> ${currentLocation.altitude}m<br>` : ''}
            <strong>Updated:</strong> ${currentLocation.timestamp_relative}<br>
            <small><strong>Recorded:</strong> ${currentLocation.timestamp}</small>
        </div>
    `;
    marker.bindPopup(popupContent).openPopup();
}

async function loadLocationHistoryMap() {
    const scriptTag = document.querySelector('script[data-node-id]');
    const nodeId = scriptTag.getAttribute('data-node-id');
    const mapContainer = document.getElementById('location-history-map');
    const cardContainer = document.getElementById('location-history-card');
    const locationCount = document.getElementById('location-count');

    try {
        // Fetch location history data
        const response = await fetch(`/api/node/${nodeId}/location-history?limit=100`);
        const data = await response.json();

        if (data.error) {
            throw new Error(data.error);
        }

        if (!data.location_history || data.location_history.length === 0) {
            // No location data available, hide the card
            return;
        }

        // Show the card now that we have data
        cardContainer.style.display = 'block';

        // Clear loading content
        mapContainer.innerHTML = '';

        // Initialize map centered on the most recent location
        const mostRecentLocation = data.location_history[0];
        const map = L.map('location-history-map').setView([
            mostRecentLocation.latitude,
            mostRecentLocation.longitude
        ], 13);

        // Add OpenStreetMap tiles
        // Add theme-appropriate tile layer
        const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
        const tileUrl = isDark
            ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
            : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';

        L.tileLayer(tileUrl, {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        // Calculate age-based colors and add markers
        const now = Date.now() / 1000; // Current time in seconds
        const oldestTime = Math.min(...data.location_history.map(loc => loc.timestamp));
        const newestTime = Math.max(...data.location_history.map(loc => loc.timestamp));
        const timeRange = newestTime - oldestTime;

        const pathCoords = [];

        data.location_history.forEach((location, index) => {
            // Calculate age-based color (green for recent, red for old)
            const age = (now - location.timestamp) / 3600; // Age in hours
            let markerColor;
            let radius = 6;

            if (age < 1) {
                markerColor = '#28a745'; // Green for < 1 hour
                radius = 8;
            } else if (age < 24) {
                markerColor = '#ffc107'; // Yellow for < 24 hours
                radius = 7;
            } else if (age < 168) { // 1 week
                markerColor = '#fd7e14'; // Orange for < 1 week
                radius = 6;
            } else {
                markerColor = '#dc3545'; // Red for > 1 week
                radius = 5;
            }

            // Create circle marker
            const marker = L.circleMarker([location.latitude, location.longitude], {
                radius: radius,
                fillColor: markerColor,
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);

            // Create popup content
            // Format timestamp using timezone preference
            const formattedTime = typeof formatTimestamp === 'function'
                ? formatTimestamp(location.timestamp)
                : location.timestamp_str;

            const popupContent = `
                <div>
                    <strong>Location #${data.location_history.length - index}</strong><br>
                    <small class="text-muted">${formattedTime}</small><br>
                    <strong>Coordinates:</strong> ${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}<br>
                    ${location.altitude ? `<strong>Altitude:</strong> ${location.altitude}m<br>` : ''}
                </div>
            `;
            marker.bindPopup(popupContent);

            // Add to path coordinates (in chronological order for path)
            pathCoords.unshift([location.latitude, location.longitude]);
        });

        // Draw path line if we have multiple points
        if (pathCoords.length > 1) {
            L.polyline(pathCoords, {
                color: '#007bff',
                weight: 2,
                opacity: 0.6,
                dashArray: '5, 5' // Dashed line to show movement path
            }).addTo(map);
        }

        // Fit map to show all markers
        if (data.location_history.length > 1) {
            const bounds = L.latLngBounds(data.location_history.map(loc => [loc.latitude, loc.longitude]));
            map.fitBounds(bounds, { padding: [20, 20] });
        }

        // Update location count
        locationCount.textContent = `${data.location_history.length} location points found`;

    } catch (error) {
        console.error('Error loading location history:', error);

        // Show error in map container
        mapContainer.innerHTML = `
            <div class="d-flex align-items-center justify-content-center h-100">
                <div class="text-center text-danger">
                    <i class="bi bi-exclamation-triangle" style="font-size: 2rem;"></i>
                    <div class="mt-2">Error loading location history</div>
                    <div class="small">${error.message}</div>
                </div>
            </div>
        `;

        // Still show the card even on error so users can see what went wrong
        cardContainer.style.display = 'block';
        locationCount.textContent = 'Error loading location data';
    }
}

// ========================= Direct Receptions Chart =========================
// Initialize Direct Receptions Chart Component
let directReceptionsChart;

document.addEventListener('DOMContentLoaded', function() {
    const scriptTag = document.querySelector('script[data-node-id]');
    const nodeId = scriptTag.getAttribute('data-node-id');

    if (nodeId && window.DirectReceptionsChart) {
        directReceptionsChart = new DirectReceptionsChart(nodeId);
        directReceptionsChart.initialize();
    }

    // Format all timestamps based on current timezone preference
    // This ensures timestamps on the detail page respect the timezone setting
    if (typeof updateAllTimestamps === 'function') {
        updateAllTimestamps();
    }

    // Set timezone label
    function setTimezoneLabel() {
        const label = document.getElementById('timezone-label-value');
        if (!label) return;
        if (typeof getTimezonePreference === 'function') {
            const pref = getTimezonePreference();
            label.textContent = pref === 'utc' ? 'UTC' : 'Local';
        }
    }
    setTimezoneLabel();

    // Listen for timezone changes if toggle exists
    if (window.timezoneToggle && typeof window.timezoneToggle.onPreferenceChange === 'function') {
        window.timezoneToggle.onPreferenceChange(setTimezoneLabel);
    }

    // Load telemetry data
    loadTelemetryData();

    // Load health warnings
    loadHealthWarnings();
});

async function loadHealthWarnings() {
    const scriptTag = document.querySelector('script[data-node-id]');
    const nodeId = scriptTag.getAttribute('data-node-id');
    const warningsContainer = document.getElementById('health-warnings-container');
    const warningsContent = document.getElementById('health-warnings-content');

    try {
        const response = await fetch(`/api/health/node/${nodeId}?hours=24`);
        const data = await response.json();

        if (data.error) {
            // Error fetching health data - show error message
            warningsContainer.style.display = 'block';
            warningsContent.innerHTML = `<div class="alert alert-warning mb-0"><small>${data.error}</small></div>`;
            return;
        }

        // Always show the health status, even if no warnings
        warningsContainer.style.display = 'block';

        // Build warnings HTML
        let html = '';

        // Show issues if any exist
        if (data.issues && data.issues.length > 0) {
            // Filter out info-level issues, show only warnings and critical
            const importantIssues = data.issues.filter(i => i.severity !== 'info');

            if (importantIssues.length > 0) {
                html += '<div class="d-flex flex-wrap gap-1 mb-2">';
                for (const issue of importantIssues) {
                    const severityClass = issue.severity === 'critical' ? 'danger' : 'warning';
                    const severityIcon = issue.severity === 'critical' ? 'exclamation-circle-fill' : 'exclamation-triangle-fill';

                    // Shorten the message - extract just the key part
                    let shortMsg = issue.message;
                    // Remove category prefix like "behavior: ", "signal: ", "connectivity: "
                    shortMsg = shortMsg.replace(/^(behavior|signal|connectivity|battery|gateway):\s*/i, '');
                    // Truncate long messages and remove parenthetical info
                    shortMsg = shortMsg.replace(/\s*\([^)]+\)\s*/g, ' ').trim();
                    // Further shorten common phrases
                    shortMsg = shortMsg.replace('Abnormally low activity', 'Low activity');
                    shortMsg = shortMsg.replace('Average RSSI', 'RSSI');
                    shortMsg = shortMsg.replace('Average SNR', 'SNR');
                    shortMsg = shortMsg.replace('Only heard by one gateway', '1 gateway');
                    shortMsg = shortMsg.replace('expected', 'exp');
                    shortMsg = shortMsg.replace('baseline', 'base');
                    // Cap length
                    if (shortMsg.length > 35) shortMsg = shortMsg.substring(0, 32) + '...';

                    html += `<span class="badge bg-${severityClass}" style="font-size: 0.6rem; font-weight: 500; cursor: help;"
                                   data-bs-toggle="tooltip" title="${issue.message.replace(/"/g, '&quot;')}">`;
                    html += `<i class="bi bi-${severityIcon}"></i> ${shortMsg}`;
                    html += '</span>';
                }
                html += '</div>';
            }
        }

        // Always show health score and confidence
        if (data.health_score !== undefined) {
            const scoreClass = data.health_status === 'healthy' ? 'success' :
                              data.health_status === 'degraded' ? 'warning' :
                              data.health_status === 'poor' ? 'danger' : 'dark';

            const confidenceClass = data.confidence_score >= 80 ? 'success' :
                                   data.confidence_score >= 60 ? 'warning' : 'danger';

            html += `<div class="d-flex justify-content-center gap-1 flex-wrap">`;
            html += `<span class="badge bg-${scoreClass}" style="font-size: 0.7rem;">${data.health_score}/100</span>`;
            html += `<span class="badge bg-${confidenceClass}" style="font-size: 0.7rem;" data-bs-toggle="tooltip"
                            title="Confidence: ${data.confidence_score}%. ${data.confidence_factors ? data.confidence_factors.join('; ') : ''}">
                        <i class="bi bi-check-circle"></i> ${data.confidence_score}%</span>`;
            html += '</div>';
        }

        // Add baseline info if available
        if (data.baseline && data.baseline.has_baseline) {
            html += `<div class="mt-2"><small class="text-muted">`;
            html += `<i class="bi bi-graph-up"></i> Baseline: ${data.baseline.avg_packets_per_day.toFixed(1)} packets/day `;
            html += `(${data.baseline.total_days.toFixed(0)} days, ${data.baseline.total_packets} packets)`;
            html += '</small></div>';
        }

        warningsContent.innerHTML = html;

        // Reinitialize tooltips
        const tooltipTriggerList = warningsContent.querySelectorAll('[data-bs-toggle="tooltip"]');
        [...tooltipTriggerList].forEach(tooltipTriggerEl => {
            if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
                new bootstrap.Tooltip(tooltipTriggerEl);
            }
        });

    } catch (error) {
        console.error('Error loading health warnings:', error);
    }
}

async function loadTelemetryData() {
    const scriptTag = document.querySelector('script[data-node-id]');
    const nodeId = scriptTag.getAttribute('data-node-id');
    const telemetryCard = document.getElementById('telemetry-card');
    const telemetryContent = document.getElementById('telemetry-content');

    try {
        // Fetch current telemetry, 24h history (for sparklines), and 7-day history (for hover overlay)
        const [telemetryResponse, history24hResponse, history7dResponse] = await Promise.all([
            fetch(`/api/node/${nodeId}/telemetry`),
            fetch(`/api/node/${nodeId}/telemetry/history?hours=24`),
            fetch(`/api/node/${nodeId}/telemetry/history?hours=168`)
        ]);

        const data = await telemetryResponse.json();
        const history24hData = await history24hResponse.json();
        const history7dData = await history7dResponse.json();

        if (data.error) {
            throw new Error(data.error);
        }

        const telemetry = data.telemetry;
        const history = history24hData.history || {};
        const history7d = history7dData.history || {};

        // Store 7-day history globally for sparkline hover
        window.telemetryHistory7d = history7d;

        if (!telemetry) {
            // No telemetry data available, hide the card
            return;
        }

        // Show the card now that we have data
        telemetryCard.style.display = 'block';

        // Build comprehensive telemetry HTML
        let html = '';

        // Fetch comprehensive health data from the health API
        let nodeHealth = {};
        try {
            const healthResponse = await fetch(`/api/health/node/${nodeId}?hours=24`);
            if (healthResponse.ok) {
                const healthData = await healthResponse.json();
                nodeHealth = healthData;
            }
        } catch (error) {
            console.debug('Could not load health data:', error);
        }

        // Use health data from API
        let healthScore = nodeHealth.health_score !== undefined ? nodeHealth.health_score : 100;
        let healthStatus = nodeHealth.health_status || 'unknown';
        let issues = nodeHealth.issues || [];
        let metrics = nodeHealth.metrics || {};
        let confidenceScore = nodeHealth.confidence_score !== undefined ? nodeHealth.confidence_score : 100;
        let baseline = nodeHealth.baseline || {};

        // Fallback to telemetry-based health if API data unavailable
        if (healthScore === 100 && telemetry.device_metrics) {
            const dm = telemetry.device_metrics;

            // Evaluate battery
            if (dm.battery_level !== undefined) {
                if (dm.battery_level < 20) {
                    healthScore -= 30;
                } else if (dm.battery_level < 50) {
                    healthScore -= 15;
                }
            }

            // Evaluate channel utilization
            if (dm.channel_utilization !== undefined && dm.channel_utilization > 80) {
                healthScore -= 15;
            }
        }

        // Determine health color
        let healthColor = 'success';
        let healthStatusText = 'Healthy';
        if (healthScore >= 80) {
            healthColor = 'success';
            healthStatusText = 'Healthy';
        } else if (healthScore >= 60) {
            healthColor = 'warning';
            healthStatusText = 'Degraded';
        } else if (healthScore >= 40) {
            healthColor = 'danger';
            healthStatusText = 'Poor';
        } else {
            healthColor = 'danger';
            healthStatusText = 'Critical';
        }

        // Build health alerts from issues
        let healthAlerts = [];
        let detailedIssues = [];
        issues.forEach(issue => {
            // Create badge for quick view
            let badgeClass = 'bg-info text-dark';
            if (issue.severity === 'critical') {
                badgeClass = 'bg-danger';
            } else if (issue.severity === 'warning') {
                badgeClass = 'bg-warning text-dark';
            }

            // Format issue with category if available
            let issueText = issue.message;
            if (issue.category) {
                issueText = issue.category + ': ' + issue.message;
            }

            healthAlerts.push('<span class="badge ' + badgeClass + '">' + issueText + '</span>');

            // Store detailed issues for display
            detailedIssues.push({
                severity: issue.severity,
                category: issue.category || 'Other',
                message: issue.message,
                outage_details: issue.outage_details || []
            });
        });

        // Health Summary Row
        html += '<div class="row mb-3 pb-3 border-bottom">';
        html += '<div class="col-12">';
        html += '<div class="d-flex justify-content-between align-items-start mb-2">';
        html += '<div>';
        html += '<h5 class="mb-1"><i class="bi bi-heart-pulse text-' + healthColor + '"></i> <strong>Health: <span class="text-' + healthColor + '">' + healthStatusText + ' (' + Math.round(healthScore) + '/100)</span></strong></h5>';
        html += '<small class="text-muted">Confidence: <span class="badge bg-secondary">' + Math.round(confidenceScore) + '%</span></small>';
        html += '</div>';
        html += '<small class="text-muted text-end" id="telemetry-timestamp-small"></small>';
        html += '</div>';

        if (healthAlerts.length > 0) {
            html += '<div class="d-flex flex-wrap gap-2 mt-2">' + healthAlerts.join('') + '</div>';

            // Show detailed outage information if available
            detailedIssues.forEach(issue => {
                if (issue.outage_details && issue.outage_details.length > 0) {
                    html += '<div class="mt-2 small alert alert-warning mb-0">';
                    html += '<strong>' + issue.category + ' Details:</strong><ul class="mt-1 mb-0">';
                    issue.outage_details.forEach(outage => {
                        // Format timestamps based on timezone preference
                        const startTime = typeof formatTimestamp === 'function'
                            ? formatTimestamp(outage.start_timestamp, 'time')
                            : outage.start_time;
                        const endTime = typeof formatTimestamp === 'function'
                            ? formatTimestamp(outage.end_timestamp, 'time')
                            : outage.end_time;
                        html += '<li>' + outage.duration_formatted + ' - ' + startTime + ' to ' + endTime + '</li>';
                    });
                    html += '</ul></div>';
                }
            });
        } else if (issues.length === 0) {
            html += '<small class="text-success"><i class="bi bi-check-circle"></i> No issues detected</small>';
        }

        // Show metrics summary if available
        if (metrics.total_packets !== undefined) {
            html += '<div class="mt-2 pt-2 border-top" style="font-size: 0.85rem;">';
            html += '<small class="text-muted">24h Metrics: ';
            html += '<strong>' + metrics.total_packets + ' packets</strong>';
            if (metrics.avg_rssi !== undefined && metrics.avg_rssi !== null) {
                html += ' • RSSI: <strong>' + metrics.avg_rssi.toFixed(1) + ' dBm</strong>';
            }
            if (metrics.avg_snr !== undefined && metrics.avg_snr !== null) {
                html += ' • SNR: <strong>' + metrics.avg_snr.toFixed(1) + ' dB</strong>';
            }
            if (metrics.unique_gateways !== undefined) {
                html += ' • <strong>' + metrics.unique_gateways + ' gateway(s)</strong>';
            }
            if (metrics.activity_gaps !== undefined && metrics.activity_gaps > 0) {
                html += ' • <strong>' + metrics.activity_gaps + ' activity gap(s)</strong>';
            }
            if (metrics.long_outages !== undefined && metrics.long_outages > 0) {
                html += ' • <span class="text-warning"><strong>' + metrics.long_outages + ' outage(s)</strong></span>';
            }
            html += '</small>';
            html += '</div>';
        }

        // Show baseline information if available
        if (baseline && baseline.has_baseline) {
            const variabilityText = baseline.coefficient_of_variation > 1.5 ? 'highly variable' :
                                   baseline.coefficient_of_variation > 1.0 ? 'moderately variable' : 'consistent';
            html += '<div class="mt-2 pt-2 border-top small alert alert-info mb-0" style="font-size: 0.85rem;">';
            html += '<strong>Baseline Behavior:</strong> ';
            html += 'Avg ' + baseline.avg_packets_per_day.toFixed(1) + ' packets/day • ';
            html += baseline.total_packets + ' packets over ' + Math.round(baseline.total_days) + ' days • ';
            html += variabilityText + ' pattern';
            html += '</div>';
        }

        html += '</div>';
        html += '</div>';

        // Main Telemetry Grid
        html += '<div class="row g-3">';

        // Power & Battery Section
        html += '<div class="col-lg-6">';
        html += '<h6 class="text-secondary mb-2"><i class="bi bi-battery-charging"></i> Power & Battery</h6>';
        html += '<div class="table-responsive">';

        html += '<table class="table table-sm table-borderless mb-0" style="font-size: 0.9rem;">';

        // Power Type (from analysis)
        if (telemetry.power_type && telemetry.power_type !== 'unknown') {
            const powerIcons = {
                'mains': '<i class="bi bi-plug-fill text-primary"></i>',
                'solar': '<i class="bi bi-sun-fill text-warning"></i>',
                'battery': '<i class="bi bi-battery-full text-success"></i>',
                'usb': '<i class="bi bi-usb-symbol text-info"></i>'
            };
            const powerLabels = {
                'mains': 'Mains Power',
                'solar': 'Solar Powered',
                'battery': 'Battery Only',
                'usb': 'USB Power'
            };
            const icon = powerIcons[telemetry.power_type] || '<i class="bi bi-lightning-charge"></i>';
            const label = powerLabels[telemetry.power_type] || telemetry.power_type;
            const tooltip = telemetry.power_type_reason ? ' title="' + telemetry.power_type_reason + '"' : '';
            html += '<tr>';
            html += '<td class="text-muted" style="width: 50%;">Power Source</td>';
            html += '<td class="text-end fw-bold"' + tooltip + ' data-bs-toggle="tooltip">' + icon + ' ' + label + '</td>';
            html += '</tr>';
        }

        if (telemetry.device_metrics) {
            const dm = telemetry.device_metrics;

            if (dm.battery_level !== undefined) {
                const batteryClass = dm.battery_level > 80 ? 'text-success' : dm.battery_level > 20 ? 'text-warning' : 'text-danger';
                html += '<tr>';
                html += '<td class="text-muted" style="width: 50%;">Battery Level</td>';
                html += '<td class="text-end"><span class="' + batteryClass + ' fw-bold">' + dm.battery_level + '%</span> <span id="spark-battery_level"></span></td>';
                html += '</tr>';
            }

            if (dm.voltage !== undefined && dm.voltage > 0) {
                html += '<tr>';
                html += '<td class="text-muted">Voltage</td>';
                html += '<td class="text-end fw-bold">' + dm.voltage.toFixed(2) + ' V <span id="spark-voltage"></span></td>';
                html += '</tr>';
            }

            if (dm.uptime_seconds !== undefined) {
                const uptime = formatUptime(dm.uptime_seconds);
                html += '<tr>';
                html += '<td class="text-muted">Uptime</td>';
                html += '<td class="text-end fw-bold">' + uptime + '</td>';
                html += '</tr>';
            }
        }

        html += '</table>';
        html += '</div>';
        html += '</div>';

        // Network & Channel Section
        html += '<div class="col-lg-6">';
        html += '<h6 class="text-secondary mb-2"><i class="bi bi-wifi"></i> Network & Radio</h6>';
        html += '<div class="table-responsive">';
        html += '<table class="table table-sm table-borderless mb-0" style="font-size: 0.9rem;">';

        if (telemetry.device_metrics) {
            const dm = telemetry.device_metrics;

            if (dm.channel_utilization !== undefined) {
                const chanClass = dm.channel_utilization > 80 ? 'text-danger' : dm.channel_utilization > 50 ? 'text-warning' : 'text-success';
                html += '<tr>';
                html += '<td class="text-muted" style="width: 50%;">Channel Util</td>';
                html += '<td class="text-end"><span class="' + chanClass + ' fw-bold">' + dm.channel_utilization.toFixed(1) + '%</span> <span id="spark-channel_utilization"></span></td>';
                html += '</tr>';
            }

            if (dm.air_util_tx !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">Air Util TX</td>';
                html += '<td class="text-end fw-bold">' + dm.air_util_tx.toFixed(1) + '% <span id="spark-air_util_tx"></span></td>';
                html += '</tr>';
            }
        }

        html += '</table>';
        html += '</div>';
        html += '</div>';

        // Environment Section
        if (telemetry.environment_metrics) {
            const em = telemetry.environment_metrics;
            html += '<div class="col-lg-6">';
            html += '<h6 class="text-secondary mb-2"><i class="bi bi-cloud"></i> Environment</h6>';
            html += '<div class="table-responsive">';
            html += '<table class="table table-sm table-borderless mb-0" style="font-size: 0.9rem;">';

            if (em.temperature !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted" style="width: 50%;">Temperature</td>';
                // Use TemperatureToggle.formatTemperature to respect user preference, fallback to Celsius
                let tempDisplay = em.temperature.toFixed(1) + ' °C';
                if (typeof TemperatureToggle !== 'undefined' && TemperatureToggle.formatTemperature) {
                    tempDisplay = TemperatureToggle.formatTemperature(em.temperature, 1);
                }
                html += '<td class="text-end fw-bold"><span class="temperature-display" data-temperature-celsius="' + em.temperature + '">' + tempDisplay + '</span> <span id="spark-temperature"></span></td>';
                html += '</tr>';
            }

            if (em.relative_humidity !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">Humidity</td>';
                html += '<td class="text-end fw-bold">' + em.relative_humidity.toFixed(1) + '% <span id="spark-relative_humidity"></span></td>';
                html += '</tr>';
            }

            if (em.barometric_pressure !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">Pressure</td>';
                html += '<td class="text-end fw-bold">' + em.barometric_pressure.toFixed(1) + ' hPa <span id="spark-barometric_pressure"></span></td>';
                html += '</tr>';
            }

            if (em.gas_resistance !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">Gas Resistance</td>';
                html += '<td class="text-end fw-bold">' + em.gas_resistance.toFixed(0) + ' Ω</td>';
                html += '</tr>';
            }

            html += '</table>';
            html += '</div>';
            html += '</div>';
        }

        // Power Metrics Section (only show if there are actual power metrics, not just power_type)
        if (telemetry.power_metrics) {
            const pm = telemetry.power_metrics || {};
            html += '<div class="col-lg-6">';
            html += '<h6 class="text-secondary mb-2"><i class="bi bi-lightning-charge"></i> Power Metrics</h6>';
            html += '<div class="table-responsive">';
            html += '<table class="table table-sm table-borderless mb-0" style="font-size: 0.9rem;">';

            if (pm.ch1_voltage !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted" style="width: 50%;">CH1 Voltage</td>';
                html += '<td class="text-end fw-bold">' + pm.ch1_voltage.toFixed(2) + ' V</td>';
                html += '</tr>';
            }
            if (pm.ch1_current !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">CH1 Current</td>';
                html += '<td class="text-end fw-bold">' + pm.ch1_current.toFixed(2) + ' mA</td>';
                html += '</tr>';
            }
            if (pm.ch2_voltage !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">CH2 Voltage</td>';
                html += '<td class="text-end fw-bold">' + pm.ch2_voltage.toFixed(2) + ' V</td>';
                html += '</tr>';
            }
            if (pm.ch2_current !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">CH2 Current</td>';
                html += '<td class="text-end fw-bold">' + pm.ch2_current.toFixed(2) + ' mA</td>';
                html += '</tr>';
            }
            if (pm.ch3_voltage !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">CH3 Voltage</td>';
                html += '<td class="text-end fw-bold">' + pm.ch3_voltage.toFixed(2) + ' V</td>';
                html += '</tr>';
            }
            if (pm.ch3_current !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">CH3 Current</td>';
                html += '<td class="text-end fw-bold">' + pm.ch3_current.toFixed(2) + ' mA</td>';
                html += '</tr>';
            }

            html += '</table>';
            html += '</div>';
            html += '</div>';
        }

        // Air Quality Section
        if (telemetry.air_quality_metrics) {
            const aq = telemetry.air_quality_metrics;
            html += '<div class="col-lg-6">';
            html += '<h6 class="text-secondary mb-2"><i class="bi bi-wind"></i> Air Quality</h6>';
            html += '<div class="table-responsive">';
            html += '<table class="table table-sm table-borderless mb-0" style="font-size: 0.9rem;">';

            if (aq.pm10_standard !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted" style="width: 50%;">PM1.0</td>';
                html += '<td class="text-end fw-bold">' + aq.pm10_standard + ' µg/m³</td>';
                html += '</tr>';
            }
            if (aq.pm25_standard !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">PM2.5</td>';
                html += '<td class="text-end fw-bold">' + aq.pm25_standard + ' µg/m³</td>';
                html += '</tr>';
            }
            if (aq.pm100_standard !== undefined) {
                html += '<tr>';
                html += '<td class="text-muted">PM10</td>';
                html += '<td class="text-end fw-bold">' + aq.pm100_standard + ' µg/m³</td>';
                html += '</tr>';
            }

            html += '</table>';
            html += '</div>';
            html += '</div>';
        }

        html += '</div>';

        // Update content
        telemetryContent.innerHTML = html;

        // Reinitialize tooltips
        const tooltipTriggerList = telemetryContent.querySelectorAll('[data-bs-toggle="tooltip"]');
        [...tooltipTriggerList].forEach(tooltipTriggerEl => {
            new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // Update timestamp
        if (telemetry.timestamp_relative) {
            document.getElementById('telemetry-timestamp').textContent = telemetry.timestamp_relative;
            // Format timestamp_unix if available, otherwise use timestamp string
            const timestampText = telemetry.timestamp_unix && typeof formatTimestamp === 'function'
                ? formatTimestamp(telemetry.timestamp_unix, 'datetime')
                : telemetry.timestamp;
            document.getElementById('telemetry-timestamp-small').textContent = timestampText;
        }

        // Render sparklines for metrics with history data
        renderSparklines(history);

        // Update timestamps if the function is available
        if (typeof updateAllTimestamps === 'function') {
            updateAllTimestamps();
        }

    } catch (error) {
        console.error('Error loading telemetry data:', error);

        // Show error in content
        telemetryContent.innerHTML = `
            <div class="text-center text-muted">
                <i class="bi bi-info-circle" style="font-size: 2rem;"></i>
                <div class="mt-2">No telemetry data available</div>
                <div class="small">${error.message || 'This node has not sent any telemetry packets yet.'}</div>
            </div>
        `;
    }
}

function renderSparklines(history) {
    // Define sparkline configurations for each metric
    const sparklineConfigs = {
        'battery_level': { color: '#28a745', suffix: '%', min: 0, max: 100 },
        'voltage': { color: '#ffc107', suffix: 'V', min: 0 },
        'channel_utilization': { color: '#17a2b8', suffix: '%', min: 0, max: 100 },
        'air_util_tx': { color: '#6c757d', suffix: '%', min: 0, max: 100 },
        'temperature': { color: '#dc3545', suffix: '', isTemperature: true },
        'relative_humidity': { color: '#007bff', suffix: '%', min: 0, max: 100 },
        'barometric_pressure': { color: '#6610f2', suffix: 'hPa' }
    };

    // Render each sparkline
    Object.keys(sparklineConfigs).forEach(metricName => {
        const container = document.getElementById(`spark-${metricName}`);
        if (container && history[metricName] && history[metricName].length > 1) {
            const config = sparklineConfigs[metricName];
            renderSparkline(container, history[metricName], config);
        }
    });
}

function renderSparkline(container, data, config) {
    const width = 100;
    const height = 20;
    const color = config.color || '#007bff';
    const metricName = container.id.replace('spark-', '');

    // Determine temperature suffix at runtime if this is a temperature metric
    let suffix = config.suffix;
    if (config.isTemperature) {
        // Get temperature unit - check if TemperatureToggle is available
        const unit = (typeof TemperatureToggle !== 'undefined' && TemperatureToggle.getUnit)
            ? TemperatureToggle.getUnit()
            : 'C';
        suffix = unit === 'F' ? '°F' : '°C';
    }

    // Convert temperature data if needed
    let processedData = data;
    if (config.isTemperature && typeof TemperatureToggle !== 'undefined' && TemperatureToggle.celsiusToFahrenheit) {
        const unit = TemperatureToggle.getUnit();
        if (unit === 'F') {
            processedData = data.map(d => ({
                x: d.x,
                y: TemperatureToggle.celsiusToFahrenheit(d.y)
            }));
        }
    }

    // Extract y values
    const values = processedData.map(d => d.y);
    const minVal = config.min !== undefined ? config.min : Math.min(...values);
    const maxVal = config.max !== undefined ? config.max : Math.max(...values);
    const range = maxVal - minVal || 1;

    // Create SVG points for the line
    const points = processedData.map((d, i) => {
        const x = (i / (processedData.length - 1)) * width;
        const y = height - ((d.y - minVal) / range) * height;
        return `${x},${y}`;
    }).join(' ');

    // Create tooltip with trend info
    const lastValue = values[values.length - 1];
    const firstValue = values[0];
    const trend = lastValue > firstValue ? '↗' : lastValue < firstValue ? '↘' : '→';
    const trendColor = lastValue > firstValue ? '#28a745' : lastValue < firstValue ? '#dc3545' : '#6c757d';

    // Store config and suffix for expanded view (7d data will be fetched from global)
    container.dataset.sparkConfig = JSON.stringify(config);
    container.dataset.sparkSuffix = suffix;
    container.dataset.sparkMetric = metricName;

    container.innerHTML = `
        <span class="sparkline-wrapper" style="cursor: pointer; position: relative; display: inline-block;">
            <svg width="${width}" height="${height}" style="vertical-align: middle;">
                <polyline
                    fill="none"
                    stroke="${color}"
                    stroke-width="1.5"
                    points="${points}"
                />
            </svg>
            <span style="color: ${trendColor}; font-size: 12px; margin-left: 4px;" title="24h trend">${trend}</span>
        </span>
    `;

    // Add hover event for expanded chart
    const wrapper = container.querySelector('.sparkline-wrapper');
    wrapper.addEventListener('mouseenter', (e) => showExpandedSparkline(e, container, metricName));
    wrapper.addEventListener('mouseleave', hideExpandedSparkline);
}

// Expanded sparkline overlay functions
let expandedSparklineOverlay = null;

function showExpandedSparkline(event, container, metricName) {
    const config = JSON.parse(container.dataset.sparkConfig || '{}');
    const suffix = container.dataset.sparkSuffix || '';

    // Get 7-day data from global storage
    const history7d = window.telemetryHistory7d || {};
    let data = history7d[metricName] || [];

    if (data.length < 2) return;

    // Convert temperature data if needed
    if (config.isTemperature && typeof TemperatureToggle !== 'undefined' && TemperatureToggle.celsiusToFahrenheit) {
        const unit = TemperatureToggle.getUnit();
        if (unit === 'F') {
            data = data.map(d => ({
                x: d.x,
                y: TemperatureToggle.celsiusToFahrenheit(d.y)
            }));
        }
    }

    // Remove existing overlay
    hideExpandedSparkline();

    // Create overlay
    expandedSparklineOverlay = document.createElement('div');
    expandedSparklineOverlay.className = 'sparkline-expanded-overlay';
    expandedSparklineOverlay.style.cssText = `
        position: fixed;
        z-index: 9999;
        background: var(--bs-body-bg, #fff);
        border: 1px solid var(--bs-border-color, #dee2e6);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.25);
        padding: 12px;
        min-width: 340px;
        pointer-events: none;
    `;

    // Position overlay
    const rect = container.getBoundingClientRect();
    expandedSparklineOverlay.style.left = Math.max(10, rect.left - 120) + 'px';
    expandedSparklineOverlay.style.top = (rect.bottom + 8) + 'px';

    // Make sure it doesn't go off-screen
    document.body.appendChild(expandedSparklineOverlay);
    const overlayRect = expandedSparklineOverlay.getBoundingClientRect();
    if (overlayRect.right > window.innerWidth - 10) {
        expandedSparklineOverlay.style.left = (window.innerWidth - overlayRect.width - 10) + 'px';
    }
    if (overlayRect.bottom > window.innerHeight - 10) {
        expandedSparklineOverlay.style.top = (rect.top - overlayRect.height - 8) + 'px';
    }

    // Calculate stats
    const values = data.map(d => d.y);
    const minVal = Math.min(...values);
    const maxVal = Math.max(...values);
    const avgVal = values.reduce((a, b) => a + b, 0) / values.length;
    const lastVal = values[values.length - 1];

    // Create expanded chart
    const chartWidth = 320;
    const chartHeight = 80;
    const color = config.color || '#007bff';

    const displayMin = config.min !== undefined ? config.min : minVal;
    const displayMax = config.max !== undefined ? config.max : maxVal;
    const range = displayMax - displayMin || 1;

    // Create SVG points
    const points = data.map((d, i) => {
        const x = (i / (data.length - 1)) * chartWidth;
        const y = chartHeight - ((d.y - displayMin) / range) * chartHeight;
        return `${x},${y}`;
    }).join(' ');

    // Create area fill points
    const areaPoints = `0,${chartHeight} ${points} ${chartWidth},${chartHeight}`;

    // Generate time axis labels (7 days)
    const now = new Date();
    const tzPref = typeof getTimezonePreference === 'function' ? getTimezonePreference() : 'local';
    const tzOption = tzPref === 'utc' ? 'UTC' : undefined;

    const timeLabels = [];
    for (let i = 6; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dayName = i === 0 ? 'Today' : date.toLocaleDateString(undefined, { weekday: 'short', timeZone: tzOption });
        const monthDay = date.toLocaleDateString(undefined, { month: 'numeric', day: 'numeric', timeZone: tzOption });
        timeLabels.push({ dayName, monthDay, position: ((6 - i) / 6) * chartWidth });
    }

    // Format metric name for display
    const metricLabels = {
        'battery_level': 'Battery Level',
        'voltage': 'Voltage',
        'channel_utilization': 'Channel Utilization',
        'air_util_tx': 'TX Air Utilization',
        'temperature': 'Temperature',
        'relative_humidity': 'Humidity',
        'barometric_pressure': 'Pressure'
    };
    const label = metricLabels[metricName] || metricName;

    // Build time axis HTML
    const timeAxisHtml = timeLabels.map((t, idx) => {
        const left = t.position;
        const align = idx === 0 ? 'left' : idx === 6 ? 'right' : 'center';
        const transform = idx === 0 ? 'translateX(0)' : idx === 6 ? 'translateX(-100%)' : 'translateX(-50%)';
        return `<div style="position: absolute; left: ${left}px; transform: ${transform}; text-align: ${align}; white-space: nowrap;">
            <div style="font-weight: 500;">${t.dayName}</div>
            <div style="opacity: 0.7;">${t.monthDay}</div>
        </div>`;
    }).join('');

    expandedSparklineOverlay.innerHTML = `
        <div style="font-size: 0.75rem; color: var(--bs-secondary); margin-bottom: 8px; font-weight: 600;">
            ${label} - Last 7 Days
        </div>
        <svg width="${chartWidth}" height="${chartHeight}" style="display: block;">
            <defs>
                <linearGradient id="grad-${metricName}" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:${color};stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:${color};stop-opacity:0.05" />
                </linearGradient>
            </defs>
            <polygon fill="url(#grad-${metricName})" points="${areaPoints}" />
            <polyline fill="none" stroke="${color}" stroke-width="2" points="${points}" />
        </svg>
        <div style="position: relative; height: 28px; margin-top: 4px; font-size: 0.6rem; color: var(--bs-secondary);">
            ${timeAxisHtml}
        </div>
        <div style="display: flex; justify-content: space-between; margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--bs-border-color-translucent); font-size: 0.7rem; color: var(--bs-secondary);">
            <span>Min: <strong style="color: var(--bs-body-color);">${minVal.toFixed(1)}${suffix}</strong></span>
            <span>Avg: <strong style="color: var(--bs-body-color);">${avgVal.toFixed(1)}${suffix}</strong></span>
            <span>Max: <strong style="color: var(--bs-body-color);">${maxVal.toFixed(1)}${suffix}</strong></span>
            <span>Now: <strong style="color: ${color};">${lastVal.toFixed(1)}${suffix}</strong></span>
        </div>
    `;
}

function hideExpandedSparkline() {
    if (expandedSparklineOverlay) {
        expandedSparklineOverlay.remove();
        expandedSparklineOverlay = null;
    }
}

function formatUptime(seconds) {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    let parts = [];
    if (days > 0) parts.push(days + 'd');
    if (hours > 0) parts.push(hours + 'h');
    if (minutes > 0) parts.push(minutes + 'm');

    return parts.join(' ') || '0m';
}

// Listen for temperature unit changes and re-render telemetry
document.addEventListener('temperatureUnitChanged', function() {
    loadTelemetryData();
    // Also update live telemetry display if active
    updateLiveTelemetryTemperature();
});

// Update live telemetry temperature when unit changes
function updateLiveTelemetryTemperature() {
    const tempEl = document.getElementById('live-temperature');
    if (!tempEl || tempEl.textContent === '--') return;

    // Parse current value to get the raw celsius value
    const currentText = tempEl.textContent;
    let celsiusTemp;

    if (currentText.includes('°F')) {
        // Convert back from Fahrenheit to Celsius
        const fahrenheit = parseFloat(currentText);
        celsiusTemp = (fahrenheit - 32) * 5/9;
    } else if (currentText.includes('°C')) {
        celsiusTemp = parseFloat(currentText);
    } else {
        return; // No valid temperature
    }

    const tempUnit = localStorage.getItem('temperatureUnit') || 'celsius';
    if (tempUnit === 'fahrenheit') {
        tempEl.textContent = ((celsiusTemp * 9/5) + 32).toFixed(1) + '°F';
    } else {
        tempEl.textContent = celsiusTemp.toFixed(1) + '°C';
    }
}

// ==================== LIVE TELEMETRY POLLING ====================
let liveTelemetryTimeout = null;
let liveTelemetryStartTime = null;
let liveTelemetryCountdownInterval = null;
let liveTelemetryPollTimeout = null;
let liveTelemetryIsPolling = false;

// Adaptive polling configuration
let liveTelemetryPollInterval = 5000; // Start at 5 seconds
const LIVE_TELEMETRY_MIN_INTERVAL = 3000; // 3 seconds minimum (near real-time)
const LIVE_TELEMETRY_MAX_INTERVAL = 20000; // 20 seconds maximum
let liveTelemetrySelectedDuration = 60000; // Default 1 minute
let liveTelemetryLastResponseTime = 0;
let liveTelemetryConsecutiveSlowResponses = 0;
let liveTelemetryConsecutiveFastResponses = 0;

// Live chart data storage
let liveChartData = {
    timestamps: [],
    battery: [],
    voltage: [],
    channelUtil: [],
    airUtil: []
};

// Poll timeline tracking - stores each poll result
let pollTimelineResults = [];
const MAX_TIMELINE_RESULTS = 50; // Keep last 50 polls visible

// Initialize duration selector
document.addEventListener('DOMContentLoaded', function() {
    const durationBtns = document.querySelectorAll('#live-duration-selector button');
    durationBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            if (liveTelemetryIsPolling) return; // Don't change during polling
            durationBtns.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            liveTelemetrySelectedDuration = parseInt(this.dataset.duration) * 1000;
        });
    });
});

function resetTelemetryStats() {
    // Reset the stats display to zero for a fresh run
    const statsContainer = document.getElementById('live-telemetry-stats');
    if (!statsContainer) return;

    // Hide the container initially (it shows when first stats arrive)
    statsContainer.classList.add('d-none');

    // Reset all values to 0
    document.getElementById('stats-requests').textContent = '0';
    document.getElementById('stats-successes').textContent = '0';
    document.getElementById('stats-timeouts').textContent = '0';
    document.getElementById('stats-success-rate').textContent = '0.0';

    // Reset badge to neutral
    const badge = document.getElementById('stats-success-rate-badge');
    if (badge) {
        badge.className = 'badge bg-secondary';
    }

    // Reset poll timeline
    resetPollTimeline();
}

function resetPollTimeline() {
    pollTimelineResults = [];
    const timeline = document.getElementById('poll-timeline');
    const summary = document.getElementById('poll-timeline-summary');
    if (timeline) {
        timeline.innerHTML = '<span class="text-muted small">Waiting for first poll...</span>';
    }
    if (summary) {
        summary.textContent = '--';
    }
}

function addPollResult(success, responseTime) {
    // Add a new poll result to the timeline
    const now = new Date();
    const result = {
        timestamp: now,
        success: success,
        responseTime: responseTime,
        slow: success && responseTime > 4000 // Consider >4s as slow
    };

    pollTimelineResults.push(result);

    // Keep only last N results
    if (pollTimelineResults.length > MAX_TIMELINE_RESULTS) {
        pollTimelineResults = pollTimelineResults.slice(-MAX_TIMELINE_RESULTS);
    }

    updatePollTimelineDisplay();
}

function updatePollTimelineDisplay() {
    const timeline = document.getElementById('poll-timeline');
    const summary = document.getElementById('poll-timeline-summary');

    if (!timeline) return;

    // Calculate stats
    const total = pollTimelineResults.length;
    const successes = pollTimelineResults.filter(r => r.success).length;
    const failures = pollTimelineResults.filter(r => !r.success).length;
    const slow = pollTimelineResults.filter(r => r.slow).length;
    const successRate = total > 0 ? ((successes / total) * 100).toFixed(0) : 0;

    // Update summary
    if (summary) {
        const avgResponseTime = total > 0
            ? (pollTimelineResults.filter(r => r.success).reduce((sum, r) => sum + r.responseTime, 0) / Math.max(successes, 1) / 1000).toFixed(1)
            : 0;
        summary.innerHTML = `<span class="${failures > 0 ? 'text-danger' : 'text-success'}">${successRate}% success</span> · ${avgResponseTime}s avg`;
    }

    // Build timeline dots
    let html = '';
    pollTimelineResults.forEach((result, index) => {
        let color, title, icon;
        if (!result.success) {
            color = '#dc3545'; // Red for failure
            title = `Poll #${index + 1}: Failed at ${result.timestamp.toLocaleTimeString()}`;
            icon = '✕';
        } else if (result.slow) {
            color = '#ffc107'; // Yellow for slow
            title = `Poll #${index + 1}: ${(result.responseTime / 1000).toFixed(1)}s (slow) at ${result.timestamp.toLocaleTimeString()}`;
            icon = '!';
        } else {
            color = '#198754'; // Green for success
            title = `Poll #${index + 1}: ${(result.responseTime / 1000).toFixed(1)}s at ${result.timestamp.toLocaleTimeString()}`;
            icon = '✓';
        }

        // Create a dot with tooltip
        html += `<div class="poll-dot" style="
            width: 18px;
            height: 18px;
            background: ${color};
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            cursor: help;
            transition: transform 0.15s;
            flex-shrink: 0;
        " title="${title}" onmouseover="this.style.transform='scale(1.3)'" onmouseout="this.style.transform='scale(1)'">${icon}</div>`;
    });

    // Add "newest" indicator
    if (pollTimelineResults.length > 0) {
        html += '<span class="text-muted small ms-2">newest →</span>';
    }

    timeline.innerHTML = html || '<span class="text-muted small">Waiting for first poll...</span>';
}

function updateTelemetryStats(stats) {
    // Update the stats display elements
    const statsContainer = document.getElementById('live-telemetry-stats');
    if (!statsContainer) return;

    // Show the stats container
    statsContainer.classList.remove('d-none');

    // Get node-specific stats if available, otherwise use global stats
    const nodeStats = stats.node_stats;

    // Update stat values - prefer node stats, properly handle 0 values
    const requests = nodeStats !== undefined ? (nodeStats.requests ?? 0) : (stats.total_requests ?? 0);
    const successes = nodeStats !== undefined ? (nodeStats.successes ?? 0) : (stats.successful_responses ?? 0);
    const timeouts = nodeStats !== undefined ? (nodeStats.timeouts ?? 0) : (stats.timeouts ?? 0);
    const successRate = nodeStats !== undefined ? (nodeStats.success_rate ?? 0) : (stats.success_rate ?? 0);

    document.getElementById('stats-requests').textContent = requests;
    document.getElementById('stats-successes').textContent = successes;
    document.getElementById('stats-timeouts').textContent = timeouts;
    document.getElementById('stats-success-rate').textContent = successRate.toFixed(1);

    // Color the badge based on success rate
    const badge = document.getElementById('stats-success-rate-badge');
    if (successRate >= 80) {
        badge.className = 'badge bg-success';
    } else if (successRate >= 50) {
        badge.className = 'badge bg-warning';
    } else {
        badge.className = 'badge bg-danger';
    }
}

function toggleLiveTelemetry() {
    if (liveTelemetryIsPolling) {
        stopLiveTelemetry();
    } else {
        startLiveTelemetry();
    }
}

function startLiveTelemetry() {
    const btn = document.getElementById('live-telemetry-btn');
    const timer = document.getElementById('live-telemetry-timer');
    const status = document.getElementById('live-telemetry-status');
    const chartsContainer = document.getElementById('live-charts-container');
    const pollingMetrics = document.getElementById('polling-metrics-container');
    const durationSelector = document.getElementById('live-duration-selector');

    // Reset adaptive polling - start at 5s, will speed up if responses are fast
    liveTelemetryPollInterval = 5000;
    liveTelemetryConsecutiveSlowResponses = 0;
    liveTelemetryConsecutiveFastResponses = 0;

    // Reset stats display
    resetTelemetryStats();

    // Reset chart data
    liveChartData = {
        timestamps: [],
        battery: [],
        voltage: [],
        channelUtil: [],
        airUtil: []
    };

    // Update UI state
    btn.innerHTML = '<i class="bi bi-stop-fill"></i> Stop';
    btn.classList.remove('btn-outline-primary');
    btn.classList.add('btn-danger');
    timer.classList.remove('d-none');
    chartsContainer.style.display = 'block';
    pollingMetrics.style.display = 'block';
    durationSelector.querySelectorAll('button').forEach(b => b.disabled = true);

    liveTelemetryStartTime = Date.now();
    liveTelemetryIsPolling = true;
    status.innerHTML = '<i class="bi bi-broadcast text-success"></i> Polling for live telemetry data...';

    // Initialize empty charts
    initializeLiveCharts();

    // Start polling immediately
    pollLiveTelemetry();

    // Set up countdown display
    liveTelemetryCountdownInterval = setInterval(updateLiveTelemetryCountdown, 1000);

    // Auto-stop after selected duration
    liveTelemetryTimeout = setTimeout(() => {
        stopLiveTelemetry();
        const durationText = liveTelemetrySelectedDuration >= 60000
            ? Math.round(liveTelemetrySelectedDuration / 60000) + ' minute(s)'
            : Math.round(liveTelemetrySelectedDuration / 1000) + ' seconds';
        status.innerHTML = `<i class="bi bi-info-circle"></i> Polling stopped after ${durationText}. Click "Start Live" to resume.`;
    }, liveTelemetrySelectedDuration);
}

function stopLiveTelemetry() {
    const btn = document.getElementById('live-telemetry-btn');
    const timer = document.getElementById('live-telemetry-timer');
    const status = document.getElementById('live-telemetry-status');
    const durationSelector = document.getElementById('live-duration-selector');
    const pollingMetrics = document.getElementById('polling-metrics-container');

    liveTelemetryIsPolling = false;

    // Clear timeouts
    if (liveTelemetryPollTimeout) {
        clearTimeout(liveTelemetryPollTimeout);
        liveTelemetryPollTimeout = null;
    }
    if (liveTelemetryTimeout) {
        clearTimeout(liveTelemetryTimeout);
        liveTelemetryTimeout = null;
    }
    if (liveTelemetryCountdownInterval) {
        clearInterval(liveTelemetryCountdownInterval);
        liveTelemetryCountdownInterval = null;
    }

    // Update button state
    btn.innerHTML = '<i class="bi bi-play-fill"></i> Start Live';
    btn.classList.remove('btn-danger');
    btn.classList.add('btn-outline-primary');
    timer.classList.add('d-none');
    durationSelector.querySelectorAll('button').forEach(b => b.disabled = false);
    pollingMetrics.style.display = 'none';

    status.innerHTML = '<i class="bi bi-info-circle"></i> Polling stopped. Click "Start Live" to resume.';
}

function updateLiveTelemetryCountdown() {
    const timer = document.getElementById('live-telemetry-timer');
    const intervalInfo = document.getElementById('live-telemetry-interval-info');
    const elapsed = Date.now() - liveTelemetryStartTime;
    const remaining = Math.max(0, Math.ceil((liveTelemetrySelectedDuration - elapsed) / 1000));
    timer.textContent = remaining + 's';

    // Update interval info
    const currentInterval = Math.round(liveTelemetryPollInterval / 1000);
    intervalInfo.textContent = `Polling every ${currentInterval}s (adaptive)`;

    // Change color as time runs out
    if (remaining <= 10) {
        timer.classList.remove('bg-secondary', 'bg-warning');
        timer.classList.add('bg-danger');
    } else if (remaining <= 30) {
        timer.classList.remove('bg-secondary', 'bg-danger');
        timer.classList.add('bg-warning');
    } else {
        timer.classList.remove('bg-danger', 'bg-warning');
        timer.classList.add('bg-secondary');
    }
}

function initializeLiveCharts() {
    const isDarkMode = document.documentElement.getAttribute('data-bs-theme') === 'dark';
    const textColor = isDarkMode ? '#adb5bd' : '#6c757d';
    const gridColor = isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';

    const commonLayout = {
        margin: { t: 30, r: 10, b: 30, l: 40 },
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: textColor, size: 10 },
        xaxis: {
            showgrid: true,
            gridcolor: gridColor,
            tickformat: '%H:%M:%S'
        },
        yaxis: {
            showgrid: true,
            gridcolor: gridColor
        },
        showlegend: false
    };

    const commonConfig = {
        displayModeBar: false,
        responsive: true
    };

    // Battery chart
    Plotly.newPlot('live-chart-battery', [{
        x: [],
        y: [],
        type: 'scatter',
        mode: 'lines+markers',
        line: { color: '#198754', width: 2 },
        marker: { size: 4 },
        name: 'Battery'
    }], { ...commonLayout, title: { text: 'Battery %', font: { size: 12 } }, yaxis: { ...commonLayout.yaxis, range: [0, 100] } }, commonConfig);

    // Voltage chart
    Plotly.newPlot('live-chart-voltage', [{
        x: [],
        y: [],
        type: 'scatter',
        mode: 'lines+markers',
        line: { color: '#0d6efd', width: 2 },
        marker: { size: 4 },
        name: 'Voltage'
    }], { ...commonLayout, title: { text: 'Voltage (V)', font: { size: 12 } } }, commonConfig);

    // Channel utilization chart
    Plotly.newPlot('live-chart-channel-util', [{
        x: [],
        y: [],
        type: 'scatter',
        mode: 'lines+markers',
        line: { color: '#fd7e14', width: 2 },
        marker: { size: 4 },
        name: 'Channel Util'
    }], { ...commonLayout, title: { text: 'Channel Util %', font: { size: 12 } }, yaxis: { ...commonLayout.yaxis, range: [0, 100] } }, commonConfig);

    // Air util chart
    Plotly.newPlot('live-chart-air-util', [{
        x: [],
        y: [],
        type: 'scatter',
        mode: 'lines+markers',
        line: { color: '#6f42c1', width: 2 },
        marker: { size: 4 },
        name: 'Air Util TX'
    }], { ...commonLayout, title: { text: 'Air Util TX %', font: { size: 12 } }, yaxis: { ...commonLayout.yaxis, range: [0, 100] } }, commonConfig);
}

function updateLiveCharts(dm) {
    const now = new Date();
    const getBatteryLevel = () => dm.battery_level ?? dm.batteryLevel;
    const getVoltage = () => dm.voltage;
    const getChannelUtil = () => dm.channel_utilization ?? dm.channelUtilization;
    const getAirUtilTx = () => dm.air_util_tx ?? dm.airUtilTx;

    // Add new data points
    liveChartData.timestamps.push(now);
    liveChartData.battery.push(getBatteryLevel());
    liveChartData.voltage.push(getVoltage());
    liveChartData.channelUtil.push(getChannelUtil());
    liveChartData.airUtil.push(getAirUtilTx());

    // Keep only last 60 data points to avoid memory issues
    const maxPoints = 60;
    if (liveChartData.timestamps.length > maxPoints) {
        liveChartData.timestamps = liveChartData.timestamps.slice(-maxPoints);
        liveChartData.battery = liveChartData.battery.slice(-maxPoints);
        liveChartData.voltage = liveChartData.voltage.slice(-maxPoints);
        liveChartData.channelUtil = liveChartData.channelUtil.slice(-maxPoints);
        liveChartData.airUtil = liveChartData.airUtil.slice(-maxPoints);
    }

    // Update charts with animation
    const updateData = { x: [liveChartData.timestamps], y: [liveChartData.battery] };
    Plotly.update('live-chart-battery', updateData, {}, [0]);

    Plotly.update('live-chart-voltage', { x: [liveChartData.timestamps], y: [liveChartData.voltage] }, {}, [0]);
    Plotly.update('live-chart-channel-util', { x: [liveChartData.timestamps], y: [liveChartData.channelUtil] }, {}, [0]);
    Plotly.update('live-chart-air-util', { x: [liveChartData.timestamps], y: [liveChartData.airUtil] }, {}, [0]);
}

function adjustPollingInterval(responseTime, success) {
    // Aggressive adaptive polling: try to get as close to real-time as possible
    // Use response time + small buffer as the target interval
    const SLOW_THRESHOLD = 4000; // 4 seconds considered slow
    const FAST_THRESHOLD = 1500; // 1.5 seconds considered fast
    const VERY_FAST_THRESHOLD = 800; // Under 800ms is very fast

    if (!success) {
        // Failed request - back off significantly
        liveTelemetryConsecutiveSlowResponses++;
        liveTelemetryConsecutiveFastResponses = 0;
        liveTelemetryPollInterval = Math.min(
            liveTelemetryPollInterval + 3000,
            LIVE_TELEMETRY_MAX_INTERVAL
        );
    } else if (responseTime > SLOW_THRESHOLD) {
        liveTelemetryConsecutiveSlowResponses++;
        liveTelemetryConsecutiveFastResponses = 0;

        // Increase interval after 2 consecutive slow responses
        if (liveTelemetryConsecutiveSlowResponses >= 2) {
            liveTelemetryPollInterval = Math.min(
                liveTelemetryPollInterval + 2000,
                LIVE_TELEMETRY_MAX_INTERVAL
            );
            liveTelemetryConsecutiveSlowResponses = 0;
        }
    } else if (responseTime < VERY_FAST_THRESHOLD) {
        // Very fast response - speed up aggressively
        liveTelemetryConsecutiveFastResponses++;
        liveTelemetryConsecutiveSlowResponses = 0;

        // Speed up after just 1 very fast response
        liveTelemetryPollInterval = Math.max(
            Math.min(liveTelemetryPollInterval - 1000, responseTime + 2000),
            LIVE_TELEMETRY_MIN_INTERVAL
        );
        liveTelemetryConsecutiveFastResponses = 0;
    } else if (responseTime < FAST_THRESHOLD) {
        liveTelemetryConsecutiveFastResponses++;
        liveTelemetryConsecutiveSlowResponses = 0;

        // Speed up after 2 consecutive fast responses
        if (liveTelemetryConsecutiveFastResponses >= 2) {
            liveTelemetryPollInterval = Math.max(
                liveTelemetryPollInterval - 500,
                LIVE_TELEMETRY_MIN_INTERVAL
            );
            liveTelemetryConsecutiveFastResponses = 0;
        }
    } else {
        // Response time is acceptable, reset counters
        liveTelemetryConsecutiveSlowResponses = 0;
        liveTelemetryConsecutiveFastResponses = 0;
    }
}

function updatePollingMetrics(pollInterval, responseTime, success) {
    // Update the visual bar graph showing poll interval vs response time
    const container = document.getElementById('polling-metrics-container');
    const pollIntervalBar = document.getElementById('poll-interval-bar');
    const responseTimeBar = document.getElementById('response-time-bar');
    const responseLabel = document.getElementById('response-label');
    const intervalLabel = document.getElementById('interval-label');
    const metricsLabel = document.getElementById('polling-metrics-label');

    if (!container || container.style.display === 'none') return;

    const maxInterval = LIVE_TELEMETRY_MAX_INTERVAL; // 30000ms
    const pollIntervalSec = pollInterval / 1000;
    const responseTimeSec = responseTime / 1000;

    // Calculate percentages (capped at 100%)
    const intervalPercent = Math.min((pollInterval / maxInterval) * 100, 100);
    const responsePercent = Math.min((responseTime / maxInterval) * 100, 100);

    // Update bar widths
    pollIntervalBar.style.width = intervalPercent + '%';
    responseTimeBar.style.width = responsePercent + '%';

    // Update bar colors based on success/performance
    if (!success) {
        responseTimeBar.style.background = 'linear-gradient(90deg, #dc3545 0%, #e35d6a 100%)'; // Red for failure
    } else if (responseTime > 5000) {
        responseTimeBar.style.background = 'linear-gradient(90deg, #ffc107 0%, #ffda6a 100%)'; // Yellow for slow
    } else {
        responseTimeBar.style.background = 'linear-gradient(90deg, #198754 0%, #20c997 100%)'; // Green for good
    }

    // Update labels
    responseLabel.textContent = success ? `${responseTimeSec.toFixed(1)}s` : 'Failed';
    intervalLabel.textContent = `${pollIntervalSec.toFixed(0)}s interval`;

    // Update summary label
    const efficiency = success ? Math.round((1 - responseTime / pollInterval) * 100) : 0;
    const efficiencyText = efficiency > 0 ? `${efficiency}% headroom` : 'At capacity';
    metricsLabel.textContent = success ? efficiencyText : 'No response';
}

function scheduleNextPoll() {
    if (!liveTelemetryIsPolling) return;

    liveTelemetryPollTimeout = setTimeout(() => {
        if (liveTelemetryIsPolling) {
            pollLiveTelemetry();
        }
    }, liveTelemetryPollInterval);
}

async function pollLiveTelemetry() {
    if (!liveTelemetryIsPolling) return;

    const scriptTag = document.querySelector('script[data-node-id]');
    const nodeId = scriptTag.getAttribute('data-node-id');
    const pollStartTime = Date.now();
    const statusIndicator = document.getElementById('live-telemetry-status');

    try {
        // Calculate timeout based on current poll interval (leave 2s buffer)
        const requestTimeout = Math.min(Math.max(liveTelemetryPollInterval - 2000, 5), 25);

        const response = await fetch(`/api/admin/node/${nodeId}/telemetry/live`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                telemetry_type: 'device_metrics',
                timeout: requestTimeout
            })
        });

        const responseTime = Date.now() - pollStartTime;
        const data = await response.json();

        // Update polling metrics visualization
        updatePollingMetrics(liveTelemetryPollInterval, responseTime, data.success);

        // Update telemetry stats display if available
        if (data.stats) {
            updateTelemetryStats(data.stats);
        }

        // Handle successful live response
        if (data.success && data.telemetry) {
            // Add successful result to timeline
            addPollResult(true, responseTime);

            const intervalSec = Math.round(liveTelemetryPollInterval / 1000);
            const responseSec = Math.round(responseTime/1000);
            statusIndicator.innerHTML = `<span class="badge bg-success">Live</span> <small class="text-muted ms-2">Response: ${responseSec}s | Next poll: ${intervalSec}s</small>`;
            adjustPollingInterval(responseTime, true);

            const telemetry = data.telemetry;
            // Handle both snake_case and camelCase keys from API
            const dm = telemetry.device_metrics || telemetry.deviceMetrics || {};
            const env = telemetry.environment_metrics || telemetry.environmentMetrics || {};

            updateTelemetryDisplay(dm, env);
            updateLiveCharts(dm);
            scheduleNextPoll();
            return;
        }

        // Handle timeout (408) - node didn't respond in time
        if (response.status === 408) {
            // Add failed result to timeline
            addPollResult(false, responseTime);

            statusIndicator.innerHTML = '<span class="badge bg-warning">No Response</span> <small class="text-muted ms-2">Node didn\'t respond (may be sleeping, distant, or not configured to reply). Retrying...</small>';
            adjustPollingInterval(responseTime, false);
            scheduleNextPoll();
            return;
        }

        // Handle other errors - show error but keep trying live
        // Add failed result to timeline
        addPollResult(false, responseTime);

        const errorMsg = data.error || 'Unknown error';
        if (errorMsg.includes('TCP not connected')) {
            statusIndicator.innerHTML = '<span class="badge bg-danger">Not Connected</span> <small class="text-muted ms-2">Connect via Admin page first</small>';
        } else if (errorMsg.includes('MQTT')) {
            statusIndicator.innerHTML = '<span class="badge bg-danger">MQTT Mode</span> <small class="text-muted ms-2">Live telemetry requires TCP connection</small>';
        } else {
            statusIndicator.innerHTML = `<span class="badge bg-warning">Error</span> <small class="text-muted ms-2">${errorMsg}</small>`;
        }

        // Still schedule next poll - connection might be restored
        adjustPollingInterval(responseTime, false);
        scheduleNextPoll();

    } catch (error) {
        console.error('Live telemetry fetch failed:', error);
        // Add failed result to timeline for network errors
        addPollResult(false, Date.now() - pollStartTime);

        statusIndicator.innerHTML = '<span class="badge bg-danger">Network Error</span> <small class="text-muted ms-2">Check connection...</small>';
        adjustPollingInterval(Date.now() - pollStartTime, false);
        scheduleNextPoll();
    }
}

async function pollCachedTelemetry() {
    const scriptTag = document.querySelector('script[data-node-id]');
    const nodeId = scriptTag.getAttribute('data-node-id');

    try {
        const response = await fetch(`/api/node/${nodeId}/telemetry`);
        const data = await response.json();

        if (data.error) {
            console.error('Telemetry error:', data.error);
            return;
        }

        const telemetry = data.telemetry;
        if (!telemetry) return;

        const dm = telemetry.device_metrics || {};
        const env = telemetry.environment_metrics || {};

        updateTelemetryDisplay(dm, env);
    } catch (error) {
        console.error('Cached telemetry fetch failed:', error);
    }
}

function updateTelemetryDisplay(dm, env) {
    // Helper to get value from either snake_case or camelCase keys
    const getBatteryLevel = () => dm.battery_level ?? dm.batteryLevel;
    const getVoltage = () => dm.voltage;
    const getChannelUtil = () => dm.channel_utilization ?? dm.channelUtilization;
    const getAirUtilTx = () => dm.air_util_tx ?? dm.airUtilTx;
    const getUptimeSeconds = () => dm.uptime_seconds ?? dm.uptimeSeconds;
    const getTemperature = () => env.temperature;

    // Update battery
    const batteryEl = document.getElementById('live-battery');
    const batteryLevel = getBatteryLevel();
    if (batteryLevel !== undefined) {
        batteryEl.textContent = batteryLevel + '%';
        batteryEl.className = 'h4 mb-0 ' + (batteryLevel < 20 ? 'text-danger' : batteryLevel < 50 ? 'text-warning' : 'text-success');
    } else {
        batteryEl.textContent = '--';
        batteryEl.className = 'h4 mb-0';
    }

    // Update voltage
    const voltageEl = document.getElementById('live-voltage');
    const voltage = getVoltage();
    if (voltage !== undefined) {
        voltageEl.textContent = voltage.toFixed(2) + 'V';
        voltageEl.className = 'h4 mb-0 ' + (voltage < 3.3 ? 'text-danger' : voltage < 3.6 ? 'text-warning' : 'text-success');
    } else {
        voltageEl.textContent = '--';
        voltageEl.className = 'h4 mb-0';
    }

    // Update channel utilization
    const chUtilEl = document.getElementById('live-channel-util');
    const channelUtil = getChannelUtil();
    if (channelUtil !== undefined) {
        chUtilEl.textContent = channelUtil.toFixed(1) + '%';
        chUtilEl.className = 'h4 mb-0 ' + (channelUtil > 80 ? 'text-danger' : channelUtil > 50 ? 'text-warning' : '');
    } else {
        chUtilEl.textContent = '--';
        chUtilEl.className = 'h4 mb-0';
    }

    // Update air util TX
    const airUtilEl = document.getElementById('live-air-util');
    const airUtilTx = getAirUtilTx();
    if (airUtilTx !== undefined) {
        airUtilEl.textContent = airUtilTx.toFixed(1) + '%';
        airUtilEl.className = 'h4 mb-0 ' + (airUtilTx > 25 ? 'text-danger' : airUtilTx > 10 ? 'text-warning' : '');
    } else {
        airUtilEl.textContent = '--';
        airUtilEl.className = 'h4 mb-0';
    }

    // Update uptime
    const uptimeEl = document.getElementById('live-uptime');
    const uptimeSeconds = getUptimeSeconds();
    if (uptimeSeconds !== undefined) {
        uptimeEl.textContent = formatUptime(uptimeSeconds);
    } else {
        uptimeEl.textContent = '--';
    }

    // Update temperature
    const tempEl = document.getElementById('live-temperature');
    const temperature = getTemperature();
    if (temperature !== undefined) {
        const tempUnit = localStorage.getItem('temperatureUnit') || 'celsius';
        if (tempUnit === 'fahrenheit') {
            tempEl.textContent = ((temperature * 9/5) + 32).toFixed(1) + '°F';
        } else {
            tempEl.textContent = temperature.toFixed(1) + '°C';
        }
    } else {
        tempEl.textContent = '--';
    }

    // Update last update time
    const lastUpdateEl = document.getElementById('live-last-update');
    const now = new Date();
    lastUpdateEl.textContent = now.toLocaleTimeString();

    // Flash effect to show update
    const card = document.getElementById('live-telemetry-content');
    card.style.transition = 'background-color 0.3s';
    card.style.backgroundColor = 'rgba(25, 135, 84, 0.1)';
    setTimeout(() => {
        card.style.backgroundColor = '';
    }, 300);
}
</script>
{% endblock %}
