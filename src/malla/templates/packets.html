{% extends "base.html" %}
{% from "macros.html" import node_picker, gateway_picker %}
{% from "components/table_layout_macros.html" import fullscreen_table_container, filter_section, table_controls_section, grouping_section, table_stats_section, table_layout_styles %}

{% block title %}Packets - Malla{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/node-picker.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/modern-table.css') }}">
{{ table_layout_styles() }}
<style>
    /* ==================== Animations ==================== */
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translateY(-30px);
            max-height: 0;
        }
        to {
            opacity: 1;
            transform: translateY(0);
            max-height: 100px;
        }
    }

    @keyframes pulseRow {
        0%, 100% {
            background-color: rgba(13, 110, 253, 0.15);
            box-shadow: inset 0 0 0 0 rgba(13, 110, 253, 0.3);
        }
        50% {
            background-color: rgba(13, 110, 253, 0.25);
            box-shadow: inset 0 0 0 2px rgba(13, 110, 253, 0.2);
        }
    }

    @keyframes fadeInRow {
        from {
            opacity: 0;
            transform: translateX(-10px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @keyframes livePulse {
        0%, 100% {
            opacity: 1;
            box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
        }
        50% {
            opacity: 0.8;
            box-shadow: 0 0 0 6px rgba(40, 167, 69, 0.3);
        }
    }

    @keyframes scaleIn {
        from {
            transform: scale(0.95);
            opacity: 0;
        }
        to {
            transform: scale(1);
            opacity: 1;
        }
    }

    /* ==================== New Packets Notification ==================== */
    /* ==================== Timestamp Styling ==================== */
    .timestamp-relative {
        display: block;
        font-size: 0.75rem !important;
        opacity: 0.85;
        margin-top: 2px;
    }

    /* ==================== Packet Row Styling ==================== */
    .packet-row-new {
        animation: pulseRow 0.8s ease-out forwards, fadeInRow 0.5s ease-out forwards !important;
        background-color: rgba(13, 110, 253, 0.08) !important;
    }

    .modern-table-container tbody tr {
        transition: all 0.3s ease;
    }

    .modern-table-container tbody tr:hover {
        background-color: rgba(13, 110, 253, 0.05);
        box-shadow: inset 1px 0 0 rgba(13, 110, 253, 0.1);
    }

    /* ==================== Stats Cards - Enhanced ==================== */
    .card {
        border: 1px solid rgba(0, 0, 0, 0.08);
    }

    .card.shadow-sm {
        transition: all 0.3s ease;
    }

    .card.shadow-sm:hover {
        transform: translateY(-4px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.12) !important;
        border-color: rgba(13, 110, 253, 0.2);
    }

    .card-title {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .ppm-live-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #28a745;
        animation: livePulse 2s infinite;
        display: inline-block;
    }

    /* ==================== Filter Section Enhancement ==================== */
    .filter-section-header {
        font-weight: 600;
        color: var(--bs-primary);
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* ==================== Auto-Add Button ==================== */
    #autoAddButton {
        transition: all 0.3s ease;
        font-size: 0.9rem;
    }

    #autoAddButton[data-state="playing"] {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
    }

    #autoAddButton[data-state="playing"]:hover {
        background-color: #218838;
        border-color: #218838;
    }

    #autoAddButton[data-state="paused"] {
        background-color: transparent;
        border-color: #6c757d;
        color: #6c757d;
    }

    #autoAddButton[data-state="paused"]:hover {
        background-color: #f8f9fa;
        border-color: #6c757d;
    }

    /* ==================== Responsive ==================== */
    @media (max-width: 768px) {
        .new-packets-notification {
            font-size: 0.9rem;
            padding: 10px 16px;
            top: 70px;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Override the base template's container to make this page full-width/full-height -->
</div> <!-- Close the base template's container -->

<!-- High-Level Stats Cards -->
<div class="container-fluid mb-3" style="padding: 1rem;">
    <div class="row g-3">
        <div class="col-md-4">
            <div class="card shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6 class="card-title mb-0">
                            <i class="bi bi-speedometer2"></i> Packets/Min
                            <span class="ppm-live-indicator" title="Live updating"></span>
                        </h6>
                        <small class="text-muted">live + 24h avg</small>
                    </div>
                    <div id="gauge-ppm" style="height: 120px; display: flex; align-items: center; justify-content: center; position: relative;">
                        <div class="spinner-border spinner-border-sm text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div class="text-center mt-2">
                        <small id="ppm-value" class="text-muted">-- packets/min</small>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6 class="card-title mb-0">
                            <i class="bi bi-plus-circle"></i> New Nodes
                        </h6>
                        <small class="text-muted">Last 24h</small>
                    </div>
                    <div id="gauge-nodes" style="height: 120px; display: flex; align-items: center; justify-content: center;">
                        <div class="spinner-border spinner-border-sm text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div class="text-center mt-2">
                        <small id="nodes-value" class="text-muted">-- new nodes</small>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6 class="card-title mb-0">
                            <i class="bi bi-broadcast"></i> Gateway Avg
                        </h6>
                        <small class="text-muted">Per packet</small>
                    </div>
                    <div id="gauge-gateway" style="height: 120px; display: flex; align-items: center; justify-content: center;">
                        <div class="spinner-border spinner-border-sm text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div class="text-center mt-2">
                        <small id="gateway-value" class="text-muted">-- gateways</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% call fullscreen_table_container("packetsTable", "Packets", "bi bi-envelope", "toggleSidebar", show_auto_add=true) %}
    <!-- Main table content -->
    <div id="packetsTable" class="modern-table-container"></div>
{% endcall %}

<!-- Sidebar content (will be injected into the sidebar) -->
<div id="sidebarContent" style="display: none;">
    {% call filter_section("filtersForm", "Packet Filters") %}
        <div class="row g-3">
            <div class="col-12">
                <label for="start_time" class="form-label">Start Time</label>
                <input type="datetime-local" class="form-control form-control-sm" id="start_time" name="start_time">
            </div>
            <div class="col-12">
                <label for="end_time" class="form-label">End Time</label>
                <input type="datetime-local" class="form-control form-control-sm" id="end_time" name="end_time">
            </div>
            <div class="col-12">
                {{ node_picker(
                    field_name="from_node",
                    label="From Node",
                    selected_value="",
                    selected_display="",
                    placeholder="All nodes",
                    include_broadcast=true
                ) }}
            </div>
            <div class="col-12">
                {{ node_picker(
                    field_name="to_node",
                    label="To Node",
                    selected_value="",
                    selected_display="",
                    placeholder="All destination nodes",
                    include_broadcast=true
                ) }}
            </div>
            <div class="col-12">
                {{ node_picker(
                    field_name="exclude_from",
                    label="Exclude From Node",
                    selected_value="",
                    selected_display="",
                    placeholder="No exclusions",
                    include_broadcast=true
                ) }}
            </div>
            <div class="col-12">
                {{ node_picker(
                    field_name="exclude_to",
                    label="Exclude To Node",
                    selected_value="",
                    selected_display="",
                    placeholder="No exclusions",
                    include_broadcast=true
                ) }}
            </div>
            <div class="col-12">
                {{ gateway_picker(
                    field_name="gateway_id",
                    label="Gateway (Receiver)",
                    selected_value="",
                    selected_display="",
                    placeholder="All gateways"
                ) }}
            </div>
            <div class="col-12">
                <label for="portnum" class="form-label">Packet Type</label>
                <select class="form-select form-select-sm" id="portnum" name="portnum">
                    <option value="">All Types</option>
                    <!-- Options will be loaded dynamically -->
                </select>
            </div>
            <div class="col-12">
                <label for="hop_count" class="form-label">Hop Count</label>
                <select class="form-select form-select-sm" id="hop_count" name="hop_count">
                    <option value="">Any Hops</option>
                    <option value="0">Direct (0 hops)</option>
                    <option value="1">1 hop</option>
                    <option value="2">2 hops</option>
                    <option value="3">3 hops</option>
                    <option value="99">4+ hops</option>
                </select>
            </div>
            <div class="col-12">
                <label for="min_rssi" class="form-label">Min RSSI</label>
                <input type="number" class="form-control form-control-sm" id="min_rssi" name="min_rssi" placeholder="-120">
            </div>
            <!-- Exclude self-reported gateway messages -->
            <div class="col-12">
                <div class="form-check d-flex align-items-center">
                    <input class="form-check-input me-2" type="checkbox" id="exclude_self" name="exclude_self">
                    <label class="form-check-label mb-0" for="exclude_self">
                        Exclude gateway self messages
                    </label>
                </div>
            </div>
            <div class="col-12">
                <label for="primary_channel" class="form-label">Primary Channel</label>
                <select class="form-select form-select-sm" id="primary_channel" name="primary_channel">
                    <option value="">All Channels</option>
                    <!-- Options will be loaded dynamically -->
                </select>
            </div>
        </div>
    {% endcall %}

    {{ grouping_section("group_packets", "Group by Packet ID", "Group packets with the same mesh packet ID") }}

    {% set table_controls = [
        {"class": "btn-primary", "id": "applyFilters", "icon": "bi bi-search", "text": "Apply Filters", "type": "button"},
        {"class": "btn-outline-secondary", "id": "clearFilters", "icon": "bi bi-x-circle", "text": "Clear Filters", "type": "button"},
        {"class": "btn-outline-info", "id": "refreshTable", "icon": "bi bi-arrow-clockwise", "text": "Refresh", "type": "button"},
    ] %}
    {{ table_controls_section(table_controls) }}

    {% set stats_items = [
        {"label": "Total Packets", "id": "statsTotal", "default": "0"},
        {"label": "Filtered", "id": "statsFiltered", "default": "0"},
        {"label": "Grouped", "id": "statsGrouped", "default": "0"},
        {"label": "Last Update", "id": "statsLastUpdate", "default": "--"}
    ] %}
    {{ table_stats_section("tableStats", stats_items) }}
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/url-filter-manager.js') }}"></script>
<script src="{{ url_for('static', filename='js/filter-store.js') }}"></script>
<script src="{{ url_for('static', filename='js/table-filter-controller.js') }}"></script>
<script src="{{ url_for('static', filename='js/node-picker.js') }}"></script>
<script src="{{ url_for('static', filename='js/modern-table.js') }}"></script>
<script>
// ==================== Auto-Add Button System ====================
let newPacketsCount = 0;
let hasNewPackets = false;
let lastPacketTimestamp = Math.floor(Date.now() / 1000);

function updateAutoAddButtonState() {
    const button = document.getElementById('autoAddButton');
    if (!button) return;

    if (autoAddEnabled) {
        button.setAttribute('data-state', 'playing');
        button.innerHTML = '<i class="bi bi-pause-fill"></i> <span id="autoAddButtonText">Pause</span>';
        button.title = 'Auto-add enabled - click to disable';
    } else {
        button.setAttribute('data-state', 'paused');
        button.innerHTML = '<i class="bi bi-play-fill"></i> <span id="autoAddButtonText">Play</span>';
        button.title = 'Auto-add disabled - click to enable';
    }
}

// ==================== Stats Update Functions ====================
async function updatePacketStats() {
    try {
        // Fetch packets per minute
        const ppmResponse = await fetch('/api/stats/packets-per-minute');
        const ppmData = await ppmResponse.json();

        // Fetch new nodes
        const nodesResponse = await fetch('/api/stats/new-nodes-24h');
        const nodesData = await nodesResponse.json();

        // Fetch gateway coverage
        const gatewayResponse = await fetch('/api/stats/gateway-coverage');
        const gatewayData = await gatewayResponse.json();

        // Update PPM display
        const ppmValue = ppmData.packets_per_minute || 0;
        document.getElementById('ppm-value').textContent = ppmValue.toFixed(1) + ' packets/min';
        updateGauge('gauge-ppm', ppmValue, 100, 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)');

        // Update New Nodes display
        const newNodesValue = nodesData.new_nodes_24h || 0;
        const activeNodes = nodesData.active_nodes_24h || 1;
        const newNodePercentage = (newNodesValue / activeNodes * 100).toFixed(1);
        document.getElementById('nodes-value').textContent = newNodesValue + ' nodes (' + newNodePercentage + '%)';
        updateGauge('gauge-nodes', newNodePercentage, 100, 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)');

        // Update Gateway Coverage display
        const gatewayValue = gatewayData.coverage_metric || 0;
        document.getElementById('gateway-value').textContent = gatewayValue.toFixed(1) + ' gateways/packet';
        updateGauge('gauge-gateway', gatewayValue * 20, 100, 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)');
    } catch (error) {
        console.error('Error updating packet stats:', error);
    }
}

// Create a simple gauge visualization
function updateGauge(containerId, value, max, gradient) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const percentage = Math.min((value / max) * 100, 100);
    const radius = 40;
    const circumference = 2 * Math.PI * radius;
    const offset = circumference - (percentage / 100) * circumference;

    let svg = container.querySelector('svg');
    if (!svg) {
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 100 100');
        svg.setAttribute('style', 'width: 100px; height: 100px;');

        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gradientEl = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradientEl.setAttribute('id', 'grad-' + containerId);
        gradientEl.setAttribute('x1', '0%');
        gradientEl.setAttribute('y1', '0%');
        gradientEl.setAttribute('x2', '100%');
        gradientEl.setAttribute('y2', '100%');

        // Parse gradient colors
        const colors = gradient.match(/#[0-9a-f]{6}|rgb[^)]*\)/gi) || ['#667eea', '#764ba2'];
        if (colors.length >= 2) {
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', colors[0]);

            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', colors[1]);

            gradientEl.appendChild(stop1);
            gradientEl.appendChild(stop2);
        }
        defs.appendChild(gradientEl);
        svg.appendChild(defs);

        // Background circle
        const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bgCircle.setAttribute('cx', '50');
        bgCircle.setAttribute('cy', '50');
        bgCircle.setAttribute('r', radius);
        bgCircle.setAttribute('fill', 'none');
        bgCircle.setAttribute('stroke', '#e9ecef');
        bgCircle.setAttribute('stroke-width', '8');
        svg.appendChild(bgCircle);

        // Progress circle
        const progressCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        progressCircle.setAttribute('cx', '50');
        progressCircle.setAttribute('cy', '50');
        progressCircle.setAttribute('r', radius);
        progressCircle.setAttribute('fill', 'none');
        progressCircle.setAttribute('stroke', 'url(#grad-' + containerId + ')');
        progressCircle.setAttribute('stroke-width', '8');
        progressCircle.setAttribute('stroke-dasharray', circumference);
        progressCircle.setAttribute('stroke-dashoffset', circumference);
        progressCircle.setAttribute('transform', 'rotate(-90 50 50)');
        progressCircle.setAttribute('style', 'transition: stroke-dashoffset 0.3s ease-in-out;');
        svg.appendChild(progressCircle);

        // Text
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '50');
        text.setAttribute('y', '55');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '20');
        text.setAttribute('font-weight', 'bold');
        text.setAttribute('fill', '#495057');
        text.textContent = '0%';
        svg.appendChild(text);

        container.innerHTML = '';
        container.appendChild(svg);
    }

    // Update progress circle
    const progressCircle = svg.querySelectorAll('circle')[1];
    if (progressCircle) {
        progressCircle.setAttribute('stroke-dashoffset', offset);
    }

    // Update text
    const text = svg.querySelector('text');
    if (text) {
        text.textContent = Math.round(percentage) + '%';
    }
}

document.addEventListener('DOMContentLoaded', function() {
    // Update stats immediately and then every 5 seconds
    updatePacketStats();
    setInterval(updatePacketStats, 5000);

    // ==================== Auto-Add Button Handler ====================
    const autoAddButton = document.getElementById('autoAddButton');

    // Initialize button state on load
    updateAutoAddButtonState();

    autoAddButton?.addEventListener('click', function(e) {
        e.stopPropagation();
        autoAddEnabled = !autoAddEnabled;
        updateAutoAddButtonState();

        // Save preference to localStorage
        localStorage.setItem('autoAddEnabled', autoAddEnabled);
    });

    // Restore auto-add preference from localStorage
    const savedAutoAdd = localStorage.getItem('autoAddEnabled');
    if (savedAutoAdd === 'false') {
        autoAddEnabled = false;
        updateAutoAddButtonState();
    }

    // Move sidebar content into the actual sidebar FIRST
    const sidebarContent = document.getElementById('sidebarContent');
    const sidebarContainer = document.querySelector('.sidebar-content');
    if (sidebarContent && sidebarContainer) {
        sidebarContainer.innerHTML = sidebarContent.innerHTML;
        sidebarContent.remove();
    }

    // Initialize URL filter manager AFTER sidebar content is moved
    const urlManager = new URLFilterManager();

    // Expose urlManager to global scope for debugging and testing
    window.urlManager = urlManager;

    // Initialize sidebar toggle functionality
    const toggleBtn = document.getElementById('toggleSidebar');
    const closeBtn = document.getElementById('closeSidebar');
    const sidebar = document.querySelector('.table-sidebar');

    function toggleSidebar() {
        sidebar.classList.toggle('collapsed');
        const icon = toggleBtn.querySelector('i');
        if (sidebar.classList.contains('collapsed')) {
            icon.className = 'bi bi-layout-sidebar-inset';
        } else {
            icon.className = 'bi bi-layout-sidebar-inset-reverse';
        }
    }

    toggleBtn.addEventListener('click', toggleSidebar);
    closeBtn.addEventListener('click', toggleSidebar);

    // Initialize node and gateway pickers
    if (window.initializeAllPickers) {
        window.initializeAllPickers();
    }

    // Load packet types from API
    async function loadPacketTypes() {
        try {
            const response = await fetch('/api/meshtastic/packet-types');
            const data = await response.json();

            if (data.packet_types) {
                const select = document.getElementById('portnum');
                // Keep the "All Types" option
                const allOption = select.querySelector('option[value=""]');
                select.innerHTML = '';
                select.appendChild(allOption);

                // Add packet type options
                data.packet_types.forEach(([value, displayName]) => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = displayName;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading packet types:', error);
        }
    }

    // Load primary channels for select
    loadPrimaryChannels();

    async function loadPrimaryChannels() {
        try {
            const response = await fetch('/api/meshtastic/channels');
            const data = await response.json();
            if (data.channels) {
                const select = document.getElementById('primary_channel');
                const allOption = select.querySelector('option[value=""]');
                select.innerHTML = '';
                select.appendChild(allOption);
                data.channels.forEach((ch) => {
                    const option = document.createElement('option');
                    option.value = ch;
                    option.textContent = ch;
                    select.appendChild(option);
                });
            }
        } catch (e) {
            console.error('Error loading channels:', e);
        }
    }

    // Initialize page with filters and load data
    async function initializePageWithFilters() {
        // Load packet types first
        await loadPacketTypes();

        // Small delay to ensure DOM is updated
        await new Promise(resolve => setTimeout(resolve, 100));

        // Apply URL parameters
        const hasParams = await urlManager.applyURLParameters();

        // Initialize the filter controller
        controller.initialLoad(hasParams);
    }

    // Generic column configuration system
    const COLUMN_CONFIGS = {
        // Base columns that are always visible
        base: [
            {
                key: 'timestamp',
                title: 'Timestamp',
                sortable: true,
                render: (value, row) => {
                    return renderTimestampColumn(row, 'timestamp', 'id', '/packet/{id}');
                }
            },
            {
                key: 'from_node',
                title: 'From',
                sortable: true,
                render: (value, row) => {
                    if (row.from_node_id) {
                        const shortName = row.from_node_short || row.from_node_id.toString(16).padStart(8, '0').slice(-4);
                        return `<a href="/node/${row.from_node_id}" class="text-decoration-none node-link"
                                   data-node-id="${row.from_node_id}" data-bs-toggle="tooltip"
                                   data-bs-placement="top" data-bs-html="true"
                                   data-bs-title="Loading..." title="View node details">
                                    ${shortName}
                                </a>`;
                    }
                    return `<span class="text-muted">Unknown</span>`;
                }
            },
            {
                key: 'to_node',
                title: 'To',
                sortable: true,
                render: (value, row) => {
                    if (row.to_node_id) {
                        const shortName = row.to_node_short || row.to_node_id.toString(16).padStart(8, '0').slice(-4);
                        return `<a href="/node/${row.to_node_id}" class="text-decoration-none node-link"
                                   data-node-id="${row.to_node_id}" data-bs-toggle="tooltip"
                                   data-bs-placement="top" data-bs-html="true"
                                   data-bs-title="Loading..." title="View node details">
                                    ${shortName}
                                </a>`;
                    }
                    return `<span class="text-muted">Broadcast</span>`;
                }
            },
            {
                key: 'portnum_name',
                title: 'Type',
                sortable: true,
                render: (value, row) => {
                    if (value) {
                        const typeMap = {
                            'TEXT_MESSAGE_APP': 'Text',
                            'POSITION_APP': 'Position',
                            'NODEINFO_APP': 'Node Info',
                            'ROUTING_APP': 'Routing',
                            'ADMIN_APP': 'Admin',
                            'TELEMETRY_APP': 'Telemetry',
                            'TRACEROUTE_APP': 'Traceroute',
                            'NEIGHBORINFO_APP': 'Neighbor Info'
                        };
                        const displayName = typeMap[value] || value;
                        return `<span class="badge bg-secondary">${displayName}</span>`;
                    }
                    return `<span class="text-muted">Unknown</span>`;
                }
            }
        ],

        // Always visible columns
        always: [
            {
                key: 'channel',
                title: 'Channel',
                sortable: true,
                render: (value, row) => {
                    if (value && value !== 'Unknown') {
                        if (value === 'LongFast') {
                            return `<span class="badge bg-primary">${value}</span>`;
                        } else {
                            return `<span class="badge bg-info">${value}</span>`;
                        }
                    }
                    return `<span class="text-muted">Unknown</span>`;
                }
            }
        ],

        // Conditional columns based on packet type
        conditional: {
            'TEXT_MESSAGE_APP': [
                {
                    key: 'text_content',
                    title: 'Message',
                    sortable: false,
                    render: (value, row) => {
                        if (value) {
                            return `<span class="text-break">${value}</span>`;
                        }
                        return `<span class="text-muted">No content</span>`;
                    }
                }
            ]
        },

        // Default columns for all packet types (unless overridden)
        default: [
            {
                key: 'gateway',
                title: 'Gateway',
                sortable: true,
                render: (value, row) => {
                    if (row.is_grouped) {
                        const count = row.gateway_count;
                        if (count > 1) {
                            return `<span class="badge bg-info" title="Multiple gateways: ${row.gateway_list}">
                                        ${count} gateways
                                    </span>`;
                        } else {
                            return `<span class="badge bg-info">${value}</span>`;
                        }
                    } else {
                        const gatewayName = row.gateway_name;
                        const gatewayNodeId = row.gateway_node_id;

                        if (value && value.startsWith('!') && gatewayNodeId) {
                            const shortName = value.substring(value.length - 4).toUpperCase();
                            return `<a href="/node/${gatewayNodeId}" class="text-decoration-none node-link"
                                       data-node-id="${gatewayNodeId}" data-bs-toggle="tooltip"
                                       data-bs-placement="top" data-bs-html="true"
                                       data-bs-title="Loading..." title="View node details">
                                        ${shortName}
                                    </a>`;
                        } else if (gatewayName && gatewayNodeId) {
                            const parenMatch = gatewayName.match(/\(([^)]+)\)$/);
                            const shortName = parenMatch ? parenMatch[1] : gatewayName.substring(0, 4).toUpperCase();
                            return `<a href="/node/${gatewayNodeId}" class="text-decoration-none node-link"
                                       data-node-id="${gatewayNodeId}" data-bs-toggle="tooltip"
                                       data-bs-placement="top" data-bs-html="true"
                                       data-bs-title="Loading..." title="View node details">
                                        ${shortName}
                                    </a>`;
                        }
                        return value || 'N/A';
                    }
                }
            },
            {
                key: 'rssi',
                title: 'RSSI',
                sortable: true,
                render: (value, row) => {
                    if (row.is_grouped) {
                        return value && value !== 'N/A' ?
                            `<span>${value}</span>` :
                            `<span class="text-muted">N/A</span>`;
                    } else if (value !== null && value !== '' && value !== 'N/A') {
                        const rssiValue = parseFloat(value);
                        const colorClass = getRssiColorClass(rssiValue);
                        const formattedValue = rssiValue.toFixed(1);
                        return `<span class="${colorClass}">${formattedValue} dBm</span>`;
                    }
                    return '<span class="text-muted">N/A</span>';
                }
            },
            {
                key: 'snr',
                title: 'SNR',
                sortable: true,
                render: (value, row) => {
                    if (row.is_grouped) {
                        return value && value !== 'N/A' ?
                            `<span>${value}</span>` :
                            `<span class="text-muted">N/A</span>`;
                    } else if (value !== null && value !== '' && value !== 'N/A') {
                        const snrValue = parseFloat(value);
                        const colorClass = getSnrColorClass(snrValue);
                        const formattedValue = snrValue.toFixed(2);
                        return `<span class="${colorClass}">${formattedValue} dB</span>`;
                    }
                    return '<span class="text-muted">N/A</span>';
                }
            },
            {
                key: 'hops',
                title: 'Hops',
                sortable: true,
                render: (value, row) => {
                    if (row.is_grouped) {
                        return value && value !== 'N/A' ?
                            `<span class="text-info">${value}</span>` :
                            `<span class="text-muted">N/A</span>`;
                    } else if (value !== null && value !== '') {
                        const hops = parseInt(value);
                        if (hops === 0) {
                            return `<span class="badge bg-success">Direct</span>`;
                        } else if (hops <= 2) {
                            return `<span class="badge bg-info">${hops}</span>`;
                        } else {
                            return `<span class="badge bg-warning">${hops}</span>`;
                        }
                    }
                    return `<span class="text-muted">N/A</span>`;
                }
            },
            {
                key: 'relay_node',
                title: 'Relay Node',
                sortable: true,
                render: (value, row) => {
                    // For grouped packets, value is already a formatted string (e.g., "0a, 3f*2")
                    if (row.is_grouped && typeof value === 'string' && value) {
                        return `<code>${value}</code>`;
                    }
                    // For individual packets, value is an integer
                    if (value !== null && value !== undefined && value !== 0 && typeof value === 'number') {
                        // Extract last byte
                        const relayHex = (value & 0xFF).toString(16).padStart(2, '0');
                        return `<code>${relayHex}</code>`;
                    }
                    return `<span class="text-muted">-</span>`;
                }
            },
          ],

        // Final columns that are always at the end
        actions: [
            {
                key: 'id',
                title: 'Actions',
                sortable: false,
                render: (value, row) => {
                    return `<a href="/packet/${value}" class="btn btn-sm btn-outline-primary" title="View packet details">
                                <i class="bi bi-eye"></i>
                            </a>`;
                }
            }
        ]
    };

    // Function to get dynamic columns based on current filter
    function getDynamicColumns() {
        const portnum = document.getElementById('portnum')?.value || '';

        let columns = [
            ...COLUMN_CONFIGS.base,
            ...COLUMN_CONFIGS.always
        ];

        // Add conditional columns based on packet type
        if (COLUMN_CONFIGS.conditional[portnum]) {
            columns.push(...COLUMN_CONFIGS.conditional[portnum]);
        }

        // Add default columns (unless we're in a mode that excludes them)
        const excludeDefaultColumns = getExcludedDefaultColumns(portnum);
        const defaultColumns = COLUMN_CONFIGS.default.filter(col =>
            !excludeDefaultColumns.includes(col.key)
        );
        columns.push(...defaultColumns);

        // Add action columns
        columns.push(...COLUMN_CONFIGS.actions);

        return columns;
    }

    // Function to determine which default columns to exclude for specific packet types
    function getExcludedDefaultColumns(portnum) {
        const exclusions = {
            // No column exclusions currently needed
        };
        return exclusions[portnum] || [];
    }



    // Initialize the modern table
    let table = new ModernTable('packetsTable', {
        endpoint: '/api/packets/data',
        enableSearch: false,
        enablePagination: true,
        pageSize: 100,
        deferInitialLoad: true,  // Defer loading until after URL parameters are applied
        columns: getDynamicColumns()
    });

    // Expose table to global scope for debugging and testing
    window.table = table;

    // Update stats function
    function updateStats() {
        const groupPacketsCheckbox = document.getElementById('group_packets');
        document.getElementById('statsTotal').textContent = table.state.totalCount || '0';
        document.getElementById('statsFiltered').textContent = table.state.data.length || '0';
        document.getElementById('statsGrouped').textContent = groupPacketsCheckbox.checked ? 'Yes' : 'No';
        document.getElementById('statsLastUpdate').textContent = new Date().toLocaleTimeString();
    }

    // Real-time auto-update functionality for new packets
    let lastPacketTimestamp = Math.floor(Date.now() / 1000);
    let autoUpdateInterval = null;
    let autoUpdateEnabled = true;
    let hasNewPackets = false;
    let autoAddEnabled = false;

    async function checkForNewPackets() {
        if (!autoUpdateEnabled) return;

        try {
            const response = await fetch(`/api/packets/new?since=${lastPacketTimestamp}&limit=50`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            if (data.packets && data.packets.length > 0) {
                // Update the last timestamp for next check
                const newestTimestamp = Math.max(...data.packets.map(p => p.timestamp));
                lastPacketTimestamp = newestTimestamp;

                // Track that we have new packets
                newPacketsCount = data.packets.length;
                hasNewPackets = true;

                // If auto-add is enabled, automatically refresh the table
                if (autoAddEnabled && window.controller) {
                    window.controller.applyCurrentFilters();
                    hasNewPackets = false;
                }

                // Show visual indicator that new packets arrived
                const lastUpdateEl = document.getElementById('statsLastUpdate');
                if (lastUpdateEl) {
                    lastUpdateEl.classList.add('pulse-update');
                    setTimeout(() => {
                        lastUpdateEl.classList.remove('pulse-update');
                    }, 800);
                }

                updateStats();
            }
        } catch (error) {
            console.debug('Real-time update check failed:', error);
        }
    }

    // Start real-time updates every 3 seconds (just fetches, no refresh)
    autoUpdateInterval = setInterval(checkForNewPackets, 3000);

    // Refresh table when user clicks on it or when they switch back to the tab
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            autoUpdateEnabled = false;
            clearInterval(autoUpdateInterval);
        } else {
            autoUpdateEnabled = true;
            autoUpdateInterval = setInterval(checkForNewPackets, 3000);
            // Refresh when switching back to tab if we have new packets
            if (hasNewPackets && window.controller) {
                window.controller.applyCurrentFilters();
                hasNewPackets = false;
            }
        }
    });

    // Refresh table on user interaction (click, scroll, etc)
    let interactionTimeout = null;
    function handleTableInteraction() {
        if (hasNewPackets) {
            if (interactionTimeout) clearTimeout(interactionTimeout);
            // Debounce the refresh by 1 second to avoid too many refreshes
            interactionTimeout = setTimeout(() => {
                if (hasNewPackets && window.controller) {
                    window.controller.applyCurrentFilters();
                    hasNewPackets = false;
                }
            }, 1000);
        }
    }

    document.addEventListener('click', handleTableInteraction, true);
    document.addEventListener('scroll', handleTableInteraction, true);

    // Live Packets Per Minute (PPM) tracking
    let packetTimestamps = [];
    const TRACKING_WINDOW = 60000; // 1 minute in milliseconds

    function trackPacketArrival() {
        const now = Date.now();
        packetTimestamps.push(now);

        // Remove timestamps older than 1 minute
        packetTimestamps = packetTimestamps.filter(t => now - t < TRACKING_WINDOW);

        updateLivePPMGauge();
    }

    function calculateLivePPM() {
        const now = Date.now();
        // Count packets in the last minute
        const recentPackets = packetTimestamps.filter(t => now - t < TRACKING_WINDOW);
        return recentPackets.length;
    }

    function updateLivePPMGauge() {
        const ppm = calculateLivePPM();
        const maxPPM = 120; // Adjust based on expected max PPM
        const percentage = Math.min(100, (ppm / maxPPM) * 100);

        const ppmValueEl = document.getElementById('ppm-value');
        if (ppmValueEl) {
            ppmValueEl.textContent = ppm.toFixed(1) + ' packets/min';
        }

        // Update gauge (if it exists and is already rendered)
        if (window.updateCircleGauge) {
            window.updateCircleGauge('gauge-ppm', percentage);
        }
    }

    // Update time-ago displays every 30 seconds
    function updateTimeAgoDisplays() {
        if (window.updateAllTimeAgoDisplays) {
            updateAllTimeAgoDisplays();
        }
    }

    setInterval(updateTimeAgoDisplays, 30000);

    // Smooth row insertion with animation
    const originalRenderTableBody = table.renderTableBody;
    const renderedRows = new Set();

    table.renderTableBody = function() {
        // Call original render
        const result = originalRenderTableBody.call(this);

        // Add animation to new rows
        const tbody = table.container.querySelector('tbody');
        if (tbody) {
            const currentRows = Array.from(tbody.querySelectorAll('tr'));
            currentRows.forEach(row => {
                const rowId = row.getAttribute('data-id') || row.dataset.id;
                if (rowId && !renderedRows.has(rowId)) {
                    renderedRows.add(rowId);
                    row.classList.add('packet-row-new');

                    // Track packet arrival for PPM
                    trackPacketArrival();

                    // Remove animation class after animation completes
                    setTimeout(() => {
                        row.classList.remove('packet-row-new');
                    }, 600);
                }
            });
        }

        return result;
    };

    // Initialize the filter controller
    const controller = new TableFilterController({
        table,
        urlManager,
        formSelector: '#filtersForm',
        groupingCheckboxSelector: '#group_packets',
        getDynamicColumns,
        updateStats
    });

    // Expose controller methods to global scope for testing/debugging
    window.applyCurrentFilters = () => controller.applyCurrentFilters();
    window.controller = controller;

    // Button handlers
    const applyFiltersBtn = document.getElementById('applyFilters');
    const clearFiltersBtn = document.getElementById('clearFilters');
    const refreshBtn = document.getElementById('refreshTable');
    const groupPacketsCheckbox = document.getElementById('group_packets');

    applyFiltersBtn.addEventListener('click', () => controller.applyCurrentFilters());
    clearFiltersBtn.addEventListener('click', () => controller.clearFilters());
    refreshBtn.addEventListener('click', () => {
        table.refresh();
        updateStats();
    });

    // Add cleanup when page unloads
    window.addEventListener('beforeunload', function() {
        if (autoUpdateInterval) {
            clearInterval(autoUpdateInterval);
        }
    });

    // Helper functions for signal quality color coding
    function getRssiColorClass(rssi) {
        if (rssi >= -60) return 'text-success'; // Excellent
        if (rssi >= -70) return 'text-info';    // Good
        if (rssi >= -80) return 'text-warning'; // Fair
        return 'text-danger';                   // Poor
    }

    function getSnrColorClass(snr) {
        if (snr > 5) return 'text-success';     // Excellent
        if (snr > 0) return 'text-info';       // Good
        if (snr > -5) return 'text-warning';   // Fair
        return 'text-danger';                  // Poor
    }

    // Initialize tooltips after table loads
    table.on('dataLoaded', function() {
        // Initialize Bootstrap tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
        updateStats();
    });

    // Initialize page
    initializePageWithFilters();
});
</script>
{% endblock %}
