{% extends "base.html" %}
{% from "components/sidebar_macros.html" import sidebar_container, selected_details_section, search_section, controls_section, stats_section, legend_section, sidebar_styles %}

{% block content %}
<!-- Override the base template's container to make this page full-width/full-height -->
</div> <!-- Close the base template's container -->

<div class="graph-container">
    <!-- Main Graph Area -->
    <div class="graph-main">
        <div id="loadingSpinner" class="loading-overlay">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2 text-muted">Building network graph...</p>
        </div>
        <div id="networkGraph" class="network-graph"></div>
        <div id="graphError" class="error-overlay" style="display: none;">
            <i class="bi bi-exclamation-triangle"></i>
            <p class="mt-2">Error loading graph data</p>
        </div>
    </div>

    <!-- Sidebar -->
    {% call sidebar_container("sidebar", "Network Graph", "bi bi-diagram-3", "toggleSidebar") %}
        <!-- Selected Details -->
        <div class="sidebar-section" id="selectedDetails" style="display: none;">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0"><i class="bi bi-info-circle"></i> <span id="selectedDetailsTitle">Selection</span></h6>
                <button id="clearSelection" class="btn btn-sm btn-outline-secondary">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
            <div id="selectedDetailsContent"></div>
        </div>

        <!-- Hover Details -->
        <div class="sidebar-section">
            <h6><i class="bi bi-eye"></i> Hover Details</h6>
            <div id="hoverDetails" class="hover-details">
                <small class="text-muted">Hover over nodes or links for details</small>
            </div>
        </div>

        <!-- Hop Filter (shown when node is selected) -->
        <div class="sidebar-section" id="hopFilterSection" style="display: none;">
            <h6><i class="bi bi-funnel"></i> Hop Distance Filter</h6>
            <div class="mb-2">
                <label for="hopDistance" class="form-label">Show nodes within <span id="hopDistanceValue">3</span> hops</label>
                <input type="range" class="form-range" id="hopDistance" min="1" max="10" value="3" step="1">
            </div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="enableHopFilter" checked>
                <label class="form-check-label" for="enableHopFilter">
                    Enable hop filter
                </label>
            </div>
            <div id="hopFilterStats" class="text-muted small" style="display: none;">
                Showing <strong><span id="visibleNodeCount">0</span></strong> of <strong><span id="totalNodeCount">0</span></strong> nodes
            </div>
        </div>

        {{ search_section("nodeSearch", "clearSearch", "searchResults") }}

        <!-- Auto-Refresh Control -->
        <div class="sidebar-section">
            <h6><i class="bi bi-lightning-charge"></i> Live Updates</h6>
            <div class="mb-3">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="autoRefreshToggle" checked>
                    <label class="form-check-label" for="autoRefreshToggle">
                        Auto-refresh
                    </label>
                </div>
                <small class="text-muted d-block mt-1">
                    Refreshes: <strong id="autoRefreshStatus">every 30s</strong>
                </small>
                <div id="autoRefreshTimer" class="small text-muted mt-2" style="display: none;">
                    Next update in <span id="refreshCountdown">30</span>s
                </div>
            </div>
            <div class="mb-3">
                <label for="autoRefreshInterval" class="form-label">Interval</label>
                <select class="form-select form-select-sm" id="autoRefreshInterval">
                    <option value="10">Every 10 seconds</option>
                    <option value="15">Every 15 seconds</option>
                    <option value="30" selected>Every 30 seconds</option>
                    <option value="60">Every minute</option>
                </select>
            </div>
        </div>

        {% set graph_controls = [
            {"class": "btn-outline-secondary", "onclick": "centerGraph()", "icon": "bi bi-arrows-move", "text": "Center Graph"},
            {"class": "btn-outline-secondary", "onclick": "resetZoom()", "icon": "bi bi-zoom-out", "text": "Reset Zoom"},
            {"class": "btn-outline-primary", "onclick": "refreshGraph()", "icon": "bi bi-arrow-clockwise", "text": "Refresh Now"}
        ] %}
        {{ controls_section(graph_controls) }}

        <!-- Activity Feed -->
        <div class="sidebar-section">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0"><i class="bi bi-activity"></i> Recent Activity</h6>
                <button id="clearActivityFeed" class="btn btn-sm btn-link p-0" style="font-size: 0.8rem;">Clear</button>
            </div>
            <div id="activityFeed" class="activity-feed">
                <small class="text-muted">Waiting for activity...</small>
            </div>
        </div>

        <!-- Link Activity Highlighting -->
        <div class="sidebar-section">
            <h6><i class="bi bi-diagram-2"></i> Link Activity</h6>
            <div class="mb-3">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="enableLinkHighlight" checked>
                    <label class="form-check-label" for="enableLinkHighlight">
                        Show recent links
                    </label>
                </div>
            </div>
            <div class="mb-3">
                <label for="linkDecayTime" class="form-label">Highlight Duration</label>
                <div class="d-flex align-items-center gap-2">
                    <input type="range" class="form-range" id="linkDecayTime" min="5" max="120" value="15" step="5">
                    <span class="badge bg-secondary" id="linkDecayTimeValue">15s</span>
                </div>
                <small class="text-muted d-block mt-1">Links fade after this duration</small>
            </div>
        </div>

        <!-- Filters -->
        <div class="sidebar-section">
            <h6><i class="bi bi-funnel"></i> Filters</h6>
            <form id="filterForm">
                <div class="mb-3">
                    <label for="hours" class="form-label">Time Period</label>
                    <select class="form-select form-select-sm" id="hours" name="hours">
                        <option value="1" {% if hours == 1 %}selected{% endif %}>Last Hour</option>
                        <option value="6" {% if hours == 6 %}selected{% endif %}>Last 6 Hours</option>
                        <option value="24" {% if hours == 24 %}selected{% endif %}>Last 24 Hours</option>
                        <option value="72" {% if hours == 72 %}selected{% endif %}>Last 3 Days</option>
                        <option value="168" {% if hours == 168 %}selected{% endif %}>Last Week</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="min_snr" class="form-label">Minimum SNR (dB)</label>
                    <select class="form-select form-select-sm" id="min_snr" name="min_snr">
                        <option value="-200" {% if min_snr == -200 %}selected{% endif %}>No Limit</option>
                        <option value="-99" {% if min_snr == -99 %}selected{% endif %}>≥ -99 dB</option>
                        <option value="-40" {% if min_snr == -40 %}selected{% endif %}>≥ -40 dB</option>
                        <option value="-30" {% if min_snr == -30 %}selected{% endif %}>≥ -30 dB</option>
                        <option value="-20" {% if min_snr == -20 %}selected{% endif %}>≥ -20 dB</option>
                        <option value="-10" {% if min_snr == -10 %}selected{% endif %}>≥ -10 dB</option>
                        <option value="0" {% if min_snr == 0 %}selected{% endif %}>≥ 0 dB</option>
                    </select>
                </div>
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="include_indirect" name="include_indirect" {% if include_indirect %}checked{% endif %}>
                        <label class="form-check-label" for="include_indirect">
                            Multi-hop Connections
                        </label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="primary_channel" class="form-label">Primary Channel</label>
                    <select class="form-select form-select-sm" id="primary_channel" name="primary_channel">
                        <option value="">All Channels</option>
                        <!-- Options will be loaded dynamically -->
                    </select>
                </div>
                <button type="submit" class="btn btn-primary btn-sm w-100">
                    <i class="bi bi-arrow-clockwise"></i> Update Graph
                </button>
            </form>
        </div>

        <!-- Graph Stats -->
        <div class="sidebar-section">
            <h6><i class="bi bi-bar-chart"></i> Statistics</h6>
            <div id="graphStats" class="stats-content">
                <div><strong>Nodes:</strong> <span id="statsNodes">0</span></div>
                <div><strong>Links:</strong> <span id="statsLinks">0</span></div>
                <div><strong>Time Period:</strong> <span id="statsTimePeriod">24h</span></div>
                <div><strong>Last Update:</strong> <span id="statsLastUpdate">--</span></div>
            </div>
        </div>

        {% set legend_items = [
            {"type": "icon", "class": "bi bi-circle-fill text-primary", "text": "Active nodes"},
            {"type": "line", "class": "direct", "text": "Direct RF links"},
            {"type": "line", "class": "indirect", "text": "Multi-hop paths"}
        ] %}
        {% call legend_section(legend_items) %}
            <div class="legend-item mt-2">
                <small class="text-muted">Node size = traffic volume<br>
                Link thickness = signal strength<br>
                Colors = SNR quality</small>
            </div>
        {% endcall %}
    {% endcall %}
</div>

<!-- Hide the footer for this page -->
<style>
.footer {
    display: none !important;
}

.graph-container {
    position: fixed;
    top: 56px; /* Height of navbar */
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    background: var(--bs-body-bg);
    z-index: 1;
}

.graph-main {
    flex: 1;
    position: relative;
    overflow: hidden;
    order: 1;
}

.network-graph {
    width: 100%;
    height: 100%;
}

.loading-overlay, .error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(248, 249, 250, 0.9);
    z-index: 100;
}

.error-overlay {
    color: #dc3545;
}

/* Node labels styling */
.node-label {
    font-size: 12px;
    font-weight: bold;
    fill: #333;
    text-anchor: middle;
    pointer-events: none;
    text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
}

.node-label-subtitle {
    font-size: 10px;
    fill: #666;
    text-anchor: middle;
    pointer-events: none;
    text-shadow: 1px 1px 1px rgba(255,255,255,0.8);
    font-style: italic;
}

.node-label.highlighted {
    font-size: 14px;
    fill: #007bff;
    font-weight: 900;
}

.node.selected circle {
    stroke: #007bff;
    stroke-width: 4;
}

.node.comparison circle {
    stroke: #28a745;
    stroke-width: 4;
}

.link.selected {
    stroke: #007bff !important;
    stroke-width: 4 !important;
}

/* Link Activity Highlighting */
.link.active-recent {
    stroke: #ffc107 !important;
    stroke-width: 3 !important;
    filter: drop-shadow(0 0 4px rgba(255, 193, 7, 0.6));
}

.indirect-links line.active-recent {
    stroke: #ff9800 !important;
    stroke-width: 2.5 !important;
    filter: drop-shadow(0 0 3px rgba(255, 152, 0, 0.5));
}

@keyframes linkFade {
    0% {
        stroke-width: 3;
        filter: drop-shadow(0 0 6px rgba(255, 193, 7, 0.8));
    }
    100% {
        stroke-width: 1;
        filter: drop-shadow(0 0 0px rgba(255, 193, 7, 0));
    }
}

.link.link-fading {
    animation: linkFade linear forwards;
}

.indirect-links line.link-fading {
    animation: linkFade linear forwards;
}

/* Activity Feed Styling */
.activity-feed {
    max-height: 250px;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 0.25rem;
    padding: 0.5rem;
    background-color: rgba(0, 0, 0, 0.02);
}

.activity-item {
    padding: 0.5rem;
    border-left: 3px solid #0dcaf0;
    background: rgba(13, 202, 240, 0.05);
    border-radius: 0.25rem;
    margin-bottom: 0.5rem;
    font-size: 0.85rem;
    animation: slideIn 0.3s ease-out;
}

.activity-item.recent {
    border-left-color: #0dcaf0;
    background: rgba(13, 202, 240, 0.1);
    font-weight: 500;
}

.activity-item-time {
    font-size: 0.75rem;
    color: #6c757d;
    display: block;
}

.activity-item-node {
    font-weight: 600;
    color: #495057;
}

.activity-item-detail {
    color: #6c757d;
    font-size: 0.8rem;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Node Activity Badges */
.node-activity-badge {
    font-size: 9px;
    background: #0dcaf0;
    color: white;
    padding: 1px 3px;
    border-radius: 50%;
    font-weight: bold;
    pointer-events: none;
}

/* Live indicator pulse */
@keyframes livePulse {
    0% {
        opacity: 1;
    }
    50% {
        opacity: 0.6;
    }
    100% {
        opacity: 1;
    }
}

.live-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    background: #28a745;
    border-radius: 50%;
    animation: livePulse 1.5s infinite;
}

/* Packet activity animations */
@keyframes node-pulse {
    0% {
        stroke: #00ff00;
        stroke-width: 6;
        filter: drop-shadow(0 0 8px #00ff00);
    }
    50% {
        stroke: #00ff00;
        stroke-width: 8;
        filter: drop-shadow(0 0 16px #00ff00);
    }
    100% {
        stroke: #fff;
        stroke-width: 2;
        filter: none;
    }
}

.node.active circle {
    animation: node-pulse 1s ease-out;
}

/* Additional mobile adjustments specific to graph */
@media (max-width: 768px) {
    .graph-container {
        flex-direction: column;
        top: 56px;
    }

    .graph-main {
        order: 1;
        flex: 1;
    }
}
</style>

{{ sidebar_styles() }}

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
let currentGraph = null;
let simulation = null;
let selectedNode = null;
let selectedLink = null;
let searchResults = [];
let hopFilterEnabled = true;
let maxHopDistance = 3;
let visibleNodeIds = null;
let nodeDistances = null;
let comparisonNode = null; // Second node for path comparison
let pathComparisonMode = false;
let activityPollInterval = null;
let lastActivityTimestamp = Math.floor(Date.now() / 1000);
let autoRefreshInterval = null;
let autoRefreshEnabled = true;
let autoRefreshIntervalSeconds = 30;
let refreshCountdownInterval = null;
let nextRefreshCountdown = 30;
let recentActivities = []; // Track recent activity
let maxActivityItems = 20; // Max items in activity feed
let recentNodeTimestamps = {}; // Track real-time node timestamps from activity polling
let enableLinkHighlight = true; // Toggle for link highlighting
let linkDecayTimeSeconds = 15; // How long links remain highlighted (seconds)
let recentLinkActivity = {}; // Map of linkKey -> timestamp of last activity
let nodeActivityCount = {}; // Track packet count per node for activity heatmap

// Make currentGraph globally accessible for debugging
window.currentGraph = null;

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    // Wait for jQuery to be available
    function waitForJQuery() {
        if (typeof $ !== 'undefined') {
            initializeInterface();
            loadGraph();
        } else {
            setTimeout(waitForJQuery, 50);
        }
    }

    waitForJQuery();
});

function initializeInterface() {
    // Handle filter form submission
    $('#filterForm').on('submit', function(e) {
        e.preventDefault();
        loadGraph();
    });

    // Start real-time activity polling
    startActivityPolling();

    // Set up auto-refresh controls
    setupAutoRefresh();

    // Handle auto-refresh toggle
    $('#toggleSidebar').on('click', function() {
        const sidebar = document.getElementById('sidebar');
        const icon = this.querySelector('i');
        const isMobile = window.innerWidth <= 768;

        sidebar.classList.toggle('collapsed');

        if (sidebar.classList.contains('collapsed')) {
            if (isMobile) {
                icon.className = 'bi bi-chevron-up';
            } else {
                icon.className = 'bi bi-chevron-left';
            }
        } else {
            if (isMobile) {
                icon.className = 'bi bi-chevron-down';
            } else {
                icon.className = 'bi bi-chevron-right';
            }
        }

        // Trigger resize after animation
        setTimeout(() => {
            if (simulation) {
                const container = document.getElementById('networkGraph');
                const containerRect = container.getBoundingClientRect();
                const width = containerRect.width;
                const height = containerRect.height;

                // Update SVG dimensions
                d3.select('#networkGraph svg')
                    .attr('width', width)
                    .attr('height', height);

                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();

                // Update stored dimensions
                window.graphWidth = width;
                window.graphHeight = height;
            }
        }, 300);
    });

    // Handle window resize to update toggle button icon
    $(window).on('resize', function() {
        const sidebar = document.getElementById('sidebar');
        const icon = document.querySelector('#toggleSidebar i');
        const isMobile = window.innerWidth <= 768;

        if (sidebar && icon) {
            if (sidebar.classList.contains('collapsed')) {
                icon.className = isMobile ? 'bi bi-chevron-up' : 'bi bi-chevron-left';
            } else {
                icon.className = isMobile ? 'bi bi-chevron-down' : 'bi bi-chevron-right';
            }
        }
    });

    // Handle clear selection button
    $('#clearSelection').on('click', function() {
        clearSelection();
    });

    // Handle auto-refresh toggle
    $('#autoRefreshToggle').on('change', function() {
        autoRefreshEnabled = this.checked;
        if (autoRefreshEnabled) {
            startAutoRefresh();
            document.getElementById('autoRefreshTimer').style.display = 'block';
        } else {
            stopAutoRefresh();
            document.getElementById('autoRefreshTimer').style.display = 'none';
        }
    });

    // Handle auto-refresh interval change
    $('#autoRefreshInterval').on('change', function() {
        autoRefreshIntervalSeconds = parseInt(this.value);
        updateAutoRefreshStatus();

        if (autoRefreshEnabled) {
            stopAutoRefresh();
            startAutoRefresh();
        }
    });

    // Handle activity feed clear button
    $('#clearActivityFeed').on('click', function() {
        recentActivities = [];
        displayActivityFeed();
    });

    // Handle link highlight toggle
    $('#enableLinkHighlight').on('change', function() {
        enableLinkHighlight = this.checked;
        if (!enableLinkHighlight) {
            // Clear all link highlights
            d3.selectAll('.link').classed('active-recent', false).classed('link-fading', false);
            d3.selectAll('.indirect-links line').classed('active-recent', false).classed('link-fading', false);
            recentLinkActivity = {};
        }
    });

    // Handle link decay time slider
    $('#linkDecayTime').on('input', function() {
        linkDecayTimeSeconds = parseInt(this.value);
        $('#linkDecayTimeValue').text(linkDecayTimeSeconds + 's');
    });

    // Handle hop filter controls
    $('#hopDistance').on('input', function() {
        maxHopDistance = parseInt(this.value);
        $('#hopDistanceValue').text(maxHopDistance);
        if (selectedNode && hopFilterEnabled) {
            applyHopFilter();
        }
    });

    $('#enableHopFilter').on('change', function() {
        hopFilterEnabled = this.checked;
        if (selectedNode) {
            applyHopFilter();
        }
    });

    // Handle node search
    $('#nodeSearch').on('input', function() {
        const query = this.value.toLowerCase().trim();
        if (query.length > 0) {
            searchNodes(query);
        } else {
            clearSearchResults();
        }
    });

    $('#clearSearch').on('click', function() {
        $('#nodeSearch').val('');
        clearSearchResults();
        clearSelection();
    });

    // Load primary channels into filter select
    loadPrimaryChannels();
}

function loadGraph() {
    showLoading();

    // Get filter parameters
    const params = new URLSearchParams();
    document.querySelectorAll('#filterForm input, #filterForm select').forEach(function(element) {
        const value = element.value;
        if (value && element.type !== 'checkbox') {
            params.append(element.name, value);
        } else if (element.type === 'checkbox' && element.checked) {
            params.append(element.name, 'true');
        }
    });

    fetch(`/api/traceroute/graph?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                showError(data.error);
                return;
            }

            currentGraph = data;
            window.currentGraph = data; // Also set global reference

            // Ensure container is ready before rendering
            const container = document.getElementById('networkGraph');
            if (container) {
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width === 0 || containerRect.height === 0) {
                    setTimeout(() => {
                        renderGraph(data);
                        updateStats(data.stats);
                        hideLoading();
                    }, 100);
                } else {
                    renderGraph(data);
                    updateStats(data.stats);
                    hideLoading();
                }
            } else {
                renderGraph(data);
                updateStats(data.stats);
                hideLoading();
            }
        })
        .catch(error => {
            console.error('Error loading graph:', error);
            showError('Failed to load graph data');
        });
}

function renderGraph(data) {
    try {
        console.log('renderGraph called with data:', data);

        const container = d3.select('#networkGraph');
        container.selectAll('*').remove(); // Clear previous graph

        if (!data.nodes || data.nodes.length === 0) {
            console.log('No nodes found in data');
            container.append('div')
                .attr('class', 'loading-overlay')
                .html('<i class="bi bi-diagram-3"></i><br>No network data found for the selected criteria');
            return;
        }

        console.log('Found', data.nodes.length, 'nodes and', data.links ? data.links.length : 0, 'links');

        // Ensure container has proper dimensions
        const containerRect = container.node().getBoundingClientRect();
        let width = containerRect.width;
        let height = containerRect.height;

        // If dimensions are 0, wait a bit and try again
        if (width === 0 || height === 0) {
            // Force a layout recalculation
            container.node().offsetHeight; // Trigger reflow

            // Try again after a brief moment
            setTimeout(() => {
                const newRect = container.node().getBoundingClientRect();
                width = newRect.width;
                height = newRect.height;

                // If still 0, use reasonable defaults based on viewport
                if (width === 0 || height === 0) {
                    width = Math.max(800, window.innerWidth - 400);  // Leave space for sidebar
                    height = Math.max(600, window.innerHeight - 200); // Leave space for navbar/footer
                }

                // Update the SVG dimensions if they were created with fallback values
                if (window.graphSvg) {
                    window.graphSvg
                        .attr('width', width)
                        .attr('height', height);

                    // Update stored dimensions
                    window.graphWidth = width;
                    window.graphHeight = height;

                    // Update simulation center
                    if (simulation) {
                        simulation.force('center', d3.forceCenter(width / 2, height / 2));
                        simulation.alpha(0.3).restart();
                    }
                }
            }, 50);
        }

        // Use current dimensions (might be 0 initially, but will be corrected above)
        if (width === 0 || height === 0) {
            width = Math.max(800, window.innerWidth - 400);  // Leave space for sidebar
            height = Math.max(600, window.innerHeight - 200); // Leave space for navbar/footer
        }

        console.log('Graph container dimensions:', {width, height});

        // Create SVG first
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('width', '100%')
            .style('height', '100%');

        // Create the g element
        const g = svg.append('g');

        // Now create zoom behavior that can reference g
        const zoom = d3.zoom()
            .scaleExtent([0.05, 10])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        // Apply zoom behavior to SVG
        svg.call(zoom);

        // Initialize with identity transform to avoid NaN values
        svg.call(zoom.transform, d3.zoomIdentity);

        // Color scales
        const snrColorScale = d3.scaleSequential(d3.interpolateRdYlGn)
            .domain([-30, 10]); // SNR range

                // Set up geographical positioning if location data is available
        const nodesWithLocation = data.nodes.filter(n => n.location);
        const nodesWithoutLocation = data.nodes.filter(n => !n.location);

        console.log(`Nodes with location: ${nodesWithLocation.length}, without: ${nodesWithoutLocation.length}`);

        // Scales for geo positioning (initialized if we have location data)
        let xScale = null;
        let yScale = null;

                if (nodesWithLocation.length > 0) {
            // Calculate geographical bounds using 80th percentile to focus on main cluster
            const latitudes = nodesWithLocation.map(n => n.location.latitude).sort((a, b) => a - b);
            const longitudes = nodesWithLocation.map(n => n.location.longitude).sort((a, b) => a - b);

            // Use 10th to 90th percentile to exclude outliers and focus on main cluster
            const percentile10 = Math.floor(latitudes.length * 0.1);
            const percentile90 = Math.floor(latitudes.length * 0.9);

            const minLat = latitudes[percentile10];
            const maxLat = latitudes[percentile90];
            const minLng = longitudes[percentile10];
            const maxLng = longitudes[percentile90];

            console.log(`Using 10th-90th percentile bounds: lat ${minLat} to ${maxLat}, lng ${minLng} to ${maxLng}`);
            console.log(`Total nodes: ${nodesWithLocation.length}, excluded outliers: ${percentile10 * 2}`);

            // Calculate the geographical span
            const latSpan = maxLat - minLat;
            const lngSpan = maxLng - minLng;

            // Add padding based on the geographical span to give more breathing room
            const latPadding = Math.max(latSpan * 0.3, 0.005); // 30% padding or 0.005 degrees minimum
            const lngPadding = Math.max(lngSpan * 0.3, 0.005);

            // Expand the domain to include padding
            const paddedMinLat = minLat - latPadding;
            const paddedMaxLat = maxLat + latPadding;
            const paddedMinLng = minLng - lngPadding;
            const paddedMaxLng = maxLng + lngPadding;

            // Create scales to map lat/lng to screen coordinates with better spacing
            const screenPadding = Math.min(width, height) * 0.05; // Smaller screen padding
            xScale = d3.scaleLinear()
                .domain([paddedMinLng, paddedMaxLng])
                .range([screenPadding, width - screenPadding]);
            yScale = d3.scaleLinear()
                .domain([paddedMaxLat, paddedMinLat]) // Flip Y axis (north = up)
                .range([screenPadding, height - screenPadding]);

            // Set initial positions based on geographical coordinates
            nodesWithLocation.forEach(node => {
                const lat = node.location.latitude;
                const lng = node.location.longitude;

                // Clamp outlier coordinates to the focused bounds to keep them visible
                const clampedLat = Math.max(paddedMinLat, Math.min(paddedMaxLat, lat));
                const clampedLng = Math.max(paddedMinLng, Math.min(paddedMaxLng, lng));

                node.x = xScale(clampedLng);
                node.y = yScale(clampedLat);

                // Fix positions initially to prevent random movement
                node.fx = node.x;
                node.fy = node.y;

                // Log if this node was clamped (outlier)
                if (lat !== clampedLat || lng !== clampedLng) {
                    console.log(`Clamped outlier node ${node.name}: (${lat}, ${lng}) -> (${clampedLat}, ${clampedLng})`);
                }
            });

            // For nodes without location, don't fix their positions - let them be positioned
            // by the force simulation based on their connections to nodes with locations
            nodesWithoutLocation.forEach(node => {
                // Start them near the center but don't fix them
                node.x = width / 2 + (Math.random() - 0.5) * 100;
                node.y = height / 2 + (Math.random() - 0.5) * 100;
                // Don't set fx/fy - let the simulation position them
            });

            console.log('Set geographical positions for nodes with location data');
        }

        // Create force simulation
        simulation = d3.forceSimulation(data.nodes)
            .force('link', d3.forceLink(data.links).id(d => d.id).distance(d => Math.max(140, 360 - d.strength * 20)))
            .force('charge', d3.forceManyBody().strength(-650))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => d.size + 50));

        // If we have geographical positioning, adjust forces and release fixed positions
        if (nodesWithLocation.length > 0) {
            // Adjust forces for geographical layout
            simulation
                .force('charge', d3.forceManyBody().strength(-350)) // Stronger repulsion for more spacing
                .force('center', null) // Remove centering force
                .force('link', d3.forceLink(data.links).id(d => d.id)
                    .distance(d => Math.max(180, 420 - d.strength * 40)) // Longer links for more spacing
                    .strength(0.6)) // Slightly softer links
                // Gentle pull back towards geographic positions to preserve rough layout
                .force('geoX', d3.forceX(d => d.location ? xScale(d.location.longitude) : width / 2).strength(d => d.location ? 0.12 : 0.05))
                .force('geoY', d3.forceY(d => d.location ? yScale(d.location.latitude) : height / 2).strength(d => d.location ? 0.12 : 0.05));

            // Release fixed positions for nodes with location after initial layout
            // This allows small adjustments while maintaining geographical structure
            setTimeout(() => {
                nodesWithLocation.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });
                // Restart with lower alpha for gentle adjustment
                simulation.alpha(0.2).restart();
            }, 1500);
        }

        console.log('Created simulation with', data.nodes.length, 'nodes');

        // Create links
        const link = g.append('g')
            .attr('class', 'links')
            .selectAll('line')
            .data(data.links)
            .join('line')
            .attr('class', 'link')
            .attr('stroke', d => snrColorScale(d.avg_snr))
            .attr('stroke-width', d => Math.max(1, d.strength))
            .attr('stroke-opacity', 0.8)
            .attr('data-original-stroke', d => snrColorScale(d.avg_snr))
            .attr('data-original-width', d => Math.max(1, d.strength))
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                showLinkHoverDetails(d);
            })
            .on('mouseout', function() {
                clearHoverDetails();
            })
            .on('click', function(event, d) {
                event.stopPropagation();
                if (selectedLink === d) {
                    clearSelection();
                } else {
                    selectLink(d);
                }
            });

        console.log('Created', data.links.length, 'links');

        // Add indirect connections if present
        if (data.indirect_connections && data.indirect_connections.length > 0) {
            const indirectLink = g.append('g')
                .attr('class', 'indirect-links')
                .selectAll('line')
                .data(data.indirect_connections)
                .join('line')
                .attr('class', 'link indirect')
                .attr('stroke', '#6c757d')
                .attr('stroke-width', d => Math.max(1, d.strength))
                .attr('stroke-opacity', 0.4)
                .attr('stroke-dasharray', '5,5')
                .attr('data-original-width', d => Math.max(1, d.strength))
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    showLinkHoverDetails(d);
                })
                .on('mouseout', function() {
                    clearHoverDetails();
                })
                .on('click', function(event, d) {
                    event.stopPropagation();
                    if (selectedLink === d) {
                        clearSelection();
                    } else {
                        selectLink(d);
                    }
                });

            console.log('Created', data.indirect_connections.length, 'indirect connections');
        }

        // Create nodes
        const node = g.append('g')
            .attr('class', 'nodes')
            .selectAll('g')
            .data(data.nodes)
            .join('g')
            .attr('class', 'node')
            .style('cursor', 'pointer')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))
            .on('mouseover', function(event, d) {
                showNodeHoverDetails(d);
                // Only show hover paths if we're not in comparison mode
                if (selectedNode && hopFilterEnabled && !pathComparisonMode && d.id !== selectedNode.id) {
                    highlightPathToNode(d);
                }
            })
            .on('mouseout', function() {
                clearHoverDetails();
                // Only clear hover paths if we're not in comparison mode
                if (selectedNode && hopFilterEnabled && !pathComparisonMode) {
                    clearPathHighlight();
                }
            })
            .on('click', function(event, d) {
                event.stopPropagation();
                handleNodeClick(d, event);
            });

        console.log('Created node groups');

        // Add activity halo circles for each node (for heatmap visualization)
        node.append('circle')
            .attr('class', 'node-halo')
            .attr('r', d => d.size + 2)
            .attr('fill', 'none')
            .attr('stroke', '#ff6b35')
            .attr('stroke-width', 0)
            .attr('stroke-opacity', 0)
            .attr('data-base-radius', d => d.size + 2);

        console.log('Added activity halos to nodes');

        // Add circles for nodes
        node.append('circle')
            .attr('r', d => d.size)
            .attr('fill', d => d.avg_snr ? snrColorScale(d.avg_snr) : '#6c757d')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);

        console.log('Added circles to nodes');

        // Create a group for each node's text labels
        node.append('g')
            .attr('class', 'node-labels')
            .each(function(d) {
                const labelGroup = d3.select(this);

                // Add main label (node name)
                labelGroup.append('text')
                    .attr('class', 'node-label')
                    .text(d.name)
                    .attr('dy', d => d.size + 15)
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('text-anchor', 'middle')
                    .style('pointer-events', 'none');

                // Add "last heard" subtitle
                const lastHeardTime = new Date(d.last_seen * 1000);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastHeardTime) / 60000);

                let lastHeardText = '';
                if (diffMinutes < 1) {
                    lastHeardText = 'now';
                } else if (diffMinutes < 60) {
                    lastHeardText = `${diffMinutes}m ago`;
                } else if (diffMinutes < 1440) {
                    const hours = Math.floor(diffMinutes / 60);
                    lastHeardText = `${hours}h ago`;
                } else {
                    const days = Math.floor(diffMinutes / 1440);
                    lastHeardText = `${days}d ago`;
                }

                labelGroup.append('text')
                    .attr('class', 'node-label-subtitle')
                    .text(`(${lastHeardText})`)
                    .attr('dy', d => d.size + 28)
                    .style('font-size', '10px')
                    .style('fill', '#666')
                    .style('text-anchor', 'middle')
                    .style('pointer-events', 'none');
            });

        console.log('Added labels to nodes');

        // Add click handler to SVG background to clear selection
        svg.on('click', function(event) {
            if (event.target === this) {
                clearSelection();
            }
        });

        // Update positions on simulation tick
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            if (data.indirect_connections && data.indirect_connections.length > 0) {
                d3.selectAll('.indirect-links line')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
            }

            node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        console.log('Set up simulation event handlers');

        // Store references for utility functions
        window.graphSvg = svg;
        window.graphG = g;
        window.graphZoom = zoom;
        window.graphWidth = width;
        window.graphHeight = height;
        window.graphNodes = node;
        window.graphLinks = link;

        console.log('renderGraph completed successfully. Stored references:', {
            graphSvg: !!window.graphSvg,
            graphG: !!window.graphG,
            graphZoom: !!window.graphZoom,
            simulation: !!simulation,
            width: window.graphWidth,
            height: window.graphHeight
        });

    } catch (error) {
        console.error('Error in renderGraph:', error);
        console.error('Error stack:', error.stack);
        showError('Failed to render graph: ' + error.message);
    }
}

function searchNodes(query) {
    if (!currentGraph || !currentGraph.nodes) {
        return;
    }

    const results = currentGraph.nodes.filter(node => {
        const nodeIdHex = node.id.toString(16).padStart(8, '0');
        return node.name.toLowerCase().includes(query) ||
               nodeIdHex.includes(query) ||
               node.id.toString().includes(query);
    }).slice(0, 10); // Limit to 10 results

    searchResults = results;
    displaySearchResults(results);
}

function displaySearchResults(results) {
    const container = document.getElementById('searchResults');

    if (results.length === 0) {
        container.innerHTML = '<small class="text-muted">No nodes found</small>';
        return;
    }

    container.innerHTML = results.map((node, index) => {
        const nodeIdHex = node.id.toString(16).padStart(8, '0');
        return `
            <div class="search-result-item" onclick="selectSearchResult(${index})">
                <div><strong>${node.name}</strong></div>
                <small class="text-muted">!${nodeIdHex} • ${node.connections} connections</small>
            </div>
        `;
    }).join('');
}

function selectSearchResult(index) {
    const node = searchResults[index];
    if (!node) return;

    // Highlight the selected result
    document.querySelectorAll('.search-result-item').forEach((item, i) => {
        item.classList.toggle('selected', i === index);
    });

    // Focus on the node in the graph and select it
    focusOnNode(node);
    selectNode(node);
}

function focusOnNode(targetNode) {
    console.log('focusOnNode called with:', targetNode);

    if (!window.graphSvg || !window.graphZoom || !simulation) {
        console.log('Missing dependencies:', {
            graphSvg: !!window.graphSvg,
            graphZoom: !!window.graphZoom,
            simulation: !!simulation
        });
        return;
    }

    // Find the node in the simulation
    const simNode = simulation.nodes().find(n => n.id === targetNode.id);
    if (!simNode) {
        console.log('Node not found in simulation:', targetNode.id);
        console.log('Available nodes:', simulation.nodes().map(n => ({id: n.id, name: n.name})));
        return;
    }

    console.log('Found simulation node:', simNode);

    // Ensure simulation has stable positions
    if (simulation.alpha() > 0.1) {
        console.log('Stabilizing simulation...');
        // Let the simulation run for a bit to get stable positions
        for (let i = 0; i < 100; ++i) simulation.tick();
    }

    console.log('Node position:', {x: simNode.x, y: simNode.y});
    console.log('Graph dimensions:', {width: window.graphWidth, height: window.graphHeight});

    // Ensure we have valid graph dimensions
    let graphWidth = window.graphWidth;
    let graphHeight = window.graphHeight;

    if (!graphWidth || !graphHeight || graphWidth === 0 || graphHeight === 0) {
        // Recalculate dimensions from the container
        const container = document.getElementById('networkGraph');
        if (container) {
            const containerRect = container.getBoundingClientRect();
            graphWidth = containerRect.width;
            graphHeight = containerRect.height;

            // Update stored dimensions
            window.graphWidth = graphWidth;
            window.graphHeight = graphHeight;

            console.log('Recalculated graph dimensions:', {width: graphWidth, height: graphHeight});
        }
    }

    // Ensure we have valid dimensions before proceeding
    if (!graphWidth || !graphHeight || graphWidth === 0 || graphHeight === 0) {
        console.log('Cannot focus on node: invalid graph dimensions');
        return;
    }

    // Calculate zoom and pan to center on the node
    const scale = 3.0;
    const translateX = graphWidth / 2 - scale * simNode.x;
    const translateY = graphHeight / 2 - scale * simNode.y;
    const translate = [translateX, translateY];

    console.log('Calculated transform:', {
        scale,
        translate,
        translateX,
        translateY,
        graphWidth,
        graphHeight,
        nodeX: simNode.x,
        nodeY: simNode.y
    });

    // Apply the transform using the stored zoom behavior
    const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);

    console.log('Applying transform:', transform);
    console.log('Transform toString:', transform.toString());

    // Use the zoom behavior's transform method properly
    window.graphSvg.transition().duration(750)
        .call(window.graphZoom.transform, transform);
}

function handleNodeClick(node, event) {
    if (!selectedNode) {
        // First selection
        selectNode(node);
    } else if (selectedNode.id === node.id) {
        // Clicking the same node - deselect
        clearSelection();
    } else if (comparisonNode && comparisonNode.id === node.id) {
        // Clicking the comparison node - remove it
        clearComparisonNode();
    } else if (!comparisonNode) {
        // Second selection - enter path comparison mode
        selectComparisonNode(node);
    } else {
        // Already have two nodes selected, replace comparison node
        selectComparisonNode(node);
    }
}

function selectNode(node) {
    // Don't clear if we're adding a comparison node
    if (!comparisonNode) {
        clearSelection();
    }

    selectedNode = node;
    selectedLink = null;
    pathComparisonMode = false;

    // Highlight the node visually
    d3.selectAll('.node')
        .filter(d => d.id === node.id)
        .classed('selected', true)
        .select('circle')
        .attr('stroke', '#007bff')
        .attr('stroke-width', 4);

    // Show detailed information
    showSelectedNodeDetails(node);

    // Show hop filter controls
    document.getElementById('hopFilterSection').style.display = 'block';

    // Apply hop filter if enabled
    if (hopFilterEnabled) {
        applyHopFilter();
    }
}

function selectComparisonNode(node) {
    comparisonNode = node;
    pathComparisonMode = true;

    // Highlight both nodes with different colors
    d3.selectAll('.node').each(function(d) {
        const isSelected = d.id === selectedNode.id;
        const isComparison = d.id === comparisonNode.id;

        if (isSelected) {
            d3.select(this)
                .classed('selected', true)
                .select('circle')
                .attr('stroke', '#007bff')
                .attr('stroke-width', 4);
        } else if (isComparison) {
            d3.select(this)
                .classed('comparison', true)
                .select('circle')
                .attr('stroke', '#28a745')
                .attr('stroke-width', 4);
        }
    });

    // Hide hop filter controls in comparison mode
    document.getElementById('hopFilterSection').style.display = 'none';

    // Show path comparison details
    showPathComparisonDetails();

    // Highlight paths between the two nodes
    highlightPathsBetweenNodes();
}

function clearComparisonNode() {
    if (!comparisonNode) return;

    // Remove comparison node highlighting
    d3.selectAll('.node')
        .filter(d => d.id === comparisonNode.id)
        .classed('comparison', false)
        .select('circle')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2);

    comparisonNode = null;
    pathComparisonMode = false;

    // Restore hop filter controls if node is still selected
    if (selectedNode) {
        document.getElementById('hopFilterSection').style.display = 'block';
        showSelectedNodeDetails(selectedNode);

        // Reapply hop filter
        if (hopFilterEnabled) {
            applyHopFilter();
        } else {
            // Reset visibility
            d3.selectAll('.node').style('opacity', 1);
            d3.selectAll('.link').style('opacity', 0.8);
            d3.selectAll('.indirect-links line').style('opacity', 0.4);
        }
    }
}

function selectLink(link) {
    clearSelection();

    selectedLink = link;
    selectedNode = null;

    // Highlight the link visually
    d3.selectAll('.link')
        .filter(d => d === link)
        .classed('selected', true);

    // Show detailed information
    showSelectedLinkDetails(link);
}

function clearSelection() {
    selectedNode = null;
    selectedLink = null;
    comparisonNode = null;
    pathComparisonMode = false;

    // Clear visual highlights
    d3.selectAll('.node')
        .classed('selected', false)
        .classed('comparison', false)
        .select('circle')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2);

    d3.selectAll('.link').classed('selected', false);
    d3.selectAll('.node-label').classed('highlighted', false);

    // Clear search result highlights
    document.querySelectorAll('.search-result-item').forEach(item => {
        item.classList.remove('selected');
    });

    // Hide selected details
    document.getElementById('selectedDetails').style.display = 'none';

    // Hide hop filter controls
    document.getElementById('hopFilterSection').style.display = 'none';

    // Reset visibility of all nodes and links
    d3.selectAll('.node').style('opacity', 1);

    // Reset links to original colors
    d3.selectAll('.link').each(function(d) {
        d3.select(this)
            .style('opacity', 0.8)
            .attr('stroke', d3.select(this).attr('data-original-stroke'))
            .attr('stroke-width', d3.select(this).attr('data-original-width'));
    });

    d3.selectAll('.indirect-links line').each(function(d) {
        d3.select(this)
            .style('opacity', 0.4)
            .attr('stroke', '#6c757d')
            .attr('stroke-width', d3.select(this).attr('data-original-width'));
    });

    // Clear hop filter state
    visibleNodeIds = null;
    nodeDistances = null;
}

function clearSearchResults() {
    document.getElementById('searchResults').innerHTML = '';
    searchResults = [];
}

function showSelectedNodeDetails(node) {
    const nodeIdHex = node.id.toString(16).padStart(8, '0');
    const content = `
        <div class="row">
            <div class="col-12">
                <h6>${node.name}</h6>
                <p class="text-muted">Node ID: !${nodeIdHex}</p>
                <div class="alert alert-info py-2 px-2 small mb-2">
                    <i class="bi bi-lightbulb"></i> Click another node to show paths between them
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-6">
                <strong>Connections:</strong><br>
                <span class="h5 text-primary">${node.connections}</span>
            </div>
            <div class="col-6">
                <strong>Packets:</strong><br>
                <span class="h5 text-info">${node.packet_count}</span>
            </div>
        </div>
        <div class="row mt-2">
            <div class="col-6">
                <strong>Avg SNR:</strong><br>
                <span class="h6 ${node.avg_snr ? (node.avg_snr > -10 ? 'text-success' : 'text-warning') : 'text-muted'}">${node.avg_snr ? node.avg_snr + ' dB' : 'N/A'}</span>
            </div>
            <div class="col-6">
                <strong>Last Seen:</strong><br>
                <small class="text-muted">${typeof formatTimestamp === 'function' ? formatTimestamp(node.last_seen) : new Date(node.last_seen * 1000).toLocaleString()}</small>
            </div>
        </div>
        <div class="row mt-2">
            <div class="col-12">
                <a href="/node/${node.id}" class="btn btn-primary btn-sm w-100">
                    <i class="bi bi-router"></i> View Node Details
                </a>
            </div>
        </div>
    `;

    document.getElementById('selectedDetailsTitle').textContent = 'Selected Node';
    document.getElementById('selectedDetailsContent').innerHTML = content;
    document.getElementById('selectedDetails').style.display = 'block';
}

function showPathComparisonDetails() {
    if (!selectedNode || !comparisonNode) return;

    // Calculate paths between the two nodes
    const pathsData = calculatePathsBetweenNodes(selectedNode.id, comparisonNode.id);

    const node1IdHex = selectedNode.id.toString(16).padStart(8, '0');
    const node2IdHex = comparisonNode.id.toString(16).padStart(8, '0');

    let pathsHtml = '';
    if (pathsData.paths.length === 0) {
        pathsHtml = '<div class="alert alert-warning py-2 px-2 small">No path found between these nodes</div>';
    } else {
        pathsHtml = `
            <div class="mb-2">
                <strong>${pathsData.paths.length} path${pathsData.paths.length > 1 ? 's' : ''} found</strong>
                <small class="text-muted"> (${pathsData.distance} hop${pathsData.distance > 1 ? 's' : ''})</small>
            </div>
            <div class="small" style="max-height: 200px; overflow-y: auto;">
        `;

        pathsData.paths.forEach((path, idx) => {
            const pathNames = path.map(nodeId => getNodeNameById(nodeId)).join(' → ');
            pathsHtml += `<div class="mb-2 p-2 bg-light rounded"><strong>${idx + 1}.</strong> ${pathNames}</div>`;
        });

        pathsHtml += '</div>';
    }

    const content = `
        <div class="mb-3">
            <div class="d-flex align-items-center mb-2">
                <span class="badge bg-primary me-2">1</span>
                <div>
                    <strong>${selectedNode.name}</strong><br>
                    <small class="text-muted">!${node1IdHex}</small>
                </div>
            </div>
            <div class="d-flex align-items-center">
                <span class="badge bg-success me-2">2</span>
                <div>
                    <strong>${comparisonNode.name}</strong><br>
                    <small class="text-muted">!${node2IdHex}</small>
                </div>
            </div>
        </div>

        ${pathsHtml}

        <div class="alert alert-info py-2 px-2 small mt-2 mb-2">
            <i class="bi bi-lightbulb"></i> Click a node again to deselect it, or click elsewhere to select different nodes
        </div>

        <div class="row mt-2">
            <div class="col-6">
                <a href="/node/${selectedNode.id}" class="btn btn-outline-primary btn-sm w-100" target="_blank">
                    <i class="bi bi-router"></i> Node 1
                </a>
            </div>
            <div class="col-6">
                <a href="/node/${comparisonNode.id}" class="btn btn-outline-success btn-sm w-100" target="_blank">
                    <i class="bi bi-router"></i> Node 2
                </a>
            </div>
        </div>
    `;

    document.getElementById('selectedDetailsTitle').textContent = 'Path Comparison';
    document.getElementById('selectedDetailsContent').innerHTML = content;
    document.getElementById('selectedDetails').style.display = 'block';
}

function calculatePathsBetweenNodes(startNodeId, endNodeId) {
    if (!currentGraph || !currentGraph.links) {
        return { paths: [], distance: 0 };
    }

    // Build adjacency list
    const adjacency = new Map();
    const allLinks = [...currentGraph.links];
    if (currentGraph.indirect_connections) {
        allLinks.push(...currentGraph.indirect_connections);
    }

    allLinks.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        if (!adjacency.has(sourceId)) adjacency.set(sourceId, []);
        if (!adjacency.has(targetId)) adjacency.set(targetId, []);

        adjacency.get(sourceId).push(targetId);
        adjacency.get(targetId).push(sourceId);
    });

    // BFS to find shortest paths
    const visited = new Set([startNodeId]);
    const distances = new Map([[startNodeId, 0]]);
    const parents = new Map([[startNodeId, []]]);
    const queue = [{nodeId: startNodeId, distance: 0}];
    let queueIndex = 0;
    let foundEnd = false;
    let targetDistance = 0;

    while (queueIndex < queue.length && !foundEnd) {
        const {nodeId, distance} = queue[queueIndex++];

        if (nodeId === endNodeId) {
            foundEnd = true;
            targetDistance = distance;
            break;
        }

        const neighbors = adjacency.get(nodeId) || [];
        for (const neighborId of neighbors) {
            if (!visited.has(neighborId)) {
                visited.add(neighborId);
                distances.set(neighborId, distance + 1);
                parents.set(neighborId, [nodeId]);
                queue.push({nodeId: neighborId, distance: distance + 1});
            } else if (distances.get(neighborId) === distance + 1) {
                parents.get(neighborId).push(nodeId);
            }
        }
    }

    if (!foundEnd) {
        return { paths: [], distance: 0 };
    }

    // Reconstruct all paths
    const allPaths = [];
    function buildPaths(currentId, currentPath) {
        if (currentPath.length > 100) return;

        const nodeParents = parents.get(currentId);
        if (!nodeParents || nodeParents.length === 0) {
            allPaths.push([currentId, ...currentPath]);
            return;
        }

        for (const parentId of nodeParents) {
            buildPaths(parentId, [currentId, ...currentPath]);
        }
    }

    buildPaths(endNodeId, []);

    return { paths: allPaths, distance: targetDistance };
}

function highlightPathsBetweenNodes() {
    if (!selectedNode || !comparisonNode || !currentGraph) return;

    const pathsData = calculatePathsBetweenNodes(selectedNode.id, comparisonNode.id);

    if (pathsData.paths.length === 0) {
        // No paths found - dim everything
        d3.selectAll('.node').style('opacity', 0.2);
        d3.selectAll('.link').style('opacity', 0.1);
        d3.selectAll('.indirect-links line').style('opacity', 0.1);

        // Keep selected nodes visible
        d3.selectAll('.node').filter(d => d.id === selectedNode.id || d.id === comparisonNode.id)
            .style('opacity', 1);
        return;
    }

    // Collect all nodes and links in any path
    const pathNodeIds = new Set();
    const pathLinks = new Set();

    pathsData.paths.forEach(path => {
        path.forEach(nodeId => pathNodeIds.add(nodeId));
        for (let i = 0; i < path.length - 1; i++) {
            pathLinks.add(`${path[i]}-${path[i + 1]}`);
            pathLinks.add(`${path[i + 1]}-${path[i]}`);
        }
    });

    // Dim nodes not in paths
    d3.selectAll('.node').style('opacity', d => pathNodeIds.has(d.id) ? 1 : 0.15);

    // Dim links not in paths
    d3.selectAll('.link').each(function(d) {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        const linkKey = `${sourceId}-${targetId}`;
        const isInPath = pathLinks.has(linkKey);

        d3.select(this)
            .style('opacity', isInPath ? 0.9 : 0.1)
            .attr('stroke', isInPath ? '#ffc107' : d3.select(this).attr('data-original-stroke'))
            .attr('stroke-width', isInPath ? 5 : d3.select(this).attr('data-original-width'));
    });

    d3.selectAll('.indirect-links line').each(function(d) {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        const linkKey = `${sourceId}-${targetId}`;
        const isInPath = pathLinks.has(linkKey);

        d3.select(this)
            .style('opacity', isInPath ? 0.7 : 0.1)
            .attr('stroke', isInPath ? '#ffc107' : '#6c757d')
            .attr('stroke-width', isInPath ? 5 : d3.select(this).attr('data-original-width'));
    });
}

function showSelectedLinkDetails(link) {
    const sourceNode = currentGraph.nodes.find(n => n.id === link.source.id || n.id === link.source);
    const targetNode = currentGraph.nodes.find(n => n.id === link.target.id || n.id === link.target);

    const content = `
        <div class="row">
            <div class="col-12">
                <h6>${sourceNode ? sourceNode.name : link.source} ↔ ${targetNode ? targetNode.name : link.target}</h6>
                <p class="text-muted">${link.type === 'direct' ? 'Direct RF Link' : 'Multi-hop Connection'}</p>
            </div>
        </div>
        <div class="row">
            <div class="col-6">
                <strong>Average SNR:</strong><br>
                <span class="h5 ${link.avg_snr > -10 ? 'text-success' : 'text-warning'}">${link.avg_snr} dB</span>
            </div>
            <div class="col-6">
                <strong>Packets:</strong><br>
                <span class="h5 text-info">${link.packet_count || link.path_count || 0}</span>
            </div>
        </div>
        ${link.hop_count ? `
        <div class="row mt-2">
            <div class="col-6">
                <strong>Hop Count:</strong><br>
                <span class="h6 text-primary">${link.hop_count}</span>
            </div>
        </div>
        ` : ''}
        <div class="row mt-2">
            <div class="col-6">
                <strong>Last Seen:</strong><br>
                <small class="text-muted">${typeof formatTimestamp === 'function' ? formatTimestamp(link.last_seen) : new Date(link.last_seen * 1000).toLocaleString()}</small>
            </div>
            <div class="col-6">
                <a href="/traceroute-hops?from_node=${link.source.id}&to_node=${link.target.id}" class="btn btn-outline-primary btn-sm">
                    <i class="bi bi-diagram-3"></i> View Link
                </a>
            </div>
        </div>
    `;

    document.getElementById('selectedDetailsContent').innerHTML = content;
    document.getElementById('selectedDetails').style.display = 'block';
}

function showNodeHoverDetails(node) {
    const nodeIdHex = node.id.toString(16).padStart(8, '0');

    let pathInfo = '';
    if (selectedNode && hopFilterEnabled && nodeDistances && node.id !== selectedNode.id) {
        const distance = nodeDistances.distances.get(node.id);
        if (distance !== undefined) {
            const allPaths = getAllPathsToNode(node.id, nodeDistances.parents, selectedNode.id);

            if (allPaths.length > 0) {
                pathInfo = `<div class="mb-2"><strong>Hops from ${selectedNode.name}:</strong> ${distance}</div>`;

                if (allPaths.length === 1) {
                    // Single path
                    const path = allPaths[0];
                    const pathNames = path.map(nodeId => getNodeNameById(nodeId)).join(' → ');
                    pathInfo += `<div class="small text-muted" style="max-height: 150px; overflow-y: auto;">${pathNames}</div>`;
                } else {
                    // Multiple paths
                    pathInfo += `<div class="small"><strong>${allPaths.length} shortest paths:</strong></div>`;
                    pathInfo += `<div class="small text-muted" style="max-height: 150px; overflow-y: auto;">`;

                    allPaths.forEach((path, idx) => {
                        const pathNames = path.map(nodeId => getNodeNameById(nodeId)).join(' → ');
                        pathInfo += `<div class="mb-1">${idx + 1}. ${pathNames}</div>`;
                    });

                    pathInfo += `</div>`;
                }
            }
        }
    }

    const content = `
        <div><strong>${node.name}</strong></div>
        <div class="text-muted">!${nodeIdHex}</div>
        <hr class="my-2">
        ${pathInfo}
        ${pathInfo ? '<hr class="my-2">' : ''}
        <div><strong>Connections:</strong> ${node.connections}</div>
        <div><strong>Packets:</strong> ${node.packet_count}</div>
        <div><strong>Avg SNR:</strong> ${node.avg_snr ? node.avg_snr + ' dB' : 'N/A'}</div>
        <div><strong>Last Seen:</strong><br>
        <small>${typeof formatTimestamp === 'function' ? formatTimestamp(node.last_seen) : new Date(node.last_seen * 1000).toLocaleString()}</small></div>
    `;

    document.getElementById('hoverDetails').innerHTML = content;
}

function showLinkHoverDetails(link) {
    const sourceNode = currentGraph.nodes.find(n => n.id === link.source.id || n.id === link.source);
    const targetNode = currentGraph.nodes.find(n => n.id === link.target.id || n.id === link.target);

    const content = `
        <div><strong>Link</strong></div>
        <div class="text-muted">${sourceNode ? sourceNode.name : link.source} ↔ ${targetNode ? targetNode.name : link.target}</div>
        <hr class="my-2">
        <div><strong>Type:</strong> ${link.type === 'direct' ? 'Direct RF' : 'Multi-hop'}</div>
        <div><strong>Avg SNR:</strong> ${link.avg_snr} dB</div>
        <div><strong>Packets:</strong> ${link.packet_count || link.path_count || 0}</div>
        ${link.hop_count ? `<div><strong>Hops:</strong> ${link.hop_count}</div>` : ''}
        <div><strong>Last Seen:</strong><br>
        <small>${typeof formatTimestamp === 'function' ? formatTimestamp(link.last_seen) : new Date(link.last_seen * 1000).toLocaleString()}</small></div>
    `;

    document.getElementById('hoverDetails').innerHTML = content;
}

function clearHoverDetails() {
    document.getElementById('hoverDetails').innerHTML = '<small class="text-muted">Hover over nodes or links for details</small>';
}

function getNodeName(nodeRef) {
    if (typeof nodeRef === 'object' && nodeRef.name) {
        return nodeRef.name;
    }
    // Find node by ID in current graph
    const node = currentGraph.nodes.find(n => n.id === nodeRef);
    return node ? node.name : `!${nodeRef.toString(16).padStart(8, '0')}`;
}

// Drag functions
function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
}

function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

// Utility functions
function centerGraph() {
    console.log('centerGraph called');

    if (!window.graphSvg || !window.graphG || !window.graphZoom) {
        console.log('Missing dependencies for centerGraph:', {
            graphSvg: !!window.graphSvg,
            graphG: !!window.graphG,
            graphZoom: !!window.graphZoom
        });
        return;
    }

    // Ensure we have valid graph dimensions
    let graphWidth = window.graphWidth;
    let graphHeight = window.graphHeight;

    if (!graphWidth || !graphHeight || graphWidth === 0 || graphHeight === 0) {
        const container = document.getElementById('networkGraph');
        if (container) {
            const containerRect = container.getBoundingClientRect();
            graphWidth = containerRect.width;
            graphHeight = containerRect.height;
            window.graphWidth = graphWidth;
            window.graphHeight = graphHeight;
        }
    }

    if (!graphWidth || !graphHeight || graphWidth === 0 || graphHeight === 0) {
        console.log('Cannot center graph: invalid dimensions');
        return;
    }

    try {
        const bounds = window.graphG.node().getBBox();
        console.log('Graph bounds:', bounds);
        console.log('Container dimensions:', {width: graphWidth, height: graphHeight});

        // Calculate scale with better margins for geographical layouts
        // Use a more conservative scale factor to avoid over-zooming
        const marginFactor = 0.85; // Leave 15% margin
        const scaleX = (graphWidth * marginFactor) / bounds.width;
        const scaleY = (graphHeight * marginFactor) / bounds.height;
        const scale = Math.min(scaleX, scaleY, 2.0); // Cap at 2x zoom to avoid over-zooming

        const translateX = graphWidth / 2 - scale * (bounds.x + bounds.width / 2);
        const translateY = graphHeight / 2 - scale * (bounds.y + bounds.height / 2);

        console.log('Center transform:', {scale, translateX, translateY, bounds});

        const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);

        window.graphSvg.transition().duration(750)
            .call(window.graphZoom.transform, transform);
    } catch (error) {
        console.error('Error in centerGraph:', error);
    }
}

function resetZoom() {
    console.log('resetZoom called');

    if (!window.graphSvg || !window.graphZoom) {
        console.log('Missing dependencies for resetZoom');
        return;
    }

    window.graphSvg.transition().duration(750)
        .call(window.graphZoom.transform, d3.zoomIdentity);
}

function refreshGraph() {
    loadGraph();
}

// Soft refresh - updates graph data without re-rendering, just updates node stats
function softRefreshGraph() {
    try {
        // Get filter parameters
        const params = new URLSearchParams();
        document.querySelectorAll('#filterForm input, #filterForm select').forEach(function(element) {
            const value = element.value;
            if (value && element.type !== 'checkbox') {
                params.append(element.name, value);
            } else if (element.type === 'checkbox' && element.checked) {
                params.append(element.name, 'true');
            }
        });

        fetch(`/api/traceroute/graph?${params.toString()}`)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('Error in soft refresh:', data.error);
                    return;
                }

                // Update currentGraph with new data (don't re-render)
                if (data.nodes && currentGraph && currentGraph.nodes) {
                    // Create a map of new node data by ID
                    const newNodeMap = {};
                    data.nodes.forEach(node => {
                        newNodeMap[node.id] = node;
                    });

                    // Update existing nodes with new data
                    currentGraph.nodes.forEach(node => {
                        if (newNodeMap[node.id]) {
                            const newData = newNodeMap[node.id];
                            node.packet_count = newData.packet_count;
                            node.connections = newData.connections;
                            node.avg_snr = newData.avg_snr;

                            // For last_seen: use the more recent of activity-detected time or API data
                            if (recentNodeTimestamps[node.id]) {
                                // Use the more recent timestamp
                                node.last_seen = Math.max(node.last_seen || 0, recentNodeTimestamps[node.id]);
                            } else {
                                // No recent activity, use API data
                                node.last_seen = newData.last_seen;
                            }
                        }
                    });
                }

                // Update links with new data
                if (data.links && currentGraph && currentGraph.links) {
                    const newLinkMap = {};
                    data.links.forEach(link => {
                        const key = `${link.source}-${link.target}`;
                        newLinkMap[key] = link;
                    });

                    currentGraph.links.forEach(link => {
                        const key = `${link.source}-${link.target}`;
                        if (newLinkMap[key]) {
                            const newData = newLinkMap[key];
                            link.last_seen = newData.last_seen;
                            link.packet_count = newData.packet_count;
                            link.avg_snr = newData.avg_snr;
                            link.strength = newData.strength;
                        }
                    });
                }

                // Update stats display with new timestamp
                if (data.stats) {
                    updateStats(data.stats);
                }

                // Update all node labels with fresh last_heard times
                updateNodeLastHeardTimes();
            })
            .catch(error => {
                console.error('Error in soft refresh:', error);
            });
    } catch (error) {
        console.error('Error in softRefreshGraph:', error);
    }
}

function showLoading() {
    document.getElementById('loadingSpinner').style.display = 'flex';
    document.getElementById('networkGraph').style.display = 'none';
    document.getElementById('graphError').style.display = 'none';
}

function hideLoading() {
    document.getElementById('loadingSpinner').style.display = 'none';
    document.getElementById('networkGraph').style.display = 'block';
}

function showError(message) {
    document.getElementById('loadingSpinner').style.display = 'none';
    document.getElementById('networkGraph').style.display = 'none';
    const errorDiv = document.getElementById('graphError');
    errorDiv.style.display = 'flex';
    errorDiv.querySelector('p').textContent = message;
}

function updateStats(stats) {
    const now = typeof formatTimestamp === 'function' ? formatTimestamp(Math.floor(Date.now() / 1000), 'time') : new Date().toLocaleTimeString();
    const statsContent = `
        <div><strong>Nodes:</strong> ${currentGraph && currentGraph.nodes ? currentGraph.nodes.length : 0}</div>
        <div><strong>Links:</strong> ${stats.links_found}</div>
        <div><strong>Packets:</strong> ${stats.packets_with_rf_hops}</div>
        <div><strong>RF Hops:</strong> ${stats.total_rf_hops}</div>
        <div><strong>Updated:</strong> <small>${now}</small></div>
    `;
    document.getElementById('graphStats').innerHTML = statsContent;
}

// Handle window resize
window.addEventListener('resize', function() {
    if (simulation && currentGraph) {
        setTimeout(() => {
            const container = document.getElementById('networkGraph');
            const containerRect = container.getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;

            // Update SVG dimensions
            d3.select('#networkGraph svg')
                .attr('width', width)
                .attr('height', height);

            // Update simulation center force (but don't restart aggressively)
            if (simulation.force('center')) {
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
            }

            // Update stored dimensions
            window.graphWidth = width;
            window.graphHeight = height;
        }, 100);
    }
});

// Function to calculate nodes within N hops from a selected node
// Returns both the set of visible nodes and a map of distances and parents for path reconstruction
// Now tracks ALL parents (for multiple shortest paths) instead of just one
function getNodesWithinHops(startNodeId, maxHops) {
    if (!currentGraph || !currentGraph.links) {
        return { nodeIds: new Set(), distances: new Map(), parents: new Map(), adjacency: new Map() };
    }

    // Build adjacency list from links
    const adjacency = new Map();

    // Include both direct and indirect links
    const allLinks = [...currentGraph.links];
    if (currentGraph.indirect_connections) {
        allLinks.push(...currentGraph.indirect_connections);
    }

    allLinks.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        if (!adjacency.has(sourceId)) adjacency.set(sourceId, []);
        if (!adjacency.has(targetId)) adjacency.set(targetId, []);

        adjacency.get(sourceId).push(targetId);
        adjacency.get(targetId).push(sourceId);
    });

    // BFS to find nodes within maxHops - track ALL parents for multiple shortest paths
    const visited = new Set([startNodeId]);
    const distances = new Map([[startNodeId, 0]]);
    const parents = new Map([[startNodeId, []]]); // Now stores arrays of parents
    const queue = [{nodeId: startNodeId, distance: 0}];
    let queueIndex = 0;

    while (queueIndex < queue.length) {
        const {nodeId, distance} = queue[queueIndex++];

        if (distance < maxHops) {
            const neighbors = adjacency.get(nodeId) || [];
            for (const neighborId of neighbors) {
                if (!visited.has(neighborId)) {
                    // First time visiting this node
                    visited.add(neighborId);
                    distances.set(neighborId, distance + 1);
                    parents.set(neighborId, [nodeId]);
                    queue.push({nodeId: neighborId, distance: distance + 1});
                } else if (distances.get(neighborId) === distance + 1) {
                    // Found another shortest path to this node
                    parents.get(neighborId).push(nodeId);
                }
            }
        }
    }

    return { nodeIds: visited, distances, parents, adjacency };
}

// Function to find ALL shortest paths from selected node to target node
function getAllPathsToNode(targetNodeId, parents, startNodeId) {
    if (!parents || !parents.has(targetNodeId)) {
        return [];
    }

    const allPaths = [];

    // Recursive function to build all paths
    function buildPaths(currentId, currentPath) {
        if (currentPath.length > 100) {
            console.error('Path reconstruction exceeded maximum length');
            return;
        }

        const nodeParents = parents.get(currentId);
        if (!nodeParents || nodeParents.length === 0) {
            // Reached the start node
            allPaths.push([currentId, ...currentPath]);
            return;
        }

        // Recurse for each parent
        for (const parentId of nodeParents) {
            buildPaths(parentId, [currentId, ...currentPath]);
        }
    }

    buildPaths(targetNodeId, []);

    return allPaths;
}

// Helper function to get node name by ID
function getNodeNameById(nodeId) {
    if (!currentGraph || !currentGraph.nodes) return `!${nodeId.toString(16).padStart(8, '0')}`;
    const node = currentGraph.nodes.find(n => n.id === nodeId);
    return node ? node.name : `!${nodeId.toString(16).padStart(8, '0')}`;
}

// Function to highlight ALL paths from selected node to hovered node
function highlightPathToNode(hoveredNode) {
    if (!selectedNode || !nodeDistances || !currentGraph) {
        return;
    }

    const allPaths = getAllPathsToNode(hoveredNode.id, nodeDistances.parents, selectedNode.id);
    if (allPaths.length === 0) {
        return;
    }

    // Create a set of all node IDs in any path
    const pathNodeIds = new Set();
    allPaths.forEach(path => {
        path.forEach(nodeId => pathNodeIds.add(nodeId));
    });

    // Create a set of all links in any path (pairs of consecutive nodes)
    const pathLinks = new Set();
    allPaths.forEach(path => {
        for (let i = 0; i < path.length - 1; i++) {
            const id1 = path[i];
            const id2 = path[i + 1];
            // Store both directions since links are bidirectional
            pathLinks.add(`${id1}-${id2}`);
            pathLinks.add(`${id2}-${id1}`);
        }
    });

    // Highlight nodes in any path (except already selected node)
    d3.selectAll('.node').each(function(d) {
        const isInPath = pathNodeIds.has(d.id) && d.id !== selectedNode.id;
        d3.select(this).select('circle')
            .attr('stroke', isInPath ? '#ffc107' : '#fff')
            .attr('stroke-width', isInPath ? 4 : 2);
    });

    // Highlight links in any path
    d3.selectAll('.link').each(function(d) {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        const linkKey = `${sourceId}-${targetId}`;
        const isInPath = pathLinks.has(linkKey);

        d3.select(this)
            .attr('stroke', isInPath ? '#ffc107' : d3.select(this).attr('data-original-stroke'))
            .attr('stroke-width', isInPath ? 5 : d3.select(this).attr('data-original-width'));
    });

    d3.selectAll('.indirect-links line').each(function(d) {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        const linkKey = `${sourceId}-${targetId}`;
        const isInPath = pathLinks.has(linkKey);

        d3.select(this)
            .attr('stroke', isInPath ? '#ffc107' : '#6c757d')
            .attr('stroke-width', isInPath ? 5 : d3.select(this).attr('data-original-width'));
    });
}

// Function to clear path highlighting
function clearPathHighlight() {
    // Reset node strokes (except the selected node which should remain highlighted)
    d3.selectAll('.node').each(function(d) {
        if (!selectedNode || d.id !== selectedNode.id) {
            d3.select(this).select('circle')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);
        }
    });

    // Reset link colors to their original values
    d3.selectAll('.link').each(function(d) {
        d3.select(this)
            .attr('stroke', d3.select(this).attr('data-original-stroke'))
            .attr('stroke-width', d3.select(this).attr('data-original-width'));
    });

    d3.selectAll('.indirect-links line').each(function(d) {
        d3.select(this)
            .attr('stroke', '#6c757d')
            .attr('stroke-width', d3.select(this).attr('data-original-width'));
    });
}

// Function to apply hop filter to the graph
function applyHopFilter() {
    if (!selectedNode || !currentGraph) {
        return;
    }

    if (!hopFilterEnabled) {
        // Reset all visibility
        d3.selectAll('.node').style('opacity', 1);
        d3.selectAll('.link').style('opacity', 0.8);
        d3.selectAll('.indirect-links line').style('opacity', 0.4);
        document.getElementById('hopFilterStats').style.display = 'none';
        visibleNodeIds = null;
        nodeDistances = null;
        return;
    }

    // Get nodes within hop distance with path information
    const result = getNodesWithinHops(selectedNode.id, maxHopDistance);
    visibleNodeIds = result.nodeIds;
    nodeDistances = { distances: result.distances, parents: result.parents, adjacency: result.adjacency };

    console.log(`Filtering to ${visibleNodeIds.size} nodes within ${maxHopDistance} hops of ${selectedNode.name}`);

    // Update stats display
    const totalNodes = currentGraph.nodes.length;
    document.getElementById('visibleNodeCount').textContent = visibleNodeIds.size;
    document.getElementById('totalNodeCount').textContent = totalNodes;
    document.getElementById('hopFilterStats').style.display = 'block';

    // Update node visibility
    d3.selectAll('.node').style('opacity', d => {
        return visibleNodeIds.has(d.id) ? 1 : 0.1;
    });

    // Update link visibility - show only links where both endpoints are visible
    d3.selectAll('.link').style('opacity', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        return (visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId)) ? 0.8 : 0.05;
    });

    d3.selectAll('.indirect-links line').style('opacity', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        return (visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId)) ? 0.4 : 0.05;
    });
}

async function loadPrimaryChannels() {
    try {
        const response = await fetch('/api/meshtastic/channels');
        const data = await response.json();
        if (data.channels) {
            const select = document.getElementById('primary_channel');
            const allOption = select.querySelector('option[value=""]');
            select.innerHTML = '';
            select.appendChild(allOption);
            data.channels.forEach((ch) => {
                const option = document.createElement('option');
                option.value = ch;
                option.textContent = ch;
                select.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Error loading channels:', err);
    }
}

// Real-time packet activity monitoring
function startActivityPolling() {
    // Poll every 3 seconds
    activityPollInterval = setInterval(pollPacketActivity, 3000);
    // Do an initial poll
    pollPacketActivity();
}

function stopActivityPolling() {
    if (activityPollInterval) {
        clearInterval(activityPollInterval);
        activityPollInterval = null;
    }
}

async function pollPacketActivity() {
    try {
        // Get packets from the last 5 seconds
        const response = await fetch('/api/packets/activity?seconds=5');
        const data = await response.json();

        console.log('pollPacketActivity: received', data.count || 0, 'activities');

        if (data.error) {
            console.error('Error fetching packet activity:', data.error);
            return;
        }

        // Process activities and animate nodes
        if (data.activities && data.activities.length > 0) {
            const nodeIds = new Set();
            const now = Math.floor(Date.now() / 1000); // Current timestamp in seconds

            // Collect all active node IDs and record activities
            data.activities.forEach(activity => {
                nodeIds.add(activity.from_node_id);

                // Track activity count for heatmap
                nodeActivityCount[activity.from_node_id] = (nodeActivityCount[activity.from_node_id] || 0) + 1;

                if (activity.to_node_id) {
                    nodeIds.add(activity.to_node_id);
                    nodeActivityCount[activity.to_node_id] = (nodeActivityCount[activity.to_node_id] || 0) + 1;

                    // Get node names from current graph and update last_seen
                    if (currentGraph && currentGraph.nodes) {
                        const fromNode = currentGraph.nodes.find(n => n.id === activity.from_node_id);
                        const toNode = currentGraph.nodes.find(n => n.id === activity.to_node_id);

                        if (fromNode && toNode) {
                            // Update last_seen timestamps to now for real-time display
                            fromNode.last_seen = now;
                            toNode.last_seen = now;

                            // Also track these timestamps separately so they don't get overwritten by soft refresh
                            recentNodeTimestamps[activity.from_node_id] = now;
                            recentNodeTimestamps[activity.to_node_id] = now;

                            const packetType = activity.portnum_name || activity.packet_type || 'DATA';
                            addActivity(fromNode.name, toNode.name, packetType);

                            // Track link activity if highlighting is enabled (any packet type with to_node_id)
                            if (enableLinkHighlight && activity.to_node_id) {
                                // Create a link key (sorted tuple for bidirectional matching)
                                const linkKey = [activity.from_node_id, activity.to_node_id].sort().join('-');
                                recentLinkActivity[linkKey] = {
                                    timestamp: Date.now(),
                                    fromId: activity.from_node_id,
                                    toId: activity.to_node_id
                                };

                                // Highlight the link with fade animation
                                console.log('Calling highlightLink for', activity.from_node_id, 'to', activity.to_node_id);
                                highlightLink(activity.from_node_id, activity.to_node_id);
                            }
                        }
                    }
                }
            });

            // Update the display of last_heard times for active nodes immediately
            updateNodeLastHeardTimes();

            // Update node activity heatmap visualization
            updateNodeActivityHalo();

            // Animate the active nodes
            animateActiveNodes(nodeIds);
        }
    } catch (err) {
        console.error('Error polling packet activity:', err);
    }
}

function animateActiveNodes(nodeIds) {
    if (!window.graphNodes) {
        return;
    }

    // Select nodes that match the active node IDs
    window.graphNodes.each(function(d) {
        if (nodeIds.has(d.id)) {
            const nodeElement = d3.select(this);

            // Remove existing animation class
            nodeElement.classed('active', false);

            // Force a reflow to restart the animation
            void this.offsetWidth;

            // Add animation class
            nodeElement.classed('active', true);

            // Remove the class after animation completes (1 second)
            setTimeout(() => {
                nodeElement.classed('active', false);
            }, 1000);
        }
    });
}

function updateNodeActivityHalo() {
    if (!window.graphNodes) {
        return;
    }

    // Find the max activity count to scale the halos
    const maxActivity = Math.max(...Object.values(nodeActivityCount), 1);

    // Update each node's halo based on activity
    window.graphNodes.each(function(d) {
        const haloCircle = d3.select(this).select('circle.node-halo');
        const activityCount = nodeActivityCount[d.id] || 0;

        // Scale the halo radius from base size up to 3x based on activity
        const baseRadius = parseFloat(haloCircle.attr('data-base-radius')) || d.size + 2;
        const scaleFactor = 1 + (activityCount / maxActivity) * 2; // Scale from 1x to 3x
        const newRadius = baseRadius * scaleFactor;

        // Scale the stroke width proportionally
        const strokeWidth = 1 + (activityCount / maxActivity) * 3; // 1 to 4

        // Update halo visualization
        haloCircle
            .attr('r', newRadius)
            .attr('stroke-width', strokeWidth)
            .attr('stroke-opacity', Math.min(0.3 + (activityCount / maxActivity) * 0.7, 1)); // 0.3 to 1.0
    });
}

function highlightLink(fromId, toId) {
    console.log('highlightLink called:', fromId, '->', toId);

    if (!window.graphLinks) {
        console.warn('graphLinks not found');
        return false;
    }

    let highlightedAny = false;

    // Select all line elements in BOTH direct and indirect links groups
    d3.selectAll('g.links line, g.indirect-links line').each(function(d) {
        const isMatch = (d.source.id === fromId && d.target.id === toId) ||
                       (d.source.id === toId && d.target.id === fromId);

        if (isMatch) {
            console.log('Link match found! Highlighting:', d.source.id, '->', d.target.id);
            const el = d3.select(this);
            const element = this;

            // Stop any previous timeout
            if (d.fadeTimeout) clearTimeout(d.fadeTimeout);

            // Store original values using both attr and style getters
            const origStroke = element.getAttribute('data-original-stroke') || element.getAttribute('stroke') || '#999';
            const origWidth = element.getAttribute('data-original-width') || element.getAttribute('stroke-width') || '1';
            const origOpacity = element.getAttribute('stroke-opacity') || '0.8';

            console.log('Original stroke:', origStroke, 'width:', origWidth, 'opacity:', origOpacity);

            // Move this element to the end of its parent so it renders on top
            element.parentNode.appendChild(element);

            // Apply strong yellow highlight using attributes (more reliable than styles in SVG)
            el.attr('stroke', '#FFD700')
              .attr('stroke-width', '5')
              .attr('stroke-opacity', '1')
              .style('filter', 'drop-shadow(0 0 10px #FFD700) drop-shadow(0 0 5px #FFA500)')
              .style('pointer-events', 'auto');

            console.log('Applied highlight to link');

            // Fade out after decay time
            d.fadeTimeout = setTimeout(() => {
                el.attr('stroke', origStroke)
                  .attr('stroke-width', origWidth)
                  .attr('stroke-opacity', origOpacity)
                  .style('filter', 'none');
                console.log('Faded out link highlight');
            }, linkDecayTimeSeconds * 1000);

            highlightedAny = true;
        }
    });

    if (!highlightedAny) {
        console.warn('No matching link found. Total direct links:', d3.selectAll('g.links line').size(), 'indirect:', d3.selectAll('g.indirect-links line').size());
    }
    console.log('highlightLink result:', highlightedAny);
    return highlightedAny;
}

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    stopActivityPolling();
    stopAutoRefresh();
});

// ============= AUTO-REFRESH FUNCTIONALITY =============

function setupAutoRefresh() {
    autoRefreshEnabled = document.getElementById('autoRefreshToggle').checked;
    autoRefreshIntervalSeconds = parseInt(document.getElementById('autoRefreshInterval').value);
    updateAutoRefreshStatus();

    if (autoRefreshEnabled) {
        startAutoRefresh();
        document.getElementById('autoRefreshTimer').style.display = 'block';
    }
}

function startAutoRefresh() {
    stopAutoRefresh(); // Clear any existing intervals
    nextRefreshCountdown = autoRefreshIntervalSeconds;

    // Start the countdown timer
    refreshCountdownInterval = setInterval(updateCountdown, 1000);

    // Start the refresh interval - use soft refresh to update data without re-rendering
    autoRefreshInterval = setInterval(() => {
        if (autoRefreshEnabled) {
            // Clean up old timestamps before soft refresh (older than 5 minutes)
            const now = Math.floor(Date.now() / 1000);
            const nowMs = Date.now();
            const fiveMinutesAgo = now - (5 * 60);
            const decayMs = linkDecayTimeSeconds * 1000;

            Object.keys(recentNodeTimestamps).forEach(nodeId => {
                if (recentNodeTimestamps[nodeId] < fiveMinutesAgo) {
                    delete recentNodeTimestamps[nodeId];
                }
            });

            // Clean up old link activity (older than decay time)
            Object.keys(recentLinkActivity).forEach(linkKey => {
                if (recentLinkActivity[linkKey].timestamp < nowMs - decayMs) {
                    delete recentLinkActivity[linkKey];
                }
            });

            // Reset node activity count every 30 seconds for fresh heatmap data
            if (Math.floor(nextRefreshCountdown) % 30 === 0) {
                nodeActivityCount = {};
            }

            softRefreshGraph();
            nextRefreshCountdown = autoRefreshIntervalSeconds;
        }
    }, autoRefreshIntervalSeconds * 1000);
}

function stopAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
    }
    if (refreshCountdownInterval) {
        clearInterval(refreshCountdownInterval);
        refreshCountdownInterval = null;
    }
}

function updateCountdown() {
    if (nextRefreshCountdown > 0) {
        nextRefreshCountdown--;
        document.getElementById('refreshCountdown').textContent = nextRefreshCountdown;
    }
}

function updateAutoRefreshStatus() {
    const statusText = autoRefreshIntervalSeconds < 60
        ? `every ${autoRefreshIntervalSeconds}s`
        : `every ${Math.floor(autoRefreshIntervalSeconds / 60)}m`;
    document.getElementById('autoRefreshStatus').textContent = statusText;
}

// ============= ACTIVITY FEED FUNCTIONALITY =============

function addActivity(fromNode, toNode, packetType) {
    const activity = {
        timestamp: Date.now(),
        fromNode: fromNode,
        toNode: toNode,
        type: packetType || 'DATA'
    };

    recentActivities.unshift(activity);
    if (recentActivities.length > maxActivityItems) {
        recentActivities.pop();
    }

    displayActivityFeed();
}

function displayActivityFeed() {
    const feedContainer = document.getElementById('activityFeed');

    if (recentActivities.length === 0) {
        feedContainer.innerHTML = '<small class="text-muted">No recent activity</small>';
        return;
    }

    const now = Date.now();
    const feedHTML = recentActivities.map((activity, index) => {
        const elapsed = now - activity.timestamp;
        const elapsedSeconds = Math.floor(elapsed / 1000);
        let timeStr;

        if (elapsedSeconds < 60) {
            timeStr = `${elapsedSeconds}s ago`;
        } else if (elapsedSeconds < 3600) {
            timeStr = `${Math.floor(elapsedSeconds / 60)}m ago`;
        } else {
            timeStr = `${Math.floor(elapsedSeconds / 3600)}h ago`;
        }

        const isRecent = index === 0 && elapsed < 5000;
        const className = isRecent ? 'activity-item recent' : 'activity-item';

        return `
            <div class="${className}">
                <span class="activity-item-time">${timeStr}</span>
                <span class="activity-item-node">${activity.fromNode}</span>
                <span class="activity-item-detail">→ ${activity.toNode}</span>
                <span class="badge bg-info" style="font-size: 0.7rem;">${activity.type}</span>
            </div>
        `;
    }).join('');

    feedContainer.innerHTML = feedHTML;
}

// ============= UPDATE LAST HEARD TIMES IN REAL-TIME =============

function updateNodeLastHeardTimes() {
    if (!window.graphNodes) return;

    const now = Date.now();

    window.graphNodes.each(function(d) {
        const labelGroup = d3.select(this).select('.node-labels');
        if (!labelGroup.empty()) {
            const lastHeardTime = new Date(d.last_seen * 1000);
            const diffMinutes = Math.floor((now - lastHeardTime) / 60000);

            let lastHeardText = '';
            if (diffMinutes < 1) {
                lastHeardText = 'now';
            } else if (diffMinutes < 60) {
                lastHeardText = `${diffMinutes}m ago`;
            } else if (diffMinutes < 1440) {
                const hours = Math.floor(diffMinutes / 60);
                lastHeardText = `${hours}h ago`;
            } else {
                const days = Math.floor(diffMinutes / 1440);
                lastHeardText = `${days}d ago`;
            }

            labelGroup.select('.node-label-subtitle')
                .text(`(${lastHeardText})`);
        }
    });
}

// Update "last heard" times every 30 seconds
setInterval(updateNodeLastHeardTimes, 30000);

</script>

<!-- Re-open the container for the footer (which we're hiding anyway) -->
<div class="container mt-4" style="display: none;">
{% endblock %}
