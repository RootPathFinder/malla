{% extends "base.html" %}
{% from "macros.html" import node_picker %}

{% block title %}Traceroute RF Hop Analysis - Malla{% endblock %}

{% block head_libs %}
<!-- Chart.js for hop analysis charts -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" integrity="sha384-e6nUZLBkQ86NJ6TVVKAeSaK8jWa3NhkYWZFomE39AvDbQWeie9PlQqM3pmYW5d1g" crossorigin="anonymous"></script>
<!-- Plotly for hop distribution visualization -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
{% endblock head_libs %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/node-picker.css') }}">
<style>
    .node-selector {
        background: var(--bs-tertiary-bg);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    .hop-analysis-card {
        border-left: 4px solid #0d6efd;
    }
    .signal-badge {
        font-size: 0.8rem;
    }
    .distance-display {
        font-weight: bold;
        color: #0d6efd;
    }
    .no-data {
        text-align: center;
        padding: 2rem;
        color: #6c757d;
    }
    .loading-spinner {
        display: none;
        text-align: center;
        padding: 2rem;
    }
    .traceroute-item {
        border-bottom: 1px solid #dee2e6;
        padding: 0.75rem 0;
    }
    .traceroute-item:last-child {
        border-bottom: none;
    }
    .chart-container {
        height: 300px;
        margin: 1rem 0;
    }

    /* Hop Distribution Styles */
    .hop-group {
        border-bottom: 1px solid var(--bs-border-color);
        padding-bottom: 0.5rem;
    }
    .hop-group:last-child {
        border-bottom: none;
    }
    .hop-node-item:hover {
        background: var(--bs-primary-bg-subtle) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <h1><i class="bi bi-broadcast-pin"></i> Traceroute RF Hop Analysis</h1>
        <p class="text-muted">Analyze radio frequency hops between any two nodes using traceroute data</p>
    </div>
</div>

<!-- Hop Distribution Overview -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span><i class="bi bi-bar-chart-steps"></i> Network Hop Distribution</span>
                <button class="btn btn-sm btn-outline-secondary" onclick="loadHopDistribution()" title="Refresh">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            </div>
            <div class="card-body">
                <div id="hop-distribution-loading" class="text-center p-3">
                    <div class="spinner-border spinner-border-sm text-primary" role="status"></div>
                    <span class="ms-2">Loading hop distribution from traceroute data...</span>
                </div>
                <div id="hop-distribution-content" style="display: none;">
                    <div class="row">
                        <div class="col-lg-8">
                            <!-- Plotly Chart -->
                            <div id="hop-distribution-chart" style="height: 400px;"></div>
                        </div>
                        <div class="col-lg-4">
                            <!-- Node List by Hop Count -->
                            <div id="hop-node-list" class="border rounded p-2" style="max-height: 400px; overflow-y: auto;">
                                <h6 class="text-muted mb-2">Nodes by Hop Distance</h6>
                                <div id="hop-node-groups"></div>
                            </div>
                        </div>
                    </div>
                    <div class="text-center mt-2">
                        <small class="text-muted"><i class="bi bi-info-circle"></i> Based on <span id="traceroute-count">0</span> traceroutes from the last 7 days. Click a node to analyze its connections.</small>
                    </div>
                </div>
                <div id="hop-distribution-empty" class="text-center text-muted p-4" style="display: none;">
                    <i class="bi bi-diagram-3" style="font-size: 2rem; opacity: 0.5;"></i>
                    <p class="mt-2">No traceroute data available for hop estimation</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Node Selection -->
<div class="row">
    <div class="col-md-6">
        <div class="node-selector">
            <h5><i class="bi bi-1-circle"></i> Select First Node</h5>
            {{ node_picker(
                field_name="node1",
                field_id="node1-select",
                label="",
                selected_value="",
                selected_display="",
                placeholder="Choose first node..."
            ) }}
            <div id="node1-info" class="mt-2 text-muted"></div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="node-selector">
            <h5><i class="bi bi-2-circle"></i> Select Second Node</h5>
            <select id="node2-select" class="form-select">
                <option value="">Choose second node...</option>
            </select>
            <div id="node2-info" class="mt-2 text-muted"></div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-12">
        <button id="analyze-btn" class="btn btn-primary btn-lg" disabled>
            <i class="bi bi-search"></i> Analyze RF Hop
        </button>
        <div class="loading-spinner" id="loading">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p>Analyzing traceroute data...</p>
        </div>
    </div>
</div>

<!-- Results Section -->
<div id="results-section" style="display: none;">
    <!-- Summary Card -->
    <div class="row mt-4">
        <div class="col-12">
            <div class="card hop-analysis-card">
                <div class="card-header">
                    <h5><i class="bi bi-bar-chart"></i> RF Hop Summary</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-3">
                            <div class="text-center">
                                <h3 id="total-hops" class="text-primary">-</h3>
                                <small class="text-muted">Total Hops Seen</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="text-center">
                                <h3 id="avg-snr" class="text-success">-</h3>
                                <small class="text-muted">Average SNR (dB)</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="text-center">
                                <h3 id="geo-distance" class="distance-display">-</h3>
                                <small class="text-muted">Geographic Distance</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="text-center">
                                <h3 id="last-seen" class="text-info">-</h3>
                                <small class="text-muted">Last Seen</small>
                            </div>
                        </div>
                    </div>
                    <div class="row mt-3">
                        <div class="col-12">
                            <div id="direction-info"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Signal Quality Chart -->
    <div class="row mt-4">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h6><i class="bi bi-graph-up"></i> SNR Over Time</h6>
                </div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="snr-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h6><i class="bi bi-pie-chart"></i> Direction Distribution</h6>
                </div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="direction-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Traceroute Details -->
    <div class="row mt-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h6><i class="bi bi-list-ul"></i> Individual Traceroutes</h6>
                    <span id="traceroute-count" class="badge bg-primary">0</span>
                </div>
                <div class="card-body">
                    <div id="traceroute-list"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- No Data Message -->
<div id="no-data-section" class="no-data" style="display: none;">
    <i class="bi bi-exclamation-triangle text-warning" style="font-size: 3rem;"></i>
    <h4 class="mt-3">No RF Hop Data Found</h4>
    <p>No traceroutes found containing a direct RF hop between these two nodes.<br>
       This could mean they're not directly connected via radio frequency.</p>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/node-picker.js') }}"></script>
<script>
    let availableNodes = [];
    let relatedNodes = [];
    let snrChart = null;
    let directionChart = null;

    // Load available nodes on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadAvailableNodes();
        setupEventListeners();

        // Check for URL parameters and auto-select nodes if present
        checkURLParameters();
    });

    function checkURLParameters() {
        const urlParams = new URLSearchParams(window.location.search);
        const fromNode = urlParams.get('from_node');
        const toNode = urlParams.get('to_node');

        if (fromNode && toNode) {
            // Store the parameters to use after nodes are loaded
            window.autoSelectNodes = {
                fromNode: fromNode,
                toNode: toNode
            };
        }
    }

    function setupEventListeners() {
        const node1Input = document.getElementById('node1-select_value'); // Hidden input for node picker
        const node2Select = document.getElementById('node2-select');
        const analyzeBtn = document.getElementById('analyze-btn');

        // Listen for changes on the hidden input (updated by node picker)
        node1Input.addEventListener('change', function() {
            updateNodeInfo('node1', this.value);
            loadRelatedNodes(this.value);
            checkAnalyzeButton();
            updateURLFromSelections();
        });

        node2Select.addEventListener('change', function() {
            updateNodeInfo('node2', this.value);
            checkAnalyzeButton();
            updateURLFromSelections();
        });

        analyzeBtn.addEventListener('click', function() {
            analyzeHop();
        });
    }

    function checkAnalyzeButton() {
        const node1 = document.getElementById('node1-select_value').value; // Hidden input for node picker
        const node2 = document.getElementById('node2-select').value;
        const analyzeBtn = document.getElementById('analyze-btn');

        analyzeBtn.disabled = !node1 || !node2 || node1 === node2;
    }

    function loadAvailableNodes() {
        fetch('/api/traceroute-hops/nodes')
            .then(response => response.json())
            .then(data => {
                availableNodes = data.nodes;
                populateNodeSelects();
            })
            .catch(error => {
                console.error('Error loading nodes:', error);
            });
    }

    function loadRelatedNodes(nodeId) {
        const node2Select = document.getElementById('node2-select');

        if (!nodeId) {
            // Reset to show all nodes
            populateNode2Select(availableNodes);
            return Promise.resolve();
        }

        // Show loading state
        node2Select.innerHTML = '<option value="">Loading related nodes...</option>';
        node2Select.disabled = true;

        return fetch(`/api/traceroute/related-nodes/${nodeId}`)
            .then(response => response.json())
            .then(data => {
                relatedNodes = data.related_nodes || [];
                populateNode2Select(relatedNodes);
                node2Select.disabled = false;

                // Update node1 info to show how many related nodes were found
                updateNode1InfoWithRelatedCount(nodeId, relatedNodes.length);
            })
            .catch(error => {
                console.error('Error loading related nodes:', error);
                // Fallback to all nodes
                populateNode2Select(availableNodes);
                node2Select.disabled = false;
            });
    }

    function populateNodeSelects() {
        // Node1 is now handled by the node picker, so we don't need to populate it manually
        // Just populate node2 with all nodes initially
        populateNode2Select(availableNodes);

        // Auto-select nodes from URL parameters if present
        if (window.autoSelectNodes) {
            const { fromNode, toNode } = window.autoSelectNodes;

            // Convert node IDs to integers for comparison
            const fromNodeInt = parseInt(fromNode);
            const toNodeInt = parseInt(toNode);

            // Find and select the nodes
            const fromNodeExists = availableNodes.find(n => n.node_id == fromNodeInt);
            const toNodeExists = availableNodes.find(n => n.node_id == toNodeInt);

            if (fromNodeExists && toNodeExists) {
                // Set the node picker value and display
                const node1Input = document.getElementById('node1-select_value');
                const node1Display = document.getElementById('node1-select');
                node1Input.value = fromNodeInt;
                node1Display.value = fromNodeExists.display_name;

                // Update node info displays
                updateNodeInfo('node1', fromNodeInt);

                // Load related nodes for the first node, then select the second node
                loadRelatedNodes(fromNodeInt).then(() => {
                    const node2Select = document.getElementById('node2-select');
                    node2Select.value = toNodeInt;
                    updateNodeInfo('node2', toNodeInt);

                    // Enable analyze button and trigger analysis
                    checkAnalyzeButton();

                    // Auto-trigger analysis after a short delay to ensure UI is ready
                    setTimeout(() => {
                        if (!document.getElementById('analyze-btn').disabled) {
                            analyzeHop();
                        }
                    }, 500);
                });

                // Clear the auto-select data
                delete window.autoSelectNodes;
            } else {
                console.warn('One or both nodes from URL parameters not found in available nodes');
                if (!fromNodeExists) console.warn('From node not found:', fromNode);
                if (!toNodeExists) console.warn('To node not found:', toNode);
            }
        }
    }

    function populateNode2Select(nodes) {
        const node2Select = document.getElementById('node2-select');
        const currentValue = node2Select.value;

        // Clear existing options (except the first one)
        node2Select.innerHTML = '<option value="">Choose second node...</option>';

        nodes.forEach(node => {
            // Create option text with traceroute count if available
            let optionText = node.display_name;
            if (node.traceroute_count) {
                optionText += ` (${node.traceroute_count} traceroutes)`;
            }

            const option = new Option(optionText, node.node_id);
            node2Select.add(option);
        });

        // Restore previous selection if it still exists
        if (currentValue && nodes.find(n => n.node_id == currentValue)) {
            node2Select.value = currentValue;
        }
    }

    function updateNodeInfo(nodeType, nodeId) {
        const infoDiv = document.getElementById(`${nodeType}-info`);

        if (!nodeId) {
            infoDiv.innerHTML = '';
            return;
        }

        const node = availableNodes.find(n => n.node_id == nodeId);
        if (node) {
            let info = `<strong>${node.hex_id}</strong>`;
            if (node.location) {
                info += ` â€¢ <i class="bi bi-geo-alt"></i> ${node.location.latitude.toFixed(4)}, ${node.location.longitude.toFixed(4)}`;
            }
            if (node.hw_model) {
                info += ` â€¢ ${node.hw_model}`;
            }
            infoDiv.innerHTML = info;
        }
    }

    function updateNode1InfoWithRelatedCount(nodeId, relatedCount) {
        const infoDiv = document.getElementById('node1-info');
        const node = availableNodes.find(n => n.node_id == nodeId);

        if (node) {
            let info = `<strong>${node.hex_id}</strong>`;
            if (node.location) {
                info += ` â€¢ <i class="bi bi-geo-alt"></i> ${node.location.latitude.toFixed(4)}, ${node.location.longitude.toFixed(4)}`;
            }
            if (node.hw_model) {
                info += ` â€¢ ${node.hw_model}`;
            }

            // Add related nodes count
            if (relatedCount > 0) {
                info += ` â€¢ <i class="bi bi-diagram-3"></i> ${relatedCount} related nodes`;
            } else {
                info += ` â€¢ <i class="bi bi-exclamation-triangle text-warning"></i> No related nodes found`;
            }

            infoDiv.innerHTML = info;
        }
    }

    function analyzeHop() {
        const node1Id = document.getElementById('node1-select_value').value; // Hidden input for node picker
        const node2Id = document.getElementById('node2-select').value;

        // Update URL with selected nodes
        updateURL(node1Id, node2Id);

        // Show loading
        document.getElementById('loading').style.display = 'block';
        document.getElementById('results-section').style.display = 'none';
        document.getElementById('no-data-section').style.display = 'none';

        // Fetch hop analysis data
        fetch(`/api/traceroute/link/${node1Id}/${node2Id}`)
            .then(response => response.json())
            .then(data => {
                document.getElementById('loading').style.display = 'none';

                if (data.traceroutes && data.traceroutes.length > 0) {
                    try {
                        displayResults(data);
                    } catch (error) {
                        console.error('Error displaying results:', error);
                        alert('Error displaying results: ' + error.message);
                        document.getElementById('no-data-section').style.display = 'block';
                    }
                } else {
                    document.getElementById('no-data-section').style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Error analyzing hop:', error);
                document.getElementById('loading').style.display = 'none';
                alert('Error analyzing hop: ' + error.message);
                document.getElementById('no-data-section').style.display = 'block';
            });
    }

    function updateURL(node1Id, node2Id) {
        if (node1Id && node2Id) {
            const url = new URL(window.location);
            url.searchParams.set('from_node', node1Id);
            url.searchParams.set('to_node', node2Id);
            window.history.pushState({}, '', url);
        }
    }

    function updateURLFromSelections() {
        const node1Id = document.getElementById('node1-select_value').value; // Hidden input for node picker
        const node2Id = document.getElementById('node2-select').value;

        if (node1Id && node2Id) {
            updateURL(node1Id, node2Id);
        } else {
            // Clear URL parameters if nodes are not fully selected
            const url = new URL(window.location);
            url.searchParams.delete('from_node');
            url.searchParams.delete('to_node');
            window.history.pushState({}, '', url);
        }
    }

    function getNodeDisplayInfo(nodeId) {
        const node = availableNodes.find(n => n.node_id == nodeId);
        if (node) {
            return {
                name: node.display_name,
                hex_id: node.hex_id,
                location: node.location,
                hw_model: node.hw_model
            };
        }
        return {
            name: `Node !${parseInt(nodeId).toString(16).padStart(8, '0')}`,
            hex_id: `!${parseInt(nodeId).toString(16).padStart(8, '0')}`,
            location: null,
            hw_model: null
        };
    }

    function createNodeLink(nodeId, displayText, includeTooltip = true) {
        const nodeInfo = getNodeDisplayInfo(nodeId);
        let tooltip = '';

        if (includeTooltip) {
            tooltip = `title="${nodeInfo.name}`;
            if (nodeInfo.location) {
                tooltip += `\nLocation: ${nodeInfo.location.latitude.toFixed(4)}, ${nodeInfo.location.longitude.toFixed(4)}`;
            }
            if (nodeInfo.hw_model) {
                tooltip += `\nHardware: ${nodeInfo.hw_model}`;
            }
            tooltip += `\nClick to view details"`;
        }

        return `<a href="/node/${nodeId}" ${tooltip} class="text-decoration-none">${displayText || nodeInfo.name}</a>`;
    }

    function formatNodeIdForDisplay(nodeId) {
        const nodeInfo = getNodeDisplayInfo(nodeId);
        // Extract just the short name and hex ID for compact display
        const shortName = nodeInfo.name.split(' (')[0]; // Get name before hex ID if present
        const hexId = nodeInfo.hex_id.substring(1, 5); // Get first 4 chars after !
        return `${shortName} (${hexId})`;
    }

    function displayResults(data) {
        document.getElementById('results-section').style.display = 'block';

        // Update summary
        document.getElementById('total-hops').textContent = data.total_attempts;
        document.getElementById('avg-snr').textContent = data.avg_snr ? `${data.avg_snr.toFixed(1)}` : 'N/A';
        document.getElementById('last-seen').textContent = getRelativeTime(data.traceroutes[0]?.timestamp);

        // Calculate and display geographic distance
        const geoDistance = calculateGeoDistance(data.from_node_id, data.to_node_id);
        document.getElementById('geo-distance').textContent = geoDistance;

        // Display direction information with proper node formatting
        displayDirectionInfo(data.direction_counts, data.from_node_id, data.to_node_id);

        // Update charts
        updateSNRChart(data.traceroutes);
        updateDirectionChart(data.direction_counts);

        // Display traceroute list
        displayTracerouteList(data.traceroutes, data.from_node_name, data.to_node_name);
        document.getElementById('traceroute-count').textContent = data.traceroutes.length;
    }

    function calculateGeoDistance(node1Id, node2Id) {
        const node1 = availableNodes.find(n => n.node_id == node1Id);
        const node2 = availableNodes.find(n => n.node_id == node2Id);

        if (!node1?.location || !node2?.location) {
            return 'N/A';
        }

        const lat1 = node1.location.latitude;
        const lon1 = node1.location.longitude;
        const lat2 = node2.location.latitude;
        const lon2 = node2.location.longitude;

        // Haversine formula
        const R = 6371; // Earth's radius in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c;

        if (distance < 1) {
            return `${(distance * 1000).toFixed(0)}m`;
        } else {
            return `${distance.toFixed(2)}km`;
        }
    }

    function displayDirectionInfo(directionCounts, fromNodeId, toNodeId) {
        const directionDiv = document.getElementById('direction-info');

        // Create formatted node links for the direction display
        const fromNodeLink = createNodeLink(fromNodeId, formatNodeIdForDisplay(fromNodeId));
        const toNodeLink = createNodeLink(toNodeId, formatNodeIdForDisplay(toNodeId));

        let html = `<strong>Link Analysis:</strong> `;
        html += `${fromNodeLink} â†” ${toNodeLink}<br>`;

        const directions = Object.keys(directionCounts);
        if (directions.length > 1) {
            html += '<span class="badge bg-success signal-badge">Bidirectional Link</span>';
        } else if (directions.length === 1) {
            html += '<span class="badge bg-warning signal-badge">Unidirectional Link</span>';
        } else {
            html += '<span class="badge bg-secondary signal-badge">No Data</span>';
        }

        // Show traffic distribution if bidirectional
        if (directions.length > 1) {
            html += '<br><small class="text-muted mt-1 d-block">';
            directions.forEach(direction => {
                const count = directionCounts[direction];
                const percentage = (count / Object.values(directionCounts).reduce((a, b) => a + b, 0) * 100).toFixed(1);
                html += `${direction}: ${count} traceroutes (${percentage}%)<br>`;
            });
            html += '</small>';
        }

        directionDiv.innerHTML = html;
    }

    function updateSNRChart(traceroutes) {
        const ctx = document.getElementById('snr-chart').getContext('2d');

        if (snrChart) {
            snrChart.destroy();
            snrChart = null;
        }

        const data = traceroutes
            .filter(tr => tr.hop_snr !== null)
            .map(tr => ({
                x: tr.timestamp_str,
                y: tr.hop_snr
            }))
            .reverse(); // Show most recent first

        snrChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.map(d => d.x),
                datasets: [{
                    label: 'SNR (dB)',
                    data: data.map(d => d.y),
                    borderColor: '#0d6efd',
                    backgroundColor: 'rgba(13, 110, 253, 0.1)',
                    tension: 0.1,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        ticks: {
                            maxTicksLimit: 10,
                            callback: function(value, index, values) {
                                // Show only every nth label to avoid crowding
                                const step = Math.ceil(data.length / 8);
                                return index % step === 0 ? this.getLabelForValue(value) : '';
                            }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'SNR (dB)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                return data[context[0].dataIndex].x;
                            }
                        }
                    }
                }
            }
        });
    }

    function updateDirectionChart(directionCounts) {
        const ctx = document.getElementById('direction-chart').getContext('2d');

        if (directionChart) {
            directionChart.destroy();
            directionChart = null;
        }

        const labels = Object.keys(directionCounts);
        const data = Object.values(directionCounts);

        directionChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: [
                        '#0d6efd',
                        '#6f42c1',
                        '#20c997',
                        '#fd7e14'
                    ]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }

    function displayTracerouteList(traceroutes, fromNodeName, toNodeName) {
        const listDiv = document.getElementById('traceroute-list');

        if (traceroutes.length === 0) {
            listDiv.innerHTML = '<p class="text-muted">No traceroutes found.</p>';
            return;
        }

        let html = '';
        traceroutes.forEach((tr, index) => {
            const snrBadgeClass = getSNRBadgeClass(tr.hop_snr);
            const snrText = tr.hop_snr !== null ? `${tr.hop_snr.toFixed(1)} dB` : 'N/A';

            // Create route display using structured data
            let routeDisplay = '';
            if (tr.route_hops && tr.route_hops.length > 0) {
                // Filter out the last hop if it has no SNR (indicating it's incomplete)
                const hopsToShow = tr.route_hops.filter((hop, hopIndex) => {
                    // If this is the last hop and it has no SNR, it's likely incomplete
                    if (hopIndex === tr.route_hops.length - 1 && (hop.snr === null || hop.snr === undefined)) {
                        return false; // Exclude incomplete final hop
                    }
                    return true;
                });

                routeDisplay = '<div class="table-responsive"><table class="table table-sm table-borderless mb-0" style="font-size: 0.85em;">';
                routeDisplay += '<thead><tr class="text-muted" style="font-size: 0.75em;">';
                routeDisplay += '<th style="width: 12%;">Hop</th>';
                routeDisplay += '<th style="width: 30%;">From</th>';
                routeDisplay += '<th style="width: 30%;">To</th>';
                routeDisplay += '<th style="width: 13%;">SNR</th>';
                routeDisplay += '<th style="width: 15%;">Direction</th>';
                routeDisplay += '</tr></thead><tbody>';

                hopsToShow.forEach(hop => {
                    const rowClass = hop.is_target_hop ? 'table-primary' : '';
                    const fontWeight = hop.is_target_hop ? 'font-weight: bold; color: #0d6efd;' : '';

                    let snrDisplay = 'â€”';
                    if (hop.snr !== null && hop.snr !== undefined) {
                        const snrClass = hop.snr >= 0 ? 'text-success' : 'text-danger';
                        snrDisplay = `<span class="${snrClass}">${hop.snr.toFixed(1)}</span>`;
                    }

                    // Create node links with proper formatting
                    const fromNodeLink = createNodeLink(hop.from_node_id, hop.from_node_name);
                    const toNodeLink = createNodeLink(hop.to_node_id, hop.to_node_name);

                    // Format direction display
                    let directionDisplay = 'â€”';
                    if (hop.direction) {
                        if (hop.direction === 'forward_rf') {
                            directionDisplay = '<span class="badge bg-primary" style="font-size: 0.7em;">Forward</span>';
                        } else if (hop.direction === 'return_rf') {
                            directionDisplay = '<span class="badge bg-success" style="font-size: 0.7em;">Return</span>';
                        } else {
                            directionDisplay = `<span class="badge bg-secondary" style="font-size: 0.7em;">${hop.direction}</span>`;
                        }
                    }

                    routeDisplay += `<tr class="${rowClass}">`;
                    routeDisplay += `<td><small class="text-muted">#${hop.hop_number}</small></td>`;
                    routeDisplay += `<td style="${fontWeight}"><small>${fromNodeLink}</small></td>`;
                    routeDisplay += `<td style="${fontWeight}"><small>${toNodeLink}</small></td>`;
                    routeDisplay += `<td><small>${snrDisplay}</small></td>`;
                    routeDisplay += `<td><small>${directionDisplay}</small></td>`;
                    routeDisplay += '</tr>';
                });

                // Add warning row if we filtered out incomplete hops
                if (hopsToShow.length < tr.route_hops.length) {
                    const filteredHop = tr.route_hops[tr.route_hops.length - 1];
                    const destinationNodeLink = createNodeLink(filteredHop.to_node_id, filteredHop.to_node_name, false);
                    routeDisplay += `<tr class="table-warning">`;
                    routeDisplay += `<td colspan="5" class="text-center" style="font-size: 0.8em;">`;
                    routeDisplay += `<i class="bi bi-exclamation-triangle"></i> `;
                    routeDisplay += `<strong>Incomplete</strong> - Last hop to ${destinationNodeLink} not confirmed`;
                    routeDisplay += `</td></tr>`;
                }

                routeDisplay += '</tbody></table></div>';
            } else {
                // Fallback to complete_path_display if route_hops not available
                routeDisplay = tr.complete_path_display || 'Route data unavailable';
            }

            html += `
                <div class="card mb-2">
                    <div class="card-body p-3">
                        <div class="row align-items-center">
                            <div class="col-md-8">
                                <div class="d-flex align-items-center">
                                    <span class="badge ${snrBadgeClass} me-2">${snrText}</span>
                                    <small class="text-muted">${getRelativeTime(tr.timestamp)}</small>
                                </div>
                            </div>
                            <div class="col-md-4 text-md-end">
                                <div class="d-flex flex-column align-items-end">
                                    <small class="text-muted mb-1">
                                        <strong>From:</strong> ${createNodeLink(tr.from_node_id, tr.from_node_name)}
                                        ${tr.gateway_node_name ? `(via ${tr.gateway_node_name})` : ''}
                                    </small>
                                    <small class="text-muted mb-1">
                                        <strong>To:</strong> ${createNodeLink(tr.to_node_id, tr.to_node_name)}
                                    </small>
                                    ${tr.id ? `<a href="/packet/${tr.id}" class="btn btn-sm btn-outline-primary" title="View packet details">
                                        <i class="bi bi-info-circle"></i> Packet Details
                                    </a>` : ''}
                                </div>
                            </div>
                        </div>
                        <div class="mt-2">
                            ${routeDisplay}
                        </div>
                    </div>
                </div>
            `;
        });

        listDiv.innerHTML = html;

        // Re-initialize tooltips for the new content
        reinitializeTooltips();
    }

    function getSNRBadgeClass(snr) {
        if (snr === null || snr === undefined) return 'bg-secondary';
        if (snr >= 5) return 'bg-success';
        if (snr >= 0) return 'bg-warning';
        return 'bg-danger';
    }

    function getRelativeTime(timestamp) {
        const now = Date.now() / 1000;
        const diff = now - timestamp;

        if (diff < 60) return 'Just now';
        if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
        return `${Math.floor(diff / 86400)}d ago`;
    }

    // =====================================================================
    // Hop Distribution Visualization (Plotly)
    // =====================================================================

    let hopDistributionData = null;

    async function loadHopDistribution() {
        const loadingEl = document.getElementById('hop-distribution-loading');
        const contentEl = document.getElementById('hop-distribution-content');
        const emptyEl = document.getElementById('hop-distribution-empty');

        loadingEl.style.display = 'block';
        contentEl.style.display = 'none';
        emptyEl.style.display = 'none';

        try {
            // Use the new distribution API that analyzes actual traceroute data
            const response = await fetch('/api/traceroute-hops/distribution');
            if (!response.ok) {
                throw new Error('Failed to fetch hop distribution');
            }

            const data = await response.json();

            if (data.nodes && data.nodes.length > 0) {
                hopDistributionData = data;
                renderHopDistributionChart(data);
                renderHopNodeList(data);
                document.getElementById('traceroute-count').textContent = data.total_traceroutes || 0;
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';
            } else {
                loadingEl.style.display = 'none';
                emptyEl.style.display = 'block';
            }
        } catch (error) {
            console.error('Error loading hop distribution:', error);
            loadingEl.style.display = 'none';
            emptyEl.style.display = 'block';
        }
    }

    function renderHopDistributionChart(data) {
        const chartDiv = document.getElementById('hop-distribution-chart');
        const isDarkMode = document.documentElement.getAttribute('data-bs-theme') === 'dark';

        // Prepare data for scatter plot - each node as a point
        const nodes = data.nodes || [];

        // Group by hop count for coloring
        const hopColors = {
            0: '#198754',  // Green - Gateway/Source
            1: '#0d6efd',  // Blue
            2: '#6f42c1',  // Purple
            3: '#fd7e14',  // Orange
            4: '#dc3545',  // Red
            5: '#6c757d'   // Gray for 5+
        };

        // Create traces for each hop group
        const traces = [];
        const distribution = data.distribution || [];

        distribution.forEach((group, groupIdx) => {
            const hopCount = group.hop_count;
            const groupNodes = data.nodes.filter(n => {
                if (hopCount === '5+') return n.min_hops >= 5;
                return n.min_hops === parseInt(hopCount);
            });

            if (groupNodes.length === 0) return;

            // Add jitter to x positions for better visualization
            const xValues = groupNodes.map((n, i) => {
                const baseX = hopCount === '5+' ? 5 : parseInt(hopCount);
                const jitter = (Math.random() - 0.5) * 0.6;
                return baseX + jitter;
            });

            // Y values based on observation count (activity level)
            const yValues = groupNodes.map(n => n.observations);

            // Size based on observations (normalized)
            const maxObs = Math.max(...nodes.map(n => n.observations));
            const sizes = groupNodes.map(n => Math.max(8, Math.min(30, (n.observations / maxObs) * 25 + 8)));

            const colorIdx = hopCount === '5+' ? 5 : parseInt(hopCount);

            traces.push({
                type: 'scatter',
                mode: 'markers',
                name: hopCount === '0' ? 'Gateway (0 hops)' : hopCount === '5+' ? '5+ Hops' : `${hopCount} Hop${hopCount === '1' ? '' : 's'}`,
                x: xValues,
                y: yValues,
                text: groupNodes.map(n => `${n.display_name}<br>Min Hops: ${n.min_hops}<br>Max Hops: ${n.max_hops}<br>Observations: ${n.observations}`),
                hovertemplate: '%{text}<extra></extra>',
                marker: {
                    size: sizes,
                    color: hopColors[colorIdx],
                    opacity: 0.7,
                    line: {
                        color: isDarkMode ? '#ffffff' : '#000000',
                        width: 1
                    }
                },
                customdata: groupNodes.map(n => n.node_id)
            });
        });

        // Add a bar chart overlay showing distribution
        const barTrace = {
            type: 'bar',
            name: 'Node Count',
            x: distribution.map(d => d.hop_count === '5+' ? 5 : parseInt(d.hop_count)),
            y: distribution.map(d => d.node_count),
            marker: {
                color: distribution.map(d => {
                    const idx = d.hop_count === '5+' ? 5 : parseInt(d.hop_count);
                    return hopColors[idx];
                }),
                opacity: 0.3
            },
            yaxis: 'y2',
            hovertemplate: '%{y} nodes at %{x} hops<extra></extra>',
            showlegend: false
        };

        const layout = {
            title: {
                text: `Hop Distribution (${data.total_nodes} nodes)`,
                font: { size: 16, color: isDarkMode ? '#ffffff' : '#000000' }
            },
            xaxis: {
                title: 'Hop Distance from Source',
                tickmode: 'array',
                tickvals: [0, 1, 2, 3, 4, 5],
                ticktext: ['0 (Gateway)', '1', '2', '3', '4', '5+'],
                gridcolor: isDarkMode ? '#444' : '#ddd',
                zerolinecolor: isDarkMode ? '#666' : '#ccc',
                color: isDarkMode ? '#ffffff' : '#000000'
            },
            yaxis: {
                title: 'Traceroute Observations',
                gridcolor: isDarkMode ? '#444' : '#ddd',
                zerolinecolor: isDarkMode ? '#666' : '#ccc',
                color: isDarkMode ? '#ffffff' : '#000000'
            },
            yaxis2: {
                title: 'Node Count',
                overlaying: 'y',
                side: 'right',
                showgrid: false,
                color: isDarkMode ? '#aaaaaa' : '#666666'
            },
            paper_bgcolor: isDarkMode ? '#212529' : '#ffffff',
            plot_bgcolor: isDarkMode ? '#2d3238' : '#f8f9fa',
            font: { color: isDarkMode ? '#ffffff' : '#000000' },
            legend: {
                orientation: 'h',
                y: -0.15,
                x: 0.5,
                xanchor: 'center',
                font: { size: 10 }
            },
            margin: { t: 50, b: 80, l: 60, r: 60 },
            hovermode: 'closest'
        };

        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['select2d', 'lasso2d'],
            displaylogo: false
        };

        Plotly.newPlot(chartDiv, [barTrace, ...traces], layout, config);

        // Add click handler to select nodes
        chartDiv.on('plotly_click', function(eventData) {
            if (eventData.points && eventData.points.length > 0) {
                const point = eventData.points[0];
                if (point.customdata) {
                    selectNodeForAnalysis(point.customdata);
                }
            }
        });
    }

    function renderHopNodeList(data) {
        const container = document.getElementById('hop-node-groups');
        const distribution = data.distribution || [];

        const hopLabels = {
            '0': 'ðŸŸ¢ Gateway (0 hops)',
            '1': 'ðŸ”µ 1 Hop',
            '2': 'ðŸŸ£ 2 Hops',
            '3': 'ðŸŸ  3 Hops',
            '4': 'ðŸ”´ 4 Hops',
            '5+': 'â¬› 5+ Hops'
        };

        let html = '';

        distribution.forEach(group => {
            const hopCount = group.hop_count;
            const nodeCount = group.node_count;
            const nodes = group.nodes || [];

            if (nodeCount === 0) return;

            html += `
                <div class="hop-group mb-2">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <small class="fw-bold">${hopLabels[hopCount] || hopCount + ' Hops'}</small>
                        <span class="badge bg-secondary">${nodeCount}</span>
                    </div>
                    <div class="hop-nodes-list">
                        ${nodes.map(n => `
                            <div class="hop-node-item d-flex justify-content-between align-items-center"
                                 onclick="selectNodeForAnalysis(${n.node_id})"
                                 title="${n.hex_id} - ${n.observations} observations"
                                 style="cursor: pointer; padding: 4px 8px; border-radius: 4px; margin-bottom: 2px; background: var(--bs-body-bg);">
                                <span style="font-size: 0.8rem;">${truncateName(n.display_name, 18)}</span>
                                <span class="badge bg-primary" style="font-size: 0.65rem;">${n.observations}</span>
                            </div>
                        `).join('')}
                        ${nodeCount > nodes.length ? `
                            <div class="text-center text-muted" style="font-size: 0.7rem;">+${nodeCount - nodes.length} more</div>
                        ` : ''}
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
    }

    function truncateName(name, maxLen) {
        if (!name) return '?';
        if (name.length <= maxLen) return name;
        return name.substring(0, maxLen - 1) + 'â€¦';
    }

    function selectNodeForAnalysis(nodeId) {
        // Set the first node picker to this node and load related nodes
        const node1Input = document.getElementById('node1-select_value');
        const node1Display = document.getElementById('node1-select');

        const node = availableNodes.find(n => n.node_id == nodeId);
        if (node) {
            node1Input.value = nodeId;
            node1Display.value = node.display_name;
            updateNodeInfo('node1', nodeId);
            loadRelatedNodes(nodeId);
            checkAnalyzeButton();

            // Scroll to the node selection section
            document.querySelector('.node-selector').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    // Load hop distribution on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadHopDistribution();
    });
</script>
{% endblock %}
