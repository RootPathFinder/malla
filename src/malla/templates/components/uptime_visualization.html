{#
    7-Day Availability Visualization Component - Compact Version

    Parameters:
        - container_id: Unique ID for this visualization container
        - node_id: Node ID to fetch uptime data for
        - days: Number of days to show (default: 7)
        - show_labels: Whether to show time block labels (default: true)
#}

<style>
    .uptime-compact {
        background: var(--bs-body-bg);
        border-radius: 6px;
    }

    .uptime-compact .uptime-row {
        display: flex;
        align-items: flex-start;
        gap: 4px;
    }

    .uptime-compact .uptime-days {
        display: flex;
        gap: 4px;
        flex: 1;
    }

    .uptime-compact .uptime-day {
        flex: 1;
        min-width: 0;
    }

    .uptime-compact .uptime-day-blocks {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .uptime-compact .uptime-block {
        height: 8px;
        border-radius: 2px;
        transition: opacity 0.15s, transform 0.15s;
        cursor: help;
    }

    .uptime-compact .uptime-block:hover {
        opacity: 0.85;
        transform: scaleY(1.3);
    }

    .uptime-compact .uptime-block.available {
        background: #198754;
    }

    .uptime-compact .uptime-block.degraded {
        background: #ffc107;
    }

    .uptime-compact .uptime-block.unavailable {
        background: #dc3545;
    }

    .uptime-compact .uptime-block.future {
        background: var(--bs-secondary);
        opacity: 0.25;
        cursor: default;
    }

    .uptime-compact .uptime-block.future:hover {
        transform: none;
    }

    .uptime-compact .uptime-day-label {
        text-align: center;
        font-size: 0.6rem;
        color: var(--bs-secondary);
        margin-top: 4px;
        line-height: 1.2;
    }

    .uptime-compact .uptime-day-label .day-name {
        font-weight: 600;
    }

    .uptime-compact .uptime-day-label .day-date {
        opacity: 0.75;
        font-size: 0.55rem;
    }

    .uptime-compact .uptime-day.today .uptime-day-label .day-name {
        color: var(--bs-primary);
    }

    .uptime-compact .uptime-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 10px;
        padding-top: 8px;
        border-top: 1px solid var(--bs-border-color-translucent);
        font-size: 0.7rem;
        color: var(--bs-secondary);
    }

    .uptime-compact .uptime-pct {
        font-weight: 700;
        font-size: 0.8rem;
    }

    .uptime-compact .uptime-pct.good { color: #198754; }
    .uptime-compact .uptime-pct.warn { color: #fd7e14; }
    .uptime-compact .uptime-pct.bad { color: #dc3545; }

    .uptime-compact .uptime-legend {
        display: flex;
        gap: 10px;
        font-size: 0.6rem;
    }

    .uptime-compact .uptime-legend-item {
        display: flex;
        align-items: center;
        gap: 3px;
    }

    .uptime-compact .uptime-legend-dot {
        width: 8px;
        height: 8px;
        border-radius: 2px;
    }

    .uptime-compact .uptime-legend-dot.available { background: #198754; }
    .uptime-compact .uptime-legend-dot.degraded { background: #ffc107; }
    .uptime-compact .uptime-legend-dot.unavailable { background: #dc3545; }
</style>

<div id="{{ container_id }}" class="uptime-compact">
    <div class="text-center text-muted py-2">
        <div class="spinner-border spinner-border-sm" role="status"></div>
        <small class="ms-2">Loading...</small>
    </div>
</div>

<script>
(function() {
    const containerId = '{{ container_id }}';
    const nodeId = '{{ node_id }}';
    const days = {{ days if days else 7 }};

    function loadUptime() {
        // Check if telemetry data is already available from node detail page
        if (window.telemetryHistory7d && Object.keys(window.telemetryHistory7d).length > 0) {
            renderFromTelemetry(window.telemetryHistory7d);
        } else {
            // Wait a bit for telemetry data to be loaded, then check again
            setTimeout(() => {
                if (window.telemetryHistory7d && Object.keys(window.telemetryHistory7d).length > 0) {
                    renderFromTelemetry(window.telemetryHistory7d);
                } else {
                    // Fetch telemetry history directly
                    fetchTelemetryHistory();
                }
            }, 1500);
        }
    }

    async function fetchTelemetryHistory() {
        try {
            const response = await fetch(`/api/node/${nodeId}/telemetry/history?hours=${days * 24}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            if (data.error || !data.history || Object.keys(data.history).length === 0) {
                document.getElementById(containerId).innerHTML = `
                    <div class="text-muted small"><i class="bi bi-info-circle"></i> No telemetry data available</div>`;
                return;
            }
            renderFromTelemetry(data.history);
        } catch (e) {
            document.getElementById(containerId).innerHTML = `
                <div class="text-muted small"><i class="bi bi-exclamation-triangle"></i> Unable to load availability data</div>`;
        }
    }

    function renderFromTelemetry(history) {
        const container = document.getElementById(containerId);

        // Collect all timestamps from all metric types
        const allTimestamps = [];
        Object.values(history).forEach(metricData => {
            if (Array.isArray(metricData)) {
                metricData.forEach(point => {
                    if (point.x) allTimestamps.push(point.x);
                });
            }
        });

        if (allTimestamps.length === 0) {
            container.innerHTML = `<div class="text-muted small"><i class="bi bi-info-circle"></i> No telemetry data</div>`;
            return;
        }

        // Get timezone preference
        const tzPref = typeof getTimezonePreference === 'function' ? getTimezonePreference() : 'local';
        const now = new Date();

        // Calculate today's date string based on timezone preference
        let todayStr;
        let currentHour;
        if (tzPref === 'utc') {
            todayStr = now.toISOString().split('T')[0];
            currentHour = now.getUTCHours();
        } else {
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            todayStr = `${year}-${month}-${day}`;
            currentHour = now.getHours();
        }

        // Build daily summary from telemetry timestamps
        // Divide each day into 4 periods (6-hour blocks)
        const dailySummary = [];
        const startOfToday = tzPref === 'utc'
            ? new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()))
            : new Date(now.getFullYear(), now.getMonth(), now.getDate());

        for (let d = days - 1; d >= 0; d--) {
            const dayStart = new Date(startOfToday.getTime() - d * 24 * 60 * 60 * 1000);
            const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);

            // Get date string for this day
            let dateStr;
            if (tzPref === 'utc') {
                dateStr = dayStart.toISOString().split('T')[0];
            } else {
                const year = dayStart.getFullYear();
                const month = String(dayStart.getMonth() + 1).padStart(2, '0');
                const dayNum = String(dayStart.getDate()).padStart(2, '0');
                dateStr = `${year}-${month}-${dayNum}`;
            }

            // Count telemetry in each 6-hour period
            const periods = [];
            for (let p = 0; p < 4; p++) {
                const periodStart = dayStart.getTime() + p * 6 * 60 * 60 * 1000;
                const periodEnd = periodStart + 6 * 60 * 60 * 1000;

                const pointsInPeriod = allTimestamps.filter(ts => ts >= periodStart && ts < periodEnd);
                const hasData = pointsInPeriod.length > 0;

                periods.push({
                    startHour: p * 6,
                    hasData: hasData,
                    dataPoints: pointsInPeriod.length
                });
            }

            // Calculate day availability based on periods with data
            const periodsWithData = periods.filter(p => p.hasData).length;
            const uptimePct = Math.round((periodsWithData / 4) * 100);

            dailySummary.push({
                date: dateStr,
                periods: periods,
                uptime_percentage: uptimePct
            });
        }

        // Calculate overall uptime percentage
        const totalPeriods = dailySummary.reduce((sum, day) => sum + 4, 0);
        const availablePeriods = dailySummary.reduce((sum, day) =>
            sum + day.periods.filter(p => p.hasData).length, 0);
        const overallUptime = Math.round((availablePeriods / totalPeriods) * 100);

        // Render the visualization
        render(dailySummary, overallUptime, todayStr, currentHour, tzPref);
    }

    function render(dailySummary, overallUptime, todayStr, currentHour, tzPref) {
        const container = document.getElementById(containerId);
        const tzOption = tzPref === 'utc' ? 'UTC' : undefined;

        // Build compact visualization - 4 blocks per day (6-hour periods)
        let html = '<div class="uptime-row"><div class="uptime-days">';

        dailySummary.forEach(day => {
            const dayDate = new Date(day.date + 'T12:00:00Z');
            const dayName = dayDate.toLocaleDateString(undefined, { weekday: 'short', timeZone: tzOption });
            const monthDay = dayDate.toLocaleDateString(undefined, { month: 'numeric', day: 'numeric', timeZone: tzOption });
            const isToday = day.date === todayStr;

            const periodLabels = ['12am-6am', '6am-12pm', '12pm-6pm', '6pm-12am'];

            html += `<div class="uptime-day${isToday ? ' today' : ''}">`;
            html += '<div class="uptime-day-blocks">';

            day.periods.forEach((period, idx) => {
                // Determine if this period is in the future (for today)
                const isFuture = isToday && period.startHour > currentHour;

                let status;
                if (isFuture) {
                    status = 'future';
                } else if (period.hasData) {
                    status = 'available';
                } else {
                    status = 'unavailable';
                }

                const tooltip = isFuture ? `${periodLabels[idx]}: Future` :
                    period.hasData ? `${dayName} ${monthDay} ${periodLabels[idx]}: ${period.dataPoints} telemetry points` :
                    `${dayName} ${monthDay} ${periodLabels[idx]}: No data`;

                html += `<div class="uptime-block ${status}" title="${tooltip}"></div>`;
            });

            html += '</div>';
            html += `<div class="uptime-day-label">`;
            html += `<div class="day-name">${isToday ? 'Today' : dayName}</div>`;
            html += `<div class="day-date">${monthDay}</div>`;
            html += '</div></div>';
        });

        html += '</div></div>';

        // Footer with percentage and legend
        const pct = overallUptime;
        const pctClass = pct >= 80 ? 'good' : pct >= 50 ? 'warn' : 'bad';

        html += `<div class="uptime-footer">`;
        html += `<span class="uptime-pct ${pctClass}">${pct}% availability</span>`;
        html += `<div class="uptime-legend">`;
        html += `<span class="uptime-legend-item"><span class="uptime-legend-dot available"></span>Data</span>`;
        html += `<span class="uptime-legend-item"><span class="uptime-legend-dot unavailable"></span>No Data</span>`;
        html += `</div></div>`;

        container.innerHTML = html;

        // Initialize tooltips
        container.querySelectorAll('[title]').forEach(el => {
            new bootstrap.Tooltip(el, { placement: 'top' });
        });
    }

    // Auto-load when document is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadUptime);
    } else {
        loadUptime();
    }
})();
</script>
