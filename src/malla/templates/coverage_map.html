{% extends "base.html" %}
{% from "macros.html" import node_picker %}

{% block title %}Coverage Map Builder - Malla{% endblock %}

{% block head_libs %}
<!-- Chart.js for visualizations -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" integrity="sha384-e6nUZLBkQ86NJ6TVVKAeSaK8jWa3NhkYWZFomE39AvDbQWeie9PlQqM3pmYW5d1g" crossorigin="anonymous"></script>
{% endblock head_libs %}

{% block extra_css %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""/>

<link rel="stylesheet" href="{{ url_for('static', filename='css/node-picker.css') }}">
<style>
    #coverage-map {
        height: 600px;
        border-radius: 8px;
        border: 1px solid var(--bs-border-color);
        z-index: 1;
        position: relative;
    }

    @media (max-width: 768px) {
        #coverage-map {
            height: 450px;
        }
    }

    .control-panel {
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-radius: 8px;
        padding: 1rem;
    }

    .node-list-container {
        max-height: 300px;
        overflow-y: auto;
    }

    .coverage-node-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem;
        border-bottom: 1px solid var(--bs-border-color);
        transition: background 0.15s;
    }

    .coverage-node-item:hover {
        background: var(--bs-tertiary-bg);
    }

    .coverage-node-item:last-child {
        border-bottom: none;
    }

    .coverage-node-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        flex-shrink: 0;
    }

    .coverage-node-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .coverage-node-actions {
        display: flex;
        gap: 0.25rem;
    }

    .coverage-node-actions button {
        padding: 0.125rem 0.375rem;
        font-size: 0.75rem;
    }

    .map-mode-indicator {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: var(--bs-warning);
        color: var(--bs-dark);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        font-weight: 600;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        display: none;
    }

    .map-mode-indicator.active {
        display: block;
        animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .attribution-box {
        background-color: var(--bs-light);
        border-left: 4px solid #0d6efd;
        padding: 1rem;
        margin-top: 1rem;
    }

    .attribution-box h6 {
        color: #0d6efd;
        font-weight: 600;
        margin-bottom: 0.5rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.25rem;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid var(--bs-border-color);
    }

    .status-badge {
        font-size: 0.875rem;
    }

    /* Node picker z-index fix */
    .card.mb-3 {
        position: relative;
        z-index: 1100;
    }

    .node-picker-dropdown {
        z-index: 1200 !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <h1><i class="bi bi-reception-4"></i> Coverage Map Builder</h1>
        <p class="text-muted">Build a multi-node RF coverage map using terrain-aware line-of-sight analysis. Add nodes from the mesh or place custom markers to visualize combined coverage.</p>
    </div>
</div>

<div class="row">
    <!-- Left Panel - Controls -->
    <div class="col-lg-4 col-xl-3 mb-3">
        <!-- Add Node Section -->
        <div class="card mb-3">
            <div class="card-header">
                <h6 class="mb-0"><i class="bi bi-plus-circle"></i> Add Node</h6>
            </div>
            <div class="card-body">
                <!-- Add from mesh -->
                <div class="mb-3">
                    {{ node_picker('mesh_node', field_id='meshNodeSearch', label='From Mesh Network',
                                  placeholder='Search nodes by name or ID...',
                                  required=false) }}
                    <button class="btn btn-primary btn-sm w-100 mt-2" id="addMeshNodeBtn" disabled>
                        <i class="bi bi-plus"></i> Add Selected Node
                    </button>
                </div>

                <hr>

                <!-- Add custom marker -->
                <div class="mb-2">
                    <label class="form-label small fw-bold">Custom Location</label>
                    <button class="btn btn-outline-secondary btn-sm w-100" id="addCustomMarkerBtn">
                        <i class="bi bi-geo-alt-fill"></i> Click Map to Add
                    </button>
                </div>
                <small class="text-muted d-block">Click on the map to place a custom transmitter location.</small>
            </div>
        </div>

        <!-- Settings -->
        <div class="card mb-3">
            <div class="card-header">
                <h6 class="mb-0"><i class="bi bi-gear"></i> Analysis Settings</h6>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label class="form-label small" id="coverageRadiusLabel">Analysis Radius (30dB LoRa ~15km)</label>
                    <select class="form-select form-select-sm" id="coverageRadius">
                        <!-- Populated by JS -->
                    </select>
                </div>

                <div class="mb-3">
                    <label class="form-label small">Resolution (rays)</label>
                    <select class="form-select form-select-sm" id="coverageResolution">
                        <option value="16">Low (16 rays) - Fast</option>
                        <option value="24">Medium (24 rays)</option>
                        <option value="36" selected>High (36 rays)</option>
                        <option value="72">Very High (72 rays) - Slow</option>
                    </select>
                </div>

                <div class="mb-3">
                    <label class="form-label small">Default Antenna Height (m)</label>
                    <input type="number" class="form-control form-control-sm" id="antennaHeight"
                           value="10" min="0" max="500" step="1">
                </div>

                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="useNodeAltitude" checked>
                    <label class="form-check-label small" for="useNodeAltitude">
                        Use node reported altitude
                    </label>
                </div>

                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="showOverlap" checked>
                    <label class="form-check-label small" for="showOverlap">
                        Show coverage overlap
                    </label>
                </div>
            </div>
        </div>

        <!-- Node List -->
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h6 class="mb-0"><i class="bi bi-list-ul"></i> Coverage Nodes (<span id="nodeCount">0</span>)</h6>
                <button class="btn btn-outline-danger btn-sm" id="clearAllBtn" style="display: none;">
                    <i class="bi bi-trash"></i> Clear All
                </button>
            </div>
            <div class="card-body p-0">
                <div class="node-list-container" id="nodeListContainer">
                    <div class="text-center text-muted py-4">
                        <i class="bi bi-inbox display-6"></i>
                        <p class="mb-0 mt-2">No nodes added yet</p>
                        <small>Add nodes from the mesh or click the map</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calculate Button -->
        <button class="btn btn-success btn-lg w-100" id="calculateBtn" disabled>
            <i class="bi bi-play-fill"></i> Calculate Coverage
        </button>

        <!-- Status -->
        <div id="statusMessage" class="alert mt-3" style="display: none;"></div>
    </div>

    <!-- Right Panel - Map -->
    <div class="col-lg-8 col-xl-9">
        <div class="card">
            <div class="card-body p-0 position-relative">
                <div id="mapModeIndicator" class="map-mode-indicator">
                    <i class="bi bi-crosshair"></i> Click on map to place node
                    <button class="btn btn-sm btn-outline-dark ms-2" id="cancelPlacementBtn">Cancel</button>
                </div>
                <div id="coverage-map"></div>
            </div>
        </div>

        <!-- Legend -->
        <div class="card mt-3">
            <div class="card-body">
                <h6 class="mb-3"><i class="bi bi-palette"></i> Legend</h6>
                <div class="row">
                    <div class="col-md-6">
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(34, 197, 94, 0.45); border-color: #15803d;"></div>
                            <span>Line-of-sight coverage (Fresnel zone clear)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(234, 179, 8, 0.45); border-color: #a16207;"></div>
                            <span>Coverage overlap (multiple nodes)</span>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #15803d;"></div>
                            <span>Mesh node location</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #1d4ed8;"></div>
                            <span>Custom node location</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Attribution -->
        <div class="attribution-box">
            <h6><i class="bi bi-award"></i> Data Attribution</h6>
            <ul class="mb-0 small">
                <li><strong>Elevation Data</strong> - DEM Net Elevation API (<a href="https://elevationapi.com" target="_blank" rel="noopener">elevationapi.com</a>)</li>
                <li><strong>Map Tiles</strong> - © <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a> contributors,
                    © <a href="https://www.stadiamaps.com/" target="_blank" rel="noopener">Stadia Maps</a>,
                    © <a href="https://www.stamen.com/" target="_blank" rel="noopener">Stamen Design</a></li>
                <li><strong>Terrain Data</strong> - SRTM (Shuttle Radar Topography Mission)</li>
            </ul>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>

<!-- Location Cache -->
<script src="{{ url_for('static', filename='js/location-cache.js') }}"></script>
<script src="{{ url_for('static', filename='js/node-picker.js') }}"></script>

<script>
// Map instance
let map = null;

// Coverage tracking
let coverageNodes = []; // { id, name, lat, lng, altitude, type: 'mesh'|'custom', marker, coverageLayer, color }
let nodeIdCounter = 0;
let placementMode = false;

// Color palette for coverage areas (brighter, more visible colors)
const coverageColors = [
    { fill: 'rgba(34, 197, 94, 0.45)', stroke: '#15803d', name: 'Green' },     // Brighter green
    { fill: 'rgba(59, 130, 246, 0.45)', stroke: '#1d4ed8', name: 'Blue' },     // Brighter blue
    { fill: 'rgba(236, 72, 153, 0.45)', stroke: '#be185d', name: 'Pink' },     // Brighter pink
    { fill: 'rgba(249, 115, 22, 0.45)', stroke: '#c2410c', name: 'Orange' },   // Brighter orange
    { fill: 'rgba(168, 85, 247, 0.45)', stroke: '#7e22ce', name: 'Purple' },   // Brighter purple
    { fill: 'rgba(20, 184, 166, 0.45)', stroke: '#0f766e', name: 'Teal' },     // Brighter teal
    { fill: 'rgba(234, 179, 8, 0.45)', stroke: '#a16207', name: 'Yellow' },    // Brighter yellow
    { fill: 'rgba(6, 182, 212, 0.45)', stroke: '#0e7490', name: 'Cyan' },      // Brighter cyan
];

// Coverage styling settings
const COVERAGE_FILL_OPACITY = 0.45;
const COVERAGE_STROKE_OPACITY = 0.9;
const COVERAGE_STROKE_WEIGHT = 3;

// Coverage radius options (km)
const coverageRadiusOptionsKm = [
    { km: 5, label_km: '5 km (urban/hilly)', label_mi: '3 mi (urban/hilly)' },
    { km: 10, label_km: '10 km (suburban)', label_mi: '6 mi (suburban)' },
    { km: 15, label_km: '15 km (typical 30dB)', label_mi: '10 mi (typical 30dB)', default: true },
    { km: 20, label_km: '20 km (good LOS)', label_mi: '12 mi (good LOS)' },
    { km: 30, label_km: '30 km (elevated)', label_mi: '19 mi (elevated)' },
    { km: 50, label_km: '50 km (high sites)', label_mi: '31 mi (high sites)' },
];

// Node picker instance
let meshNodePicker = null;

// Initialize on page load
document.addEventListener('DOMContentLoaded', async function() {
    // Initialize map
    initializeMap();

    // Load caches
    await Promise.all([
        window.NodeCache.load(),
        window.LocationCache.load()
    ]);

    // Initialize node picker
    initializeNodePicker();

    // Populate radius dropdown
    updateCoverageRadiusOptions();

    // Set up event listeners
    setupEventListeners();
});

// Initialize the map
function initializeMap() {
    map = L.map('coverage-map').setView([40.4168, -3.7038], 6);

    // Stamen Terrain (via Stadia Maps)
    L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'png'
    }).addTo(map);

    // Map click handler
    map.on('click', handleMapClick);
}

// Initialize node picker for mesh nodes
function initializeNodePicker() {
    const container = document.querySelector('#meshNodeSearch').closest('.node-picker-container');
    meshNodePicker = new NodePicker(container);

    // Listen for selection
    document.getElementById('meshNodeSearch_value').addEventListener('change', function() {
        const nodeId = this.value;
        document.getElementById('addMeshNodeBtn').disabled = !nodeId;
    });
}

// Update radius dropdown based on unit preference
function updateCoverageRadiusOptions() {
    const select = document.getElementById('coverageRadius');
    const label = document.getElementById('coverageRadiusLabel');
    const tempUnit = localStorage.getItem('malla-temperature-unit') || 'C';
    const useImperial = (tempUnit === 'F');

    select.innerHTML = '';
    coverageRadiusOptionsKm.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.km;
        option.textContent = useImperial ? opt.label_mi : opt.label_km;
        if (opt.default) option.selected = true;
        select.appendChild(option);
    });

    if (label) {
        label.textContent = useImperial
            ? 'Analysis Radius (30dB LoRa ~10mi)'
            : 'Analysis Radius (30dB LoRa ~15km)';
    }
}

// Set up event listeners
function setupEventListeners() {
    // Add mesh node button
    document.getElementById('addMeshNodeBtn').addEventListener('click', addMeshNode);

    // Custom marker button
    document.getElementById('addCustomMarkerBtn').addEventListener('click', enablePlacementMode);

    // Cancel placement
    document.getElementById('cancelPlacementBtn').addEventListener('click', disablePlacementMode);

    // Clear all
    document.getElementById('clearAllBtn').addEventListener('click', clearAllNodes);

    // Calculate coverage
    document.getElementById('calculateBtn').addEventListener('click', calculateAllCoverage);

    // Listen for temperature unit changes
    document.addEventListener('temperatureUnitChanged', updateCoverageRadiusOptions);
}

// Handle map click
function handleMapClick(e) {
    if (!placementMode) return;

    const { lat, lng } = e.latlng;
    addCustomNode(lat, lng);
    disablePlacementMode();
}

// Enable placement mode
function enablePlacementMode() {
    placementMode = true;
    document.getElementById('mapModeIndicator').classList.add('active');
    map.getContainer().style.cursor = 'crosshair';
}

// Disable placement mode
function disablePlacementMode() {
    placementMode = false;
    document.getElementById('mapModeIndicator').classList.remove('active');
    map.getContainer().style.cursor = '';
}

// Add mesh node from picker
async function addMeshNode() {
    const nodeId = parseInt(document.getElementById('meshNodeSearch_value').value);
    if (!nodeId) return;

    // Check if already added
    if (coverageNodes.some(n => n.meshNodeId === nodeId)) {
        showStatus('warning', 'This node is already added to the coverage map');
        return;
    }

    try {
        const location = await window.LocationCache.getLocation(nodeId);
        if (!location || !location.latitude || !location.longitude) {
            showStatus('error', 'Node does not have location data');
            return;
        }

        const node = await window.NodeCache.getNode(nodeId);
        const name = node?.long_name || node?.short_name || location.node_id_hex || `Node ${nodeId}`;

        const useNodeAltitude = document.getElementById('useNodeAltitude').checked;
        const altitude = useNodeAltitude ? (location.altitude || 0) : 0;

        const colorIndex = coverageNodes.length % coverageColors.length;
        const color = coverageColors[colorIndex];

        const marker = createNodeMarker(location.latitude, location.longitude, name, 'mesh', color.stroke);

        const coverageNode = {
            id: ++nodeIdCounter,
            meshNodeId: nodeId,
            name: name,
            lat: location.latitude,
            lng: location.longitude,
            altitude: altitude,
            type: 'mesh',
            marker: marker,
            coverageLayer: null,
            color: color
        };

        coverageNodes.push(coverageNode);
        updateNodeList();
        updateMapBounds();

        // Clear picker
        document.getElementById('meshNodeSearch').value = '';
        document.getElementById('meshNodeSearch_value').value = '';
        document.getElementById('addMeshNodeBtn').disabled = true;
        if (meshNodePicker.clearButton) {
            meshNodePicker.clearButton.style.display = 'none';
        }

        showStatus('success', `Added ${name} - analyzing terrain...`);

        // Automatically analyze terrain for this node
        await analyzeNodeTerrain(coverageNode.id);

    } catch (error) {
        console.error('Error adding mesh node:', error);
        showStatus('error', 'Failed to add node: ' + error.message);
    }
}

// Add custom node at clicked location
async function addCustomNode(lat, lng) {
    const colorIndex = coverageNodes.length % coverageColors.length;
    const color = coverageColors[colorIndex];
    const customName = `Custom #${coverageNodes.filter(n => n.type === 'custom').length + 1}`;

    const antennaHeight = parseFloat(document.getElementById('antennaHeight').value) || 10;

    const marker = createNodeMarker(lat, lng, customName, 'custom', color.stroke);

    const coverageNode = {
        id: ++nodeIdCounter,
        meshNodeId: null,
        name: customName,
        lat: lat,
        lng: lng,
        altitude: antennaHeight, // Use antenna height as altitude for custom nodes
        type: 'custom',
        marker: marker,
        coverageLayer: null,
        color: color
    };

    coverageNodes.push(coverageNode);
    updateNodeList();

    showStatus('success', `Added custom location - analyzing terrain...`);

    // Automatically analyze terrain for this node
    await analyzeNodeTerrain(coverageNode.id);
}

// Create a node marker
function createNodeMarker(lat, lng, name, type, color) {
    const iconHtml = type === 'mesh'
        ? `<div style="background-color: ${color}; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"><i class="bi bi-router"></i></div>`
        : `<div style="background-color: ${color}; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"><i class="bi bi-geo-alt-fill"></i></div>`;

    const marker = L.marker([lat, lng], {
        icon: L.divIcon({
            className: 'custom-coverage-marker',
            html: iconHtml,
            iconSize: [28, 28],
            iconAnchor: [14, 14]
        }),
        draggable: type === 'custom'
    }).addTo(map);

    marker.bindPopup(`<strong>${name}</strong><br>
        <small>${type === 'mesh' ? 'Mesh Node' : 'Custom Location'}</small><br>
        <small>Lat: ${lat.toFixed(5)}, Lng: ${lng.toFixed(5)}</small>`);

    // Allow dragging custom markers
    if (type === 'custom') {
        marker.on('dragend', function(e) {
            const node = coverageNodes.find(n => n.marker === marker);
            if (node) {
                const newPos = e.target.getLatLng();
                node.lat = newPos.lat;
                node.lng = newPos.lng;
                marker.setPopupContent(`<strong>${node.name}</strong><br>
                    <small>Custom Location</small><br>
                    <small>Lat: ${newPos.lat.toFixed(5)}, Lng: ${newPos.lng.toFixed(5)}</small>`);

                // Clear existing coverage if any
                if (node.coverageLayer) {
                    map.removeLayer(node.coverageLayer);
                    node.coverageLayer = null;
                }
            }
        });
    }

    return marker;
}

// Update the node list UI
function updateNodeList() {
    const container = document.getElementById('nodeListContainer');
    const countSpan = document.getElementById('nodeCount');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const calculateBtn = document.getElementById('calculateBtn');

    countSpan.textContent = coverageNodes.length;

    if (coverageNodes.length === 0) {
        container.innerHTML = `
            <div class="text-center text-muted py-4">
                <i class="bi bi-inbox display-6"></i>
                <p class="mb-0 mt-2">No nodes added yet</p>
                <small>Add nodes from the mesh or click the map</small>
            </div>`;
        clearAllBtn.style.display = 'none';
        calculateBtn.disabled = true;
        return;
    }

    clearAllBtn.style.display = 'block';
    calculateBtn.disabled = false;

    container.innerHTML = coverageNodes.map(node => `
        <div class="coverage-node-item" data-id="${node.id}">
            <div class="coverage-node-color" style="background-color: ${node.color.stroke};"></div>
            <div class="coverage-node-name" title="${node.name}">
                ${node.name}
                <br><small class="text-muted">${node.type === 'mesh' ? 'Mesh' : 'Custom'} • Alt: ${node.altitude.toFixed(0)}m</small>
                ${node.terrainAnalysis ? `<br><span class="badge ${node.terrainAnalysis.badgeClass} badge-sm">${node.terrainAnalysis.terrainClass}</span>
                    <small class="text-muted ms-1">${node.terrainAnalysis.suggestedRadiusKm}km @ ${node.terrainAnalysis.suggestedTxPower}</small>` :
                    '<br><small class="text-muted"><i class="bi bi-hourglass-split"></i> Analyzing...</small>'}
            </div>
            <div class="coverage-node-actions">
                <button class="btn btn-outline-info btn-sm" onclick="analyzeNodeTerrain(${node.id})" title="Re-analyze terrain">
                    <i class="bi bi-mountains"></i>
                </button>
                <button class="btn btn-outline-primary btn-sm" onclick="zoomToNode(${node.id})" title="Zoom to node">
                    <i class="bi bi-geo-alt"></i>
                </button>
                <button class="btn btn-outline-danger btn-sm" onclick="removeNode(${node.id})" title="Remove node">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

// Zoom to a specific node
function zoomToNode(nodeId) {
    const node = coverageNodes.find(n => n.id === nodeId);
    if (node) {
        map.setView([node.lat, node.lng], 12);
        node.marker.openPopup();
    }
}

// Remove a node
function removeNode(nodeId) {
    const index = coverageNodes.findIndex(n => n.id === nodeId);
    if (index !== -1) {
        const node = coverageNodes[index];
        if (node.marker) map.removeLayer(node.marker);
        if (node.coverageLayer) map.removeLayer(node.coverageLayer);
        coverageNodes.splice(index, 1);
        updateNodeList();
    }
}

// Clear all nodes
function clearAllNodes() {
    coverageNodes.forEach(node => {
        if (node.marker) map.removeLayer(node.marker);
        if (node.coverageLayer) map.removeLayer(node.coverageLayer);
    });
    coverageNodes = [];
    updateNodeList();
    showStatus('info', 'All nodes cleared');
}

// Update map bounds to show all nodes
function updateMapBounds() {
    if (coverageNodes.length === 0) return;

    const bounds = L.latLngBounds(coverageNodes.map(n => [n.lat, n.lng]));
    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 12 });
}

// Calculate coverage for all nodes
async function calculateAllCoverage() {
    if (coverageNodes.length === 0) return;

    const radiusKm = parseInt(document.getElementById('coverageRadius').value);
    const numRays = parseInt(document.getElementById('coverageResolution').value);
    const antennaHeight = parseFloat(document.getElementById('antennaHeight').value) || 10;

    const calculateBtn = document.getElementById('calculateBtn');
    calculateBtn.disabled = true;
    calculateBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Calculating...';

    try {
        // Clear existing coverage layers
        coverageNodes.forEach(node => {
            if (node.coverageLayer) {
                map.removeLayer(node.coverageLayer);
                node.coverageLayer = null;
            }
        });

        // Calculate coverage for each node
        for (let i = 0; i < coverageNodes.length; i++) {
            const node = coverageNodes[i];
            showStatus('loading', `Calculating coverage for ${node.name} (${i + 1}/${coverageNodes.length})...`);

            const observerHeight = node.altitude + antennaHeight;

            const coveragePolygons = await calculateViewshed(
                node.lat,
                node.lng,
                observerHeight,
                radiusKm,
                numRays
            );

            // Draw coverage
            const layer = drawCoverageOverlay(node, coveragePolygons);
            node.coverageLayer = layer;
        }

        // Draw overlap if enabled
        if (document.getElementById('showOverlap').checked && coverageNodes.length > 1) {
            // Overlap visualization would require polygon intersection - simplified version
            showStatus('success', `Coverage calculated for ${coverageNodes.length} nodes`);
        } else {
            showStatus('success', `Coverage calculated for ${coverageNodes.length} nodes`);
        }

    } catch (error) {
        console.error('Coverage calculation error:', error);
        showStatus('error', 'Error calculating coverage: ' + error.message);
    } finally {
        calculateBtn.disabled = false;
        calculateBtn.innerHTML = '<i class="bi bi-play-fill"></i> Calculate Coverage';
    }
}

// Calculate viewshed using radial elevation sampling
async function calculateViewshed(centerLat, centerLon, observerHeight, radiusKm, numRays) {
    const visibleSectors = [];
    const samplesPerRay = 20;
    const earthRadius = 6371;

    const batchSize = 8;
    const angleStep = 360 / numRays;

    for (let batchStart = 0; batchStart < numRays; batchStart += batchSize) {
        const batchPromises = [];

        for (let i = batchStart; i < Math.min(batchStart + batchSize, numRays); i++) {
            const angle = i * angleStep;
            batchPromises.push(analyzeRay(centerLat, centerLon, observerHeight, angle, radiusKm, samplesPerRay));
        }

        const batchResults = await Promise.all(batchPromises);

        batchResults.forEach((result, idx) => {
            const angle = (batchStart + idx) * angleStep;
            const nextAngle = angle + angleStep;

            if (result.visibleDistance > 0) {
                visibleSectors.push({
                    startAngle: angle,
                    endAngle: nextAngle,
                    distance: result.visibleDistance,
                    centerLat,
                    centerLon
                });
            }
        });

        // Small delay between batches
        if (batchStart + batchSize < numRays) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    return { visible: visibleSectors };
}

// Calculate Fresnel zone radius at a given point (same algorithm as line-of-sight tool)
function calculateFresnelZone(distanceFromTx, distanceToRx, frequency = 915) {
    // Fresnel zone radius in meters
    // frequency in MHz, distances in meters
    const wavelength = 299792458 / (frequency * 1000000); // meters
    const d1 = distanceFromTx;
    const d2 = distanceToRx;
    const totalDistance = d1 + d2;
    if (totalDistance === 0) return 0;
    // First Fresnel zone radius: r = sqrt(n * λ * d1 * d2 / (d1 + d2))
    // We use 60% of first Fresnel zone for practical clearance
    const fresnelRadius = 0.6 * Math.sqrt((wavelength * d1 * d2) / totalDistance);
    return fresnelRadius;
}

// Analyze a single ray for line-of-sight visibility with Fresnel zone clearance
// Uses the same algorithm as the line-of-sight analysis tool for accuracy
async function analyzeRay(centerLat, centerLon, observerHeight, angleDeg, maxDistanceKm, numSamples) {
    const earthRadius = 6371; // km
    const maxDistanceM = maxDistanceKm * 1000; // Convert to meters

    // Generate sample points along the ray
    const points = [];
    for (let i = 1; i <= numSamples; i++) {
        const distance = (i / numSamples) * maxDistanceKm;
        const point = destinationPoint(centerLat, centerLon, distance, angleDeg);
        points.push({ ...point, distance, distanceM: distance * 1000 });
    }

    // Fetch elevation for all points
    const elevations = await fetchElevationsForPoints(points);

    // If elevation API failed, return conservative estimate (half the max distance)
    if (elevations === null) {
        console.debug(`Ray ${angleDeg}°: Elevation API failed, using conservative estimate`);
        return { visibleDistance: maxDistanceKm * 0.5 };
    }

    // Check if we got real elevation data (not all zeros)
    const hasRealData = elevations.some(e => e !== 0);
    if (!hasRealData) {
        // Flat terrain or ocean - use slightly reduced coverage
        console.debug(`Ray ${angleDeg}°: Flat/ocean terrain detected, using 80% coverage`);
        return { visibleDistance: maxDistanceKm * 0.8 };
    }

    // Check line of sight with Fresnel zone clearance for each point
    // Simulating a receiver at antenna height above terrain at each sample point
    let visibleDistance = 0;

    // Assume receiver is also at same antenna height above local terrain
    const receiverAntennaHeight = 10; // meters above ground

    for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const terrainElevation = elevations[i] || 0;

        // Account for Earth curvature (drop in meters)
        const curvatureDrop = (point.distance * point.distance) / (2 * earthRadius) * 1000;

        // Effective terrain elevation accounting for Earth curvature
        const effectiveTerrainElev = terrainElevation - curvatureDrop;

        // Hypothetical receiver height at this location
        const receiverHeight = effectiveTerrainElev + receiverAntennaHeight;

        // Check if line-of-sight is clear to this point
        // by checking all intermediate points have sufficient Fresnel clearance
        let isVisible = true;

        for (let j = 1; j < i; j++) {
            const midPoint = points[j];
            const midTerrainElev = elevations[j] || 0;
            const midCurvatureDrop = (midPoint.distance * midPoint.distance) / (2 * earthRadius) * 1000;
            const effectiveMidElev = midTerrainElev - midCurvatureDrop;

            // Calculate line-of-sight elevation at this intermediate point
            const distanceRatio = midPoint.distanceM / point.distanceM;
            const losElevation = observerHeight + (receiverHeight - observerHeight) * distanceRatio;

            // Calculate required Fresnel zone clearance
            const fresnelClearance = calculateFresnelZone(
                midPoint.distanceM,
                point.distanceM - midPoint.distanceM
            );

            // Check if terrain blocks the signal (including Fresnel zone)
            const actualClearance = losElevation - effectiveMidElev;
            if (actualClearance < fresnelClearance * 0.6) { // 60% Fresnel zone rule
                isVisible = false;
                break;
            }
        }

        if (isVisible) {
            visibleDistance = point.distance;
        } else {
            break; // Once blocked, remaining distance is also blocked
        }
    }

    // Log significant terrain blockage
    if (visibleDistance < maxDistanceKm * 0.5) {
        console.debug(`Ray ${angleDeg}°: Terrain blocks at ${visibleDistance.toFixed(1)}km (max: ${maxDistanceKm}km)`);
    }

    return { visibleDistance };
}

// Calculate destination point given start, distance, and bearing
function destinationPoint(lat, lon, distanceKm, bearingDeg) {
    const R = 6371;
    const d = distanceKm / R;
    const brng = bearingDeg * Math.PI / 180;
    const lat1 = lat * Math.PI / 180;
    const lon1 = lon * Math.PI / 180;

    const lat2 = Math.asin(
        Math.sin(lat1) * Math.cos(d) +
        Math.cos(lat1) * Math.sin(d) * Math.cos(brng)
    );

    const lon2 = lon1 + Math.atan2(
        Math.sin(brng) * Math.sin(d) * Math.cos(lat1),
        Math.cos(d) - Math.sin(lat1) * Math.sin(lat2)
    );

    return {
        latitude: lat2 * 180 / Math.PI,
        longitude: lon2 * 180 / Math.PI
    };
}

// Fetch elevations for a batch of points using DEM Net API
async function fetchElevationsForPoints(points) {
    if (points.length === 0) return [];

    try {
        const startPoint = points[0];
        const endPoint = points[points.length - 1];

        const url = `https://api.elevationapi.com/api/Elevation/line/${startPoint.latitude.toFixed(6)},${startPoint.longitude.toFixed(6)}/${endPoint.latitude.toFixed(6)},${endPoint.longitude.toFixed(6)}?samples=${points.length}`;

        const response = await fetch(url);
        if (!response.ok) {
            console.warn('Elevation API error:', response.status, 'using fallback elevation data');
            // Return null to indicate API failure - caller should handle this
            return null;
        }

        const data = await response.json();

        if (data.geoPoints && Array.isArray(data.geoPoints)) {
            const elevations = data.geoPoints.map(p => p.elevation || 0);
            // Log for debugging
            if (elevations.some(e => e !== 0)) {
                console.debug(`Fetched ${elevations.length} elevation points, range: ${Math.min(...elevations)}m to ${Math.max(...elevations)}m`);
            }
            return elevations;
        }

        return null;

    } catch (error) {
        console.warn('Failed to fetch elevations:', error);
        return null;
    }
}

// Draw coverage overlay for a node
function drawCoverageOverlay(node, coveragePolygons) {
    const layerGroup = L.layerGroup();

    // Sort sectors by angle to ensure proper ordering
    const sortedSectors = [...coveragePolygons.visible].sort((a, b) => a.startAngle - b.startAngle);

    if (sortedSectors.length === 0) {
        return null;
    }

    const centerLat = sortedSectors[0].centerLat;
    const centerLon = sortedSectors[0].centerLon;

    // Create a smooth polygon by following the coverage boundary
    const smoothedPoints = [];

    for (let i = 0; i < sortedSectors.length; i++) {
        const sector = sortedSectors[i];
        // Generate multiple points along each sector's arc at its visible distance
        const arcPoints = generateArcPoints(
            sector.centerLat,
            sector.centerLon,
            sector.distance,
            sector.startAngle,
            sector.endAngle,
            3 // points per sector arc
        );
        smoothedPoints.push(...arcPoints);
    }

    if (smoothedPoints.length > 2) {
        const polygon = L.polygon(smoothedPoints, {
            color: node.color.stroke,
            fillColor: node.color.fill,
            fillOpacity: COVERAGE_FILL_OPACITY,
            weight: COVERAGE_STROKE_WEIGHT,
            opacity: COVERAGE_STROKE_OPACITY,
            smoothFactor: 1
        });

        polygon.bindPopup(`
            <strong>${node.name}</strong><br>
            <span style="color: ${node.color.stroke};">■</span> Coverage Area<br>
            <small class="text-muted">Line-of-sight coverage based on terrain elevation data</small>
        `);

        layerGroup.addLayer(polygon);

        // Draw radial lines to show sector boundaries (every 4th sector)
        sortedSectors.forEach((sector, idx) => {
            if (sector.distance > 0.5 && idx % 4 === 0) {
                const startPoint = destinationPoint(sector.centerLat, sector.centerLon, sector.distance, sector.startAngle);
                const radialLine = L.polyline([
                    [sector.centerLat, sector.centerLon],
                    [startPoint.latitude, startPoint.longitude]
                ], {
                    color: node.color.stroke,
                    weight: 1,
                    opacity: 0.3,
                    dashArray: '2,4'
                });
                layerGroup.addLayer(radialLine);
            }
        });
    }

    layerGroup.addTo(map);
    return layerGroup;
}

// Generate points along an arc
function generateArcPoints(centerLat, centerLon, radiusKm, startAngle, endAngle, numPoints) {
    const points = [];
    const angleStep = (endAngle - startAngle) / numPoints;

    for (let i = 0; i <= numPoints; i++) {
        const angle = startAngle + i * angleStep;
        const point = destinationPoint(centerLat, centerLon, radiusKm, angle);
        points.push([point.latitude, point.longitude]);
    }

    return points;
}

// Show status message
function showStatus(type, message) {
    const statusDiv = document.getElementById('statusMessage');
    statusDiv.style.display = 'block';

    statusDiv.className = 'alert mt-3';

    switch (type) {
        case 'loading':
            statusDiv.classList.add('alert-info');
            statusDiv.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>${message}`;
            break;
        case 'success':
            statusDiv.classList.add('alert-success');
            statusDiv.innerHTML = `<i class="bi bi-check-circle me-2"></i>${message}`;
            break;
        case 'error':
            statusDiv.classList.add('alert-danger');
            statusDiv.innerHTML = `<i class="bi bi-exclamation-triangle me-2"></i>${message}`;
            break;
        case 'warning':
            statusDiv.classList.add('alert-warning');
            statusDiv.innerHTML = `<i class="bi bi-exclamation-circle me-2"></i>${message}`;
            break;
        case 'info':
            statusDiv.classList.add('alert-info');
            statusDiv.innerHTML = `<i class="bi bi-info-circle me-2"></i>${message}`;
            break;
    }

    // Auto-hide non-loading messages
    if (type !== 'loading') {
        setTimeout(() => {
            statusDiv.style.display = 'none';
        }, 5000);
    }
}

// Make functions available globally for onclick handlers
window.zoomToNode = zoomToNode;
window.removeNode = removeNode;
window.analyzeNodeTerrain = analyzeNodeTerrain;

// ========================= Terrain Analysis =========================
// Analyze terrain around a node to determine position and suggest TX power

async function analyzeNodeTerrain(nodeId) {
    const node = coverageNodes.find(n => n.id === nodeId);
    if (!node) return;

    showStatus('loading', `Analyzing terrain for ${node.name}...`);

    try {
        const nodeLat = node.lat;
        const nodeLon = node.lng;
        const nodeAltitude = node.altitude || 0;

        // Fetch terrain elevation at node location
        let terrainAtNode = 0;
        const nodeElevResponse = await fetch(
            `https://api.elevationapi.com/api/Elevation?lat=${nodeLat}&lon=${nodeLon}`
        );
        if (nodeElevResponse.ok) {
            const nodeElevData = await nodeElevResponse.json();
            terrainAtNode = nodeElevData.elevation || 0;
        }

        // Sample terrain in 8 directions at multiple distances
        const directions = [0, 45, 90, 135, 180, 225, 270, 315];
        const distances = [0.5, 1, 2, 5]; // km
        const elevationValues = [];

        for (const direction of directions) {
            for (const distKm of distances) {
                const point = destinationPoint(nodeLat, nodeLon, distKm, direction);
                try {
                    const resp = await fetch(
                        `https://api.elevationapi.com/api/Elevation?lat=${point.latitude.toFixed(6)}&lon=${point.longitude.toFixed(6)}`
                    );
                    if (resp.ok) {
                        const data = await resp.json();
                        elevationValues.push(data.elevation || 0);
                    }
                    await new Promise(resolve => setTimeout(resolve, 30));
                } catch (e) {
                    console.warn('Failed to fetch elevation:', e);
                }
            }
        }

        // Calculate statistics
        const avgSurrounding = elevationValues.length > 0
            ? elevationValues.reduce((a, b) => a + b, 0) / elevationValues.length
            : 0;

        const nodeElevForComparison = nodeAltitude > 0 ? nodeAltitude : terrainAtNode;
        const prominence = nodeElevForComparison - avgSurrounding;

        // Determine terrain classification, TX power, and coverage radius recommendation
        let terrainClass, badgeClass, suggestedTxPower, suggestedRadiusKm;

        if (prominence > 100) {
            terrainClass = 'Mountain';
            badgeClass = 'bg-success';
            suggestedTxPower = '17-20 dBm';
            suggestedRadiusKm = 30; // Can see far from mountains
        } else if (prominence > 50) {
            terrainClass = 'Hilltop';
            badgeClass = 'bg-success';
            suggestedTxPower = '20-23 dBm';
            suggestedRadiusKm = 20;
        } else if (prominence > 20) {
            terrainClass = 'Elevated';
            badgeClass = 'bg-info';
            suggestedTxPower = '23-27 dBm';
            suggestedRadiusKm = 15;
        } else if (prominence > -20) {
            terrainClass = 'Level';
            badgeClass = 'bg-warning text-dark';
            suggestedTxPower = '27-30 dBm';
            suggestedRadiusKm = 10;
        } else if (prominence > -50) {
            terrainClass = 'Low';
            badgeClass = 'bg-secondary';
            suggestedTxPower = '30 dBm';
            suggestedRadiusKm = 5;
        } else {
            terrainClass = 'Valley';
            badgeClass = 'bg-danger';
            suggestedTxPower = '30 dBm (limited)';
            suggestedRadiusKm = 5;
        }

        // Store analysis on node
        node.terrainAnalysis = {
            terrainClass,
            badgeClass,
            suggestedTxPower,
            suggestedRadiusKm,
            prominence,
            avgSurrounding,
            terrainAtNode
        };

        // Auto-select the suggested coverage radius in the dropdown
        const radiusSelect = document.getElementById('coverageRadius');
        if (radiusSelect) {
            // Find the closest matching radius option
            const options = Array.from(radiusSelect.options);
            let bestOption = null;
            let bestDiff = Infinity;
            options.forEach(opt => {
                const optKm = parseInt(opt.value);
                const diff = Math.abs(optKm - suggestedRadiusKm);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestOption = opt;
                }
            });
            if (bestOption) {
                radiusSelect.value = bestOption.value;
            }
        }

        // Update UI
        updateNodeList();

        // Update marker popup with terrain info
        node.marker.setPopupContent(`<strong>${node.name}</strong><br>
            <small>${node.type === 'mesh' ? 'Mesh Node' : 'Custom Location'}</small><br>
            <small>Lat: ${node.lat.toFixed(5)}, Lng: ${node.lng.toFixed(5)}</small><br>
            <hr style="margin: 5px 0;">
            <strong>Terrain:</strong> <span class="badge ${badgeClass}">${terrainClass}</span><br>
            <strong>Prominence:</strong> ${prominence > 0 ? '+' : ''}${prominence.toFixed(0)}m<br>
            <strong>Suggested TX:</strong> ${suggestedTxPower}<br>
            <strong>Suggested Radius:</strong> ${suggestedRadiusKm} km`);

        showStatus('success', `${node.name}: ${terrainClass} (${prominence > 0 ? '+' : ''}${prominence.toFixed(0)}m) → TX: ${suggestedTxPower}, Radius: ${suggestedRadiusKm}km`);

    } catch (error) {
        console.error('Terrain analysis failed:', error);
        showStatus('error', `Failed to analyze terrain: ${error.message}`);
    }
}
</script>
{% endblock %}
